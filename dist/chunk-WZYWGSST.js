import {
  MatExpansionModule,
  MatExpansionPanel,
  MatExpansionPanelHeader,
  MatExpansionPanelTitle
} from "./chunk-UJWO3UBD.js";
import {
  LabelComponent
} from "./chunk-LAP7BRMJ.js";
import {
  EmployeeSalaryRepository
} from "./chunk-4UH7ID43.js";
import {
  GraphComponent,
  NgxGraphModule,
  arc_default,
  area_default,
  band,
  cardinalClosed_default,
  dispatch_default,
  format,
  interrupt_default,
  lineRadial_default,
  line_default,
  linear,
  linear_default,
  linkHorizontal,
  max,
  min,
  ordinal,
  pie_default,
  point,
  pointer_default,
  quantile,
  quantile2,
  range,
  select_default,
  sinInOut,
  time,
  value_default
} from "./chunk-IQBBWRS3.js";
import {
  FeedbackFormsRepository
} from "./chunk-KG3BOM3F.js";
import {
  EmployeeService
} from "./chunk-E3RI4QCV.js";
import {
  ObjectiveFormRepository
} from "./chunk-S5OCFGQY.js";
import {
  MatTableDataSource,
  TableComponent
} from "./chunk-X45EM66I.js";
import {
  CircleEmployeeImgComponent
} from "./chunk-BWIOX5TR.js";
import "./chunk-JYDETW4E.js";
import "./chunk-M2EJXGZP.js";
import {
  AppModalComponent,
  AppOptions,
  ChangeRequestsInsertDto,
  ComponentPortal,
  DocumentComponent,
  DocumentRepository,
  DocumentRowDto,
  DomPortalOutlet,
  FormInputComponent,
  ModalService
} from "./chunk-CRLS72DG.js";
import {
  ChangeRequestsRepository
} from "./chunk-4MP457FT.js";
import {
  SupabaseAuthService
} from "./chunk-726REOYR.js";
import {
  MatIconModule
} from "./chunk-ZKADD55Q.js";
import {
  Dir,
  FormBuilder,
  FormControlName,
  FormGroupDirective,
  FormsModule,
  MatButtonModule,
  NgControlStatus,
  NgControlStatusGroup,
  ReactiveFormsModule,
  StorageService,
  Validators,
  ɵNgNoValidate
} from "./chunk-JDSXESFV.js";
import "./chunk-PTMC7Z3G.js";
import "./chunk-NPYWTI7B.js";
import "./chunk-YB7VYXZC.js";
import "./chunk-BSJGXNL2.js";
import "./chunk-SNL7CR3M.js";
import "./chunk-POF6P2IF.js";
import "./chunk-BCSCWTDQ.js";
import "./chunk-XEW2RVSV.js";
import "./chunk-2R2VMYXT.js";
import "./chunk-34SSTWFD.js";
import "./chunk-PVOL3XIB.js";
import "./chunk-PPDZQ3XB.js";
import "./chunk-O2426PIE.js";
import "./chunk-CN2NLH3R.js";
import "./chunk-6VMHCKIO.js";
import "./chunk-Z4NK5ERE.js";
import "./chunk-CLKJFHPN.js";
import "./chunk-3IAPPBJB.js";
import "./chunk-4JBIDYYM.js";
import "./chunk-RNINX5QP.js";
import {
  EventConstants
} from "./chunk-FET6I6E4.js";
import {
  EventService
} from "./chunk-PYCXHYST.js";
import {
  EmployeeRepository
} from "./chunk-TLWCP54H.js";
import {
  EmployeeDto
} from "./chunk-NKEEF4XY.js";
import {
  AppConstants
} from "./chunk-LHQOL4PU.js";
import {
  IdService
} from "./chunk-YW5JDNY2.js";
import {
  BaseRepository,
  LoaderService,
  NgxSpinnerService,
  Router,
  SupabaseContext,
  TranslatePipe,
  TranslateService
} from "./chunk-HDIRTHWB.js";
import {
  ApplicationRef,
  AsyncPipe,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  CurrencyPipe,
  DatePipe,
  Directive,
  ElementRef,
  EventEmitter,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  Injector,
  Input,
  NgForOf,
  NgIf,
  NgModule,
  NgTemplateOutlet,
  NgZone,
  Output,
  PLATFORM_ID,
  Renderer2,
  Subject,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  __decorate,
  animate,
  debounceTime,
  fromEvent,
  isPlatformBrowser,
  isPlatformServer,
  setClassMetadata,
  style,
  transition,
  trigger,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵviewQuery
} from "./chunk-ERGQW4H6.js";
import "./chunk-KQ2G4OE2.js";
import "./chunk-N6SQHGEH.js";
import "./chunk-RTA6YFKO.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XVQ6O2EZ.js";

// src/app/shared/directives/enlarge-image.directive.ts
var EnlargeImageDirective = class _EnlargeImageDirective {
  el;
  constructor(el) {
    this.el = el;
  }
  onMouseOver() {
    const enlargeImageContainer = document.getElementById("enlargeImageContainer");
    if (enlargeImageContainer) {
      enlargeImageContainer.innerHTML = "";
      const enlargedImage = document.createElement("img");
      enlargedImage.src = this.el.nativeElement.src;
      enlargeImageContainer.appendChild(enlargedImage);
      enlargeImageContainer.style.display = "block";
    }
  }
  onMouseOut() {
    const enlargeImageContainer = document.getElementById("enlargeImageContainer");
    if (enlargeImageContainer) {
      enlargeImageContainer.innerHTML = "";
      enlargeImageContainer.style.display = "none";
    }
  }
  static \u0275fac = function EnlargeImageDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EnlargeImageDirective)(\u0275\u0275directiveInject(ElementRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _EnlargeImageDirective, selectors: [["", "appEnlargeImage", ""]], hostBindings: function EnlargeImageDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseover", function EnlargeImageDirective_mouseover_HostBindingHandler() {
        return ctx.onMouseOver();
      })("mouseout", function EnlargeImageDirective_mouseout_HostBindingHandler() {
        return ctx.onMouseOut();
      });
    }
  }, standalone: false });
};

// src/supabase/types/employee-document.dto.ts
var EmployeeDocumentRowDto = class {
  document_id;
  employee_id;
  id;
  constructor(param = null) {
    if (param) {
      this.document_id = param.document_id;
      this.employee_id = param.employee_id;
      this.id = param.id;
    }
  }
};

// src/app/shared/models/dto/employee/employee-document.dto.ts
var EmployeeDocumentDto = class extends EmployeeDocumentRowDto {
  document;
  constructor() {
    super();
    this.document = new DocumentRowDto();
  }
};

// src/supabase/repositories/employee-document.repository.ts
var EmployeeDocumentRepository = class _EmployeeDocumentRepository extends BaseRepository {
  supabaseService;
  spinner;
  loaderService;
  constructor(supabaseService, spinner, loaderService) {
    super(supabaseService, "employee_document", spinner, loaderService);
    this.supabaseService = supabaseService;
    this.spinner = spinner;
    this.loaderService = loaderService;
  }
  getNestedForEmployee(fieldName, rowId) {
    return __async(this, null, function* () {
      const { data, error } = yield this.client.from(this.tableName).select("*, document(*)").eq(fieldName, rowId);
      if (error) {
        this.spinner.hide();
        this.loaderService.hide();
        console.error("Error fetching data:", error);
        return null;
      }
      return data ? data : null;
    });
  }
  getDocsForEmployeeByType(employeeId, type2) {
    return __async(this, null, function* () {
      const { data, error } = yield this.client.from(this.tableName).select("*, document!inner(*)").eq("document.type", type2).eq("employee_id", employeeId);
      if (error) {
        this.spinner.hide();
        this.loaderService.hide();
        console.error("Error fetching data:", error);
        return null;
      }
      return data ? data : null;
    });
  }
  static \u0275fac = function EmployeeDocumentRepository_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EmployeeDocumentRepository)(\u0275\u0275inject(SupabaseContext), \u0275\u0275inject(NgxSpinnerService), \u0275\u0275inject(LoaderService));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _EmployeeDocumentRepository, factory: _EmployeeDocumentRepository.\u0275fac, providedIn: "root" });
};

// src/app/main/employee/profile/components/documents/documents.component.ts
var _c0 = ["documentModal"];
var _c1 = ["docComponent"];
function DocumentsComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8)(1, "div", 9);
    \u0275\u0275listener("click", function DocumentsComponent_div_1_Template_div_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.openModal());
    });
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button");
    \u0275\u0275element(6, "i", 10);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 1, "Add"));
  }
}
function DocumentsComponent_ng_container_3_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1, "expand_more");
    \u0275\u0275elementEnd();
  }
}
function DocumentsComponent_ng_container_3_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1, "expand_less");
    \u0275\u0275elementEnd();
  }
}
function DocumentsComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "mat-expansion-panel", 11, 2)(3, "mat-expansion-panel-header");
    \u0275\u0275template(4, DocumentsComponent_ng_container_3_span_4_Template, 2, 0, "span", 12)(5, DocumentsComponent_ng_container_3_span_5_Template, 2, 0, "span", 12);
    \u0275\u0275elementStart(6, "mat-panel-title");
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "app-table", 13);
    \u0275\u0275listener("action", function DocumentsComponent_ng_container_3_Template_app_table_action_9_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActionClick($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const section_r4 = ctx.$implicit;
    const panel_r5 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !panel_r5.expanded);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", panel_r5.expanded);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 5, section_r4.name), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("columns", ctx_r1.columns)("dataSource", section_r4.dataSource);
  }
}
function DocumentsComponent_ng_template_4_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275element(1, "app-form-input", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const input_r7 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("formControlName", input_r7.formControlName)("settings", input_r7);
  }
}
function DocumentsComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 15)(1, "form", 16);
    \u0275\u0275listener("ngSubmit", function DocumentsComponent_ng_template_4_Template_form_ngSubmit_1_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275template(2, DocumentsComponent_ng_template_4_div_2_Template, 2, 2, "div", 17);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("formGroup", ctx_r1.documentForm);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.formInputs);
  }
}
var DocumentsComponent = class _DocumentsComponent {
  modalService;
  employeeDocumentRepository;
  supabaseAuthService;
  employeeService;
  translate;
  spinner;
  loaderService;
  fb;
  eventService;
  documentModal = null;
  docComponent;
  currentDocument = new EmployeeDocumentDto();
  documentForm;
  columns = [
    { title: "Document name", field: "document.name", width: "70%" },
    {
      width: "30%",
      field: "actions",
      title: "Actions",
      type: "buttons",
      columnClass: "text-center",
      columnHeaderClass: "text-center",
      buttons: [
        { name: "View Document", icon: "document-outline", class: "icon-eye", visible: () => true },
        // { name: 'Edit', icon: 'create-outline', class: 'icon-edit', visible: () => this.currentEmployee?.isAdmin() },
        { name: "Delete", icon: "trash-outline", class: "icon-trash", visible: () => this.currentEmployee?.isAdmin() }
      ]
    }
  ];
  formInputs = [
    {
      formControlName: "name",
      type: "text",
      label: "Document name",
      id: "name",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return this.documentForm.get("document_id")?.value;
      }
    },
    {
      formControlName: "type",
      type: "select",
      label: "Document Type",
      id: "type",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      options: AppOptions.getContractTypeOptions(),
      disabled: () => {
        return this.documentForm.get("document_id")?.value;
      }
    },
    {
      formControlName: "document_id",
      type: "file",
      label: "Document",
      id: "document_id",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return !this.documentForm.get("type")?.value || !this.documentForm.get("name")?.value;
      },
      additional: {
        documentType: () => {
          return this.documentForm.get("type")?.value;
        },
        documentName: () => {
          return this.documentForm.get("name")?.value;
        }
      }
    }
  ];
  sections = [
    { type: "agreements", name: "Employment agreements", dataSource: new MatTableDataSource() },
    { type: "role-definitions", name: "Role definition", dataSource: new MatTableDataSource() },
    { type: "grants", name: "Grants", dataSource: new MatTableDataSource() }
  ];
  currentEmployee;
  profileEmployee;
  viewedDocument = new DocumentRowDto();
  dialogRef = null;
  constructor(modalService, employeeDocumentRepository, supabaseAuthService, employeeService, translate, spinner, loaderService, fb, eventService) {
    this.modalService = modalService;
    this.employeeDocumentRepository = employeeDocumentRepository;
    this.supabaseAuthService = supabaseAuthService;
    this.employeeService = employeeService;
    this.translate = translate;
    this.spinner = spinner;
    this.loaderService = loaderService;
    this.fb = fb;
    this.eventService = eventService;
    this.documentForm = this.fb.group({
      name: [null, []],
      // Optional, no validation
      document_id: [null, [Validators.required]],
      // Required field
      type: [null]
      // Required field
    });
  }
  ngOnInit() {
    this.initData();
    this.supabaseAuthService.getEmployee$().subscribe((result) => {
      this.currentEmployee = result;
    });
    this.employeeService.profileEmployeeSubject.subscribe((result) => {
      this.profileEmployee = result;
      this.initData();
    });
  }
  initData() {
    this.sections.forEach((section) => {
      if (this.profileEmployee?.getEmployeeId()) {
        this.employeeDocumentRepository.getDocsForEmployeeByType(this.profileEmployee?.getEmployeeId(), section.type).then((data) => {
          if (data) {
            section.dataSource.data = data;
          }
          this.spinner.hide();
          this.loaderService.hide();
        }).catch((error) => {
          this.spinner.hide();
          this.loaderService.hide();
          this.eventService.next(EventConstants.CONTRACTS_LOAD_ERROR, { employeeId: this.profileEmployee?.getEmployeeId(), sectionType: section.type, error });
        });
      }
    });
  }
  openContractDocument(documentComponent) {
    documentComponent.onPreviewClick(this.viewedDocument);
  }
  closeModal() {
    if (this.dialogRef) {
      this.modalService.hide(this.dialogRef);
    }
  }
  clearForm() {
    this.currentDocument = new EmployeeDocumentDto();
    this.documentForm.patchValue(this.currentDocument);
  }
  openModal(contractId = null) {
    if (contractId) {
      let doc = this.sections.flatMap((section) => section.dataSource.data).find((data) => data.id === contractId);
      if (doc) {
        this.currentDocument = doc;
        this.documentForm.get("document_id")?.setValue(this.currentDocument.document_id);
        this.documentForm.get("type")?.setValue(this.currentDocument.document?.type);
        this.documentForm.get("name")?.setValue(this.currentDocument.document?.name);
        this.eventService.next(EventConstants.CONTRACT_VIEWED, { contract: doc });
      }
    }
    this.dialogRef = this.modalService.show(AppModalComponent, {
      data: {
        title: this.translate.instant("Document"),
        template: this.documentModal,
        showCancelButton: true,
        confirmText: this.translate.instant("Save"),
        cancelText: this.translate.instant("Cancel"),
        onConfirm: () => __async(this, null, function* () {
          return yield this.onSubmit();
        })
      }
    });
  }
  onSubmit() {
    return __async(this, null, function* () {
      if (this.documentForm.valid) {
        try {
          let data = this.documentForm.getRawValue();
          data.employee_id = this.profileEmployee?.getEmployeeId();
          delete data.name;
          delete data.type;
          this.spinner.show();
          this.loaderService.show();
          yield this.employeeDocumentRepository.create(data);
          this.initData();
          this.clearForm();
          this.spinner.hide();
          this.loaderService.hide();
          this.eventService.next(EventConstants.CONTRACT_CREATED, { data });
          return true;
        } catch (error) {
          this.spinner.hide();
          this.loaderService.hide();
          this.eventService.next(EventConstants.CONTRACT_CREATE_ERROR, { error });
          return false;
        }
      }
      this.documentForm.markAllAsTouched();
      return false;
    });
  }
  deleteContract(contractId) {
    this.translate.get("Do you want to delete this Contract?").subscribe((message) => {
      if (confirm(message)) {
        this.spinner.show();
        this.loaderService.show();
        this.employeeDocumentRepository.delete(contractId).then(() => {
          this.initData();
          this.eventService.next(EventConstants.CONTRACT_DELETED, { contractId });
        }).catch((error) => {
          this.spinner.hide();
          this.loaderService.hide();
          this.eventService.next(EventConstants.CONTRACT_DELETE_ERROR, { contractId, error });
        });
      }
    });
  }
  onActionClick(event) {
    switch (event.action) {
      case "View Document": {
        this.viewedDocument = event.data.document;
        this.openContractDocument(this.docComponent);
        break;
      }
      case "Edit": {
        this.openModal(event.data.id);
        break;
      }
      case "Delete": {
        this.deleteContract(event.data.id);
        break;
      }
    }
  }
  openDocumentModal() {
    this.dialogRef = this.modalService.show(AppModalComponent, {
      data: {
        title: this.translate.instant("Document"),
        template: this.documentModal
      }
    });
  }
  closeDocumentModal() {
    this.dialogRef?.close();
  }
  static \u0275fac = function DocumentsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DocumentsComponent)(\u0275\u0275directiveInject(ModalService), \u0275\u0275directiveInject(EmployeeDocumentRepository), \u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(TranslateService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(LoaderService), \u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(EventService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DocumentsComponent, selectors: [["app-documents"]], viewQuery: function DocumentsComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c0, 5);
      \u0275\u0275viewQuery(_c1, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.documentModal = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.docComponent = _t.first);
    }
  }, decls: 8, vars: 4, consts: [["documentModal", ""], ["docComponent", ""], ["panel", ""], [1, "about-tab-block", "p-2"], ["class", "d-flex justify-content-between mt-2", 4, "ngIf"], [1, "pb-5", "height-adj"], [4, "ngFor", "ngForOf"], [3, "document", "hidden"], [1, "d-flex", "justify-content-between", "mt-2"], [1, "add-btn", "d-flex", "align-items-center", "gap-2", 3, "click"], [1, "fa-solid", "fa-circle-plus"], ["hideToggle", ""], ["class", "material-icons", 4, "ngIf"], ["tableLayout", "fixed", "tableClasses", "app-table no-wrap", 3, "action", "columns", "dataSource"], [1, "material-icons"], [1, "row"], [1, "row", 3, "ngSubmit", "formGroup"], ["class", "mt-2 col-12", 4, "ngFor", "ngForOf"], [1, "mt-2", "col-12"], [3, "formControlName", "settings"]], template: function DocumentsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 3);
      \u0275\u0275template(1, DocumentsComponent_div_1_Template, 7, 3, "div", 4);
      \u0275\u0275elementStart(2, "div", 5);
      \u0275\u0275template(3, DocumentsComponent_ng_container_3_Template, 10, 7, "ng-container", 6);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, DocumentsComponent_ng_template_4_Template, 3, 2, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275element(6, "app-document", 7, 1);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.currentEmployee == null ? null : ctx.currentEmployee.isAdmin());
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.sections);
      \u0275\u0275advance(3);
      \u0275\u0275property("document", ctx.viewedDocument)("hidden", true);
    }
  }, dependencies: [
    CommonModule,
    NgForOf,
    NgIf,
    DocumentComponent,
    FormInputComponent,
    ReactiveFormsModule,
    \u0275NgNoValidate,
    NgControlStatus,
    NgControlStatusGroup,
    FormGroupDirective,
    FormControlName,
    TranslatePipe,
    TableComponent,
    MatExpansionModule,
    MatExpansionPanel,
    MatExpansionPanelHeader,
    MatExpansionPanelTitle,
    MatButtonModule
  ], styles: ["\n\n  .mat-expansion-panel {\n  background-color: rgb(253, 253, 252) !important;\n  color: black !important;\n  border-radius: 0px !important;\n}\n  .mat-expansion-panel .mat-expansion-panel-header-title {\n  color: var(--main-color);\n  font-weight: bold;\n  font-size: 14px;\n}\n  .action-btn ul {\n  padding: 0px !important;\n}\n  .action-btn ul li {\n  white-space: nowrap;\n  padding: 0px !important;\n}\n/*# sourceMappingURL=documents.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DocumentsComponent, { className: "DocumentsComponent", filePath: "src/app/main/employee/profile/components/documents/documents.component.ts", lineNumber: 42 });
})();

// src/supabase/types/employee-education.dto.ts
var EmployeeEducationRowDto = class {
  description;
  document_id;
  education_date;
  employee_id;
  id;
  title;
  constructor(param = null) {
    if (param) {
      this.description = param.description;
      this.document_id = param.document_id;
      this.education_date = param.education_date;
      this.employee_id = param.employee_id;
      this.id = param.id;
      this.title = param.title;
    }
  }
};

// src/supabase/repositories/employee-education.repository.ts
var EmployeeEducationRepository = class _EmployeeEducationRepository extends BaseRepository {
  supabaseService;
  spinner;
  loaderService;
  constructor(supabaseService, spinner, loaderService) {
    super(supabaseService, "employee_education", spinner, loaderService);
    this.supabaseService = supabaseService;
    this.spinner = spinner;
    this.loaderService = loaderService;
  }
  getAllNestedWithDocumentsForEmployee(rowId) {
    return __async(this, null, function* () {
      const { data, error } = yield this.client.from(this.tableName).select("*, document(*)").eq("employee_id", rowId);
      if (error) {
        this.spinner.hide();
        this.loaderService.hide();
        console.error("Error fetching data:", error);
        return null;
      }
      return data ? data : null;
    });
  }
  static \u0275fac = function EmployeeEducationRepository_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EmployeeEducationRepository)(\u0275\u0275inject(SupabaseContext), \u0275\u0275inject(NgxSpinnerService), \u0275\u0275inject(LoaderService));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _EmployeeEducationRepository, factory: _EmployeeEducationRepository.\u0275fac, providedIn: "root" });
};

// src/app/main/employee/profile/components/education/education.component.ts
var _c02 = ["documentModal"];
var _c12 = ["docComponent"];
function EducationComponent_ng_container_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275listener("click", function EducationComponent_ng_container_1_div_3_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.openModal());
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button");
    \u0275\u0275element(5, "i", 13);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(3, 1, "Add"));
  }
}
function EducationComponent_ng_container_1_ng_container_15_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 20);
    \u0275\u0275listener("click", function EducationComponent_ng_container_1_ng_container_15_span_4_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const educationDocument_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      $event.stopImmediatePropagation();
      return \u0275\u0275resetView(ctx_r1.openEducationDocument(educationDocument_r4));
    });
    \u0275\u0275text(1, "edit");
    \u0275\u0275elementEnd();
  }
}
function EducationComponent_ng_container_1_ng_container_15_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 21);
    \u0275\u0275text(1, "expand_more");
    \u0275\u0275elementEnd();
  }
}
function EducationComponent_ng_container_1_ng_container_15_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 21);
    \u0275\u0275text(1, "expand_less");
    \u0275\u0275elementEnd();
  }
}
function EducationComponent_ng_container_1_ng_container_15_ng_container_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "app-document", 22);
    \u0275\u0275listener("decline", function EducationComponent_ng_container_1_ng_container_15_ng_container_14_Template_app_document_decline_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const educationDocument_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeclineClick($event, educationDocument_r4));
    })("approve", function EducationComponent_ng_container_1_ng_container_15_ng_container_14_Template_app_document_approve_1_listener() {
      \u0275\u0275restoreView(_r5);
      const educationDocument_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onApproveClick(educationDocument_r4));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const educationDocument_r4 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("isApprove", ctx_r1.profileEmployee && ctx_r1.profileEmployee.isAdmin() || false)("isUnderReview", ctx_r1.profileEmployee && !ctx_r1.profileEmployee.isAdmin() || false)("isDeleteVisible", false)("document", educationDocument_r4 == null ? null : educationDocument_r4.document);
  }
}
function EducationComponent_ng_container_1_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "mat-expansion-panel", 14, 2)(3, "mat-expansion-panel-header");
    \u0275\u0275template(4, EducationComponent_ng_container_1_ng_container_15_span_4_Template, 2, 0, "span", 15);
    \u0275\u0275elementStart(5, "div", 16);
    \u0275\u0275template(6, EducationComponent_ng_container_1_ng_container_15_span_6_Template, 2, 0, "span", 17)(7, EducationComponent_ng_container_1_ng_container_15_span_7_Template, 2, 0, "span", 17);
    \u0275\u0275elementStart(8, "span");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "span", 10);
    \u0275\u0275text(11);
    \u0275\u0275pipe(12, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(13, "div", 18);
    \u0275\u0275template(14, EducationComponent_ng_container_1_ng_container_15_ng_container_14_Template, 2, 4, "ng-container", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const educationDocument_r4 = ctx.$implicit;
    const panel_r6 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r1.profileEmployee && ctx_r1.profileEmployee.isAdmin());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !panel_r6.expanded);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", panel_r6.expanded);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(educationDocument_r4.title);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(12, 7, educationDocument_r4.education_date, "dd/MM/yyy"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("innerHTML", educationDocument_r4.description, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", educationDocument_r4 == null ? null : educationDocument_r4.document);
  }
}
function EducationComponent_ng_container_1_ng_container_16_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 21);
    \u0275\u0275text(1, "expand_more");
    \u0275\u0275elementEnd();
  }
}
function EducationComponent_ng_container_1_ng_container_16_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 21);
    \u0275\u0275text(1, "expand_less");
    \u0275\u0275elementEnd();
  }
}
function EducationComponent_ng_container_1_ng_container_16_a_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 25);
    \u0275\u0275listener("click", function EducationComponent_ng_container_1_ng_container_16_a_12_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const educationDocument_r8 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      $event.stopImmediatePropagation();
      return \u0275\u0275resetView(ctx_r1.deleteEducationDocument(educationDocument_r8));
    });
    \u0275\u0275element(1, "i", 26);
    \u0275\u0275pipe(2, "translate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("title", \u0275\u0275pipeBind1(2, 1, "Delete"));
  }
}
function EducationComponent_ng_container_1_ng_container_16_a_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 25);
    \u0275\u0275listener("click", function EducationComponent_ng_container_1_ng_container_16_a_13_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const educationDocument_r8 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      $event.stopImmediatePropagation();
      return \u0275\u0275resetView(ctx_r1.openEducationDocument(educationDocument_r8));
    });
    \u0275\u0275element(1, "i", 27);
    \u0275\u0275pipe(2, "translate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("title", \u0275\u0275pipeBind1(2, 1, "Edit"));
  }
}
function EducationComponent_ng_container_1_ng_container_16_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "app-document", 28);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const educationDocument_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("isDeleteVisible", false)("document", educationDocument_r8 == null ? null : educationDocument_r8.document);
  }
}
function EducationComponent_ng_container_1_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "mat-expansion-panel", 14, 2)(3, "mat-expansion-panel-header")(4, "div", 23);
    \u0275\u0275template(5, EducationComponent_ng_container_1_ng_container_16_span_5_Template, 2, 0, "span", 17)(6, EducationComponent_ng_container_1_ng_container_16_span_6_Template, 2, 0, "span", 17);
    \u0275\u0275elementStart(7, "span");
    \u0275\u0275text(8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "span", 10);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "date");
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, EducationComponent_ng_container_1_ng_container_16_a_12_Template, 3, 3, "a", 24)(13, EducationComponent_ng_container_1_ng_container_16_a_13_Template, 3, 3, "a", 24);
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "div", 18);
    \u0275\u0275template(15, EducationComponent_ng_container_1_ng_container_16_ng_container_15_Template, 2, 2, "ng-container", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const educationDocument_r8 = ctx.$implicit;
    const panel_r10 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !panel_r10.expanded);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", panel_r10.expanded);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(educationDocument_r8.title);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(11, 8, educationDocument_r8.education_date, "dd/MM/yyy"), " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.profileEmployee && ctx_r1.profileEmployee.isAdmin());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.profileEmployee && ctx_r1.profileEmployee.isAdmin());
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", educationDocument_r8.description, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", educationDocument_r8 == null ? null : educationDocument_r8.document);
  }
}
function EducationComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 5);
    \u0275\u0275element(2, "app-label", 6);
    \u0275\u0275template(3, EducationComponent_ng_container_1_div_3_Template, 6, 3, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 8)(5, "div", 9)(6, "h6", 10);
    \u0275\u0275text(7);
    \u0275\u0275pipe(8, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "h6", 10);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "h6", 11);
    \u0275\u0275text(13);
    \u0275\u0275pipe(14, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(15, EducationComponent_ng_container_1_ng_container_15_Template, 15, 10, "ng-container", 3)(16, EducationComponent_ng_container_1_ng_container_16_Template, 16, 11, "ng-container", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const section_r11 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("settings", section_r11.label);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.profileEmployee);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(8, 7, "Name"), "");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(11, 9, "Education date"), "");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(14, 11, "Actions"), "");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.filteredRequestedDocuments(section_r11.type));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.educationDocuments);
  }
}
function EducationComponent_ng_template_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 31);
    \u0275\u0275element(1, "app-form-input", 32);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const input_r13 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("formControlName", input_r13.formControlName)("settings", input_r13);
  }
}
function EducationComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 29);
    \u0275\u0275listener("ngSubmit", function EducationComponent_ng_template_2_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275template(1, EducationComponent_ng_template_2_div_1_Template, 2, 2, "div", 30);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("formGroup", ctx_r1.documentForm);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.formInputs);
  }
}
var EducationComponent = class _EducationComponent {
  storageService;
  documentRepository;
  educationDocumentRepository;
  supabaseAuthService;
  employeeService;
  spinner;
  changeRequestsRepository;
  translate;
  modalService;
  fb;
  loaderService;
  eventService;
  documentModal = null;
  docComponent;
  changeRequests;
  educationDocuments;
  requests;
  sections = [
    {
      type: "degrees",
      label: { title: "", type: "profile-label", icon: "document-attach-outline" }
    }
  ];
  profileEmployee;
  currentEmployee;
  currentEducationDocument = {};
  viewedDocument = {};
  documentForm;
  dialogRef = null;
  formInputs = [
    {
      formControlName: "title",
      type: "text",
      label: "Document name",
      id: "name",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return this.documentForm.get("document_id")?.value;
      }
    },
    {
      formControlName: "education_date",
      type: "date",
      label: "Date",
      id: "education_date",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return this.documentForm.get("document_id")?.value;
      }
    },
    {
      formControlName: "description",
      type: "textarea",
      label: "Description",
      id: "description",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return this.documentForm.get("document_id")?.value;
      }
    },
    {
      formControlName: "document_id",
      type: "file",
      label: "Document",
      id: "document_id",
      labelClass: "app-label",
      inputClass: "w-100",
      formFieldClass: "w-100",
      appearance: "outline",
      disabled: () => {
        return !this.documentForm.get("education_date")?.value;
      },
      additional: {
        documentType: () => {
          return "degrees";
        }
      }
    }
  ];
  constructor(storageService, documentRepository, educationDocumentRepository, supabaseAuthService, employeeService, spinner, changeRequestsRepository, translate, modalService, fb, loaderService, eventService) {
    this.storageService = storageService;
    this.documentRepository = documentRepository;
    this.educationDocumentRepository = educationDocumentRepository;
    this.supabaseAuthService = supabaseAuthService;
    this.employeeService = employeeService;
    this.spinner = spinner;
    this.changeRequestsRepository = changeRequestsRepository;
    this.translate = translate;
    this.modalService = modalService;
    this.fb = fb;
    this.loaderService = loaderService;
    this.eventService = eventService;
    this.documentForm = this.fb.group({
      id: null,
      title: [null, []],
      // Optional, no validation
      education_date: [null],
      description: [null],
      document_id: [null, [Validators.required]]
      // Required field
    });
  }
  ngOnInit() {
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      this.currentEmployee = employee;
    });
    this.employeeService.profileEmployeeSubject.subscribe((result) => {
      this.profileEmployee = result;
      this.initData();
    });
  }
  filteredRequestedDocuments(type2) {
    return this.requests ? this.requests.filter((x2) => x2.document.type == type2) : [];
  }
  addEducationDocumentClick() {
    this.currentEducationDocument.employee_id = this.profileEmployee?.getEmployeeId();
  }
  addChangeRequest(data) {
    if (this.profileEmployee?.getEmployeeId()) {
      let changeRequest = new ChangeRequestsInsertDto();
      changeRequest.created_at = (/* @__PURE__ */ new Date()).toLocaleDateString();
      changeRequest.display_field_name = this.translate.instant("Degrees");
      changeRequest.field_name = "degrees";
      changeRequest.new_value = data.document_id;
      changeRequest.requester_info = {
        displayName: this.currentEmployee?.hebrew_display_name ? this.currentEmployee.hebrew_display_name : this.currentEmployee?.display_name,
        employeeId: this.profileEmployee?.getEmployeeId(),
        new_value_display: data.title,
        education_date: data.education_date
      };
      changeRequest.target_id = this.profileEmployee?.getEmployeeId() || 0;
      changeRequest.target_table = "employee_education";
      this.changeRequestsRepository.create(changeRequest).then(() => {
        this.initChangeRequestsData();
        this.spinner.hide();
        this.loaderService.hide();
        this.eventService.next(EventConstants.EDUCATION_CHANGE_REQUEST_ADDED, { data });
      });
    }
  }
  openEducationDocument(employeeEducation) {
    this.currentEducationDocument = employeeEducation;
    this.documentForm.patchValue(this.currentEducationDocument);
    this.openModal();
  }
  closeModal() {
    if (this.dialogRef) {
      this.modalService.hide(this.dialogRef);
    }
  }
  clearForm() {
    this.currentEducationDocument = new EmployeeEducationRowDto();
    this.documentForm.patchValue(this.currentEducationDocument);
  }
  openModal(contractId = null) {
    this.dialogRef = this.modalService.show(AppModalComponent, {
      data: {
        title: this.translate.instant("Education Document"),
        template: this.documentModal,
        showCancelButton: true,
        confirmText: this.translate.instant("Save"),
        cancelText: this.translate.instant("Cancel"),
        onConfirm: () => __async(this, null, function* () {
          return yield this.onSubmit();
        })
      }
    });
  }
  deleteEducationDocument(educationDocument) {
    this.translate.get("Do you want to delete this Contract?").subscribe((message) => {
      if (confirm(message)) {
        this.spinner.show();
        this.loaderService.show();
        this.educationDocumentRepository.delete(educationDocument.id).then(() => {
          this.initData();
          this.eventService.next(EventConstants.EDUCATION_DELETED, { educationDocument });
        }).catch((error) => {
          this.spinner.hide();
          this.loaderService.hide();
          this.eventService.next(EventConstants.EDUCATION_DELETE_ERROR, { educationDocument, error });
        });
      }
    });
  }
  onSubmit() {
    return __async(this, null, function* () {
      if (this.documentForm.valid) {
        try {
          let data = this.documentForm.getRawValue();
          this.spinner.show();
          this.loaderService.show();
          delete data.id;
          data.employee_id = this.profileEmployee?.getEmployeeId();
          let id2 = this.documentForm.get("id")?.value;
          if (this.currentEmployee?.isAdmin()) {
            if (id2) {
              yield this.educationDocumentRepository.update(id2, data);
              this.eventService.next(EventConstants.EDUCATION_UPDATED, { data });
            } else {
              yield this.educationDocumentRepository.create(data);
              this.eventService.next(EventConstants.EDUCATION_CREATED, { data });
            }
            this.initData();
            this.clearForm();
            return true;
          } else {
            yield this.addChangeRequest(data);
            return true;
          }
        } catch (error) {
          this.eventService.next(EventConstants.EDUCATION_SUBMIT_ERROR, { error });
          return false;
        }
      }
      this.documentForm.markAllAsTouched();
      return false;
    });
  }
  onApproveClick(changeRequest) {
    if (changeRequest && changeRequest.document_id) {
      this.changeRequestsRepository.delete(changeRequest.id).then(() => {
        delete changeRequest.id;
        delete changeRequest.document;
        this.educationDocumentRepository.create(changeRequest).then(() => {
          this.initData();
          this.clearForm();
          this.eventService.next(EventConstants.EDUCATION_APPROVED, { changeRequest });
        }).catch((error) => {
          this.eventService.next(EventConstants.EDUCATION_APPROVE_ERROR, { changeRequest, error });
        });
      }).catch((error) => {
        this.eventService.next(EventConstants.EDUCATION_APPROVE_ERROR, { changeRequest, error });
      });
    }
  }
  onDeclineClick(document2, changeRequest) {
    if (changeRequest && changeRequest.id) {
      this.changeRequestsRepository.delete(changeRequest.id).then(() => {
        if (document2 && document2.id) {
          this.documentRepository.delete(document2.id).then(() => {
            this.initChangeRequestsData();
            this.eventService.next(EventConstants.EDUCATION_DECLINED, { document: document2, changeRequest });
          }).catch((error) => {
            this.eventService.next(EventConstants.EDUCATION_DECLINE_ERROR, { document: document2, changeRequest, error });
          });
        }
      }).catch((error) => {
        this.eventService.next(EventConstants.EDUCATION_DECLINE_ERROR, { document: document2, changeRequest, error });
      });
    }
  }
  onDeleteClick(educationDocument) {
    this.educationDocumentRepository.delete(educationDocument.id).then(() => {
      this.initData();
      this.eventService.next(EventConstants.EDUCATION_DELETED, { educationDocument });
    }).catch((error) => {
      this.eventService.next(EventConstants.EDUCATION_DELETE_ERROR, { educationDocument, error });
    });
  }
  initData() {
    this.educationDocuments = [];
    if (this.profileEmployee?.getEmployeeId()) {
      this.educationDocumentRepository.getAllNestedWithDocumentsForEmployee(this.profileEmployee?.getEmployeeId()).then((result) => {
        if (result) {
          this.educationDocuments = result;
        }
        this.spinner.hide();
        this.loaderService.hide();
      }).catch((error) => {
        this.spinner.hide();
        this.loaderService.hide();
        this.eventService.next(EventConstants.EDUCATION_LOAD_ERROR, { employeeId: this.profileEmployee?.getEmployeeId(), error });
      });
      this.initChangeRequestsData();
    }
  }
  initChangeRequestsData() {
    if (this.profileEmployee?.getEmployeeId()) {
      this.requests = [];
      this.changeRequests = [];
      this.changeRequestsRepository.getForDocumentCheck("employee_education", this.profileEmployee?.getEmployeeId()).then((result) => {
        if (result) {
          this.changeRequests = result;
          result.forEach((changeRequest) => {
            if (changeRequest.new_value && changeRequest.field_name) {
              this.documentRepository.getById(Number(changeRequest.new_value)).then((document2) => {
                if (document2 && changeRequest.requester_info) {
                  this.requests?.push({
                    id: changeRequest.id,
                    document: document2,
                    education_date: changeRequest.requester_info["education_date"],
                    title: changeRequest.requester_info["new_value_display"],
                    document_id: document2.id,
                    employee_id: changeRequest.target_id,
                    description: changeRequest.requester_info["description"]
                  });
                }
              }).catch((error) => {
                this.eventService.next(EventConstants.EDUCATION_CHANGE_REQUESTS_LOAD_ERROR, { changeRequest, error });
              });
            }
          });
        }
      }).catch((error) => {
        this.eventService.next(EventConstants.EDUCATION_CHANGE_REQUESTS_LOAD_ERROR, { error });
      });
    }
  }
  openDocumentModal() {
    this.dialogRef = this.modalService.show(AppModalComponent, {
      data: {
        title: this.translate.instant("Document"),
        template: this.documentModal
      }
    });
  }
  closeDocumentModal() {
    this.dialogRef?.close();
  }
  static \u0275fac = function EducationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EducationComponent)(\u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(DocumentRepository), \u0275\u0275directiveInject(EmployeeEducationRepository), \u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ChangeRequestsRepository), \u0275\u0275directiveInject(TranslateService), \u0275\u0275directiveInject(ModalService), \u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(LoaderService), \u0275\u0275directiveInject(EventService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _EducationComponent, selectors: [["app-education"]], viewQuery: function EducationComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c02, 5);
      \u0275\u0275viewQuery(_c12, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.documentModal = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.docComponent = _t.first);
    }
  }, decls: 6, vars: 3, consts: [["documentModal", ""], ["docComponent", ""], ["panel", ""], [4, "ngFor", "ngForOf"], [3, "document", "hidden"], [1, "d-flex", "mt-4"], [1, "align-content-center", 3, "settings"], ["class", "add-btn d-flex align-items-center gap-2", 3, "click", 4, "ngIf"], [1, "list-group"], [1, "d-flex", "mat-expansion-panel-header"], [1, "col-5"], [1, "col-1"], [1, "add-btn", "d-flex", "align-items-center", "gap-2", 3, "click"], [1, "fa-solid", "fa-circle-plus"], ["dir", "rtl", "hideToggle", ""], ["class", "col-1 material-icons", 3, "click", 4, "ngIf"], [1, "col-lg-5", "d-flex", "align-items-center"], ["class", "col-1 material-icons", 4, "ngIf"], [1, "pre-wrap", 3, "innerHTML"], [4, "ngIf"], [1, "col-1", "material-icons", 3, "click"], [1, "col-1", "material-icons"], [1, "list-group-item", 3, "decline", "approve", "isApprove", "isUnderReview", "isDeleteVisible", "document"], [1, "col-5", "d-flex", "align-items-center"], ["class", "btn btn-icon btn-sm btn-light", 3, "click", 4, "ngIf"], [1, "btn", "btn-icon", "btn-sm", "btn-light", 3, "click"], [1, "feather", "icon-trash", 3, "title"], [1, "feather", "icon-eye", 3, "title"], [1, "list-group-item", 3, "isDeleteVisible", "document"], [1, "row", 3, "ngSubmit", "formGroup"], ["class", "mt-2 col-12", 4, "ngFor", "ngForOf"], [1, "mt-2", "col-12"], [3, "formControlName", "settings"]], template: function EducationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ul");
      \u0275\u0275template(1, EducationComponent_ng_container_1_Template, 17, 13, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, EducationComponent_ng_template_2_Template, 2, 2, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275element(4, "app-document", 4, 1);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.sections);
      \u0275\u0275advance(3);
      \u0275\u0275property("document", ctx.viewedDocument)("hidden", true);
    }
  }, dependencies: [
    CommonModule,
    NgForOf,
    NgIf,
    DatePipe,
    LabelComponent,
    DocumentComponent,
    TranslatePipe,
    ReactiveFormsModule,
    \u0275NgNoValidate,
    NgControlStatus,
    NgControlStatusGroup,
    FormGroupDirective,
    FormControlName,
    FormsModule,
    FormInputComponent,
    MatExpansionModule,
    MatExpansionPanel,
    MatExpansionPanelHeader,
    MatButtonModule,
    Dir
  ], styles: ["\n\n  .mat-expansion-panel {\n  background-color: rgb(253, 253, 252) !important;\n  color: black !important;\n  border-radius: 0px !important;\n}\n  .mat-expansion-panel .mat-expansion-panel-header {\n  color: #6b7280;\n  font-size: 12px;\n}\n  .mat-expansion-panel .mat-expansion-panel-body {\n  font-size: 12px;\n}\n.pre-wrap[_ngcontent-%COMP%] {\n  white-space: pre-wrap !important;\n}\n/*# sourceMappingURL=education.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(EducationComponent, { className: "EducationComponent", filePath: "src/app/main/employee/profile/components/education/education.component.ts", lineNumber: 46 });
})();

// src/app/main/employee/profile/components/feedback/feedback.component.ts
function FeedbackTabComponent_ng_template_7_app_table_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-table", 8);
    \u0275\u0275listener("action", function FeedbackTabComponent_ng_template_7_app_table_0_Template_app_table_action_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onActionClick($event, "active"));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r2.expandedData)("columns", ctx_r2.feedbacksColumns);
  }
}
function FeedbackTabComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FeedbackTabComponent_ng_template_7_app_table_0_Template, 1, 2, "app-table", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.expandedData);
  }
}
function FeedbackTabComponent_ng_template_15_app_table_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-table", 8);
    \u0275\u0275listener("action", function FeedbackTabComponent_ng_template_15_app_table_0_Template_app_table_action_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onActionClick($event, "history"));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r2.expandedData)("columns", ctx_r2.feedbacksColumns);
  }
}
function FeedbackTabComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FeedbackTabComponent_ng_template_15_app_table_0_Template, 1, 2, "app-table", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.expandedData);
  }
}
var FeedbackTabComponent = class _FeedbackTabComponent {
  supabaseAuthService;
  feedbackFormsRepository;
  idService;
  router;
  translate;
  eventService;
  employeeService;
  columnsActive = [
    { field: "title", title: "Title", width: "25%" },
    { field: "created_at", title: "Create date", type: "date", width: "15%" },
    { field: "due_date", title: "Due date", type: "date", width: "15%" },
    { field: "status", title: "Status", type: "feedback-form-status", width: "15%" },
    { field: "final_weighted_grade", title: "Final Weighted Grade", type: "percentage", width: "15%" },
    {
      title: "Actions",
      field: "actions",
      type: "buttons",
      visible: () => true,
      columnClass: "app-table-sticky-right",
      columnHeaderClass: "app-table-sticky-right",
      width: "10%",
      buttons: [
        {
          name: "Go to form",
          class: "icon-eye"
        }
      ]
    }
  ];
  columnsHistory = [
    { field: "title", title: "Title", width: "25%" },
    { field: "created_at", title: "Create date", type: "date", width: "15%" },
    { field: "due_date", title: "Due date", type: "date", width: "15%" },
    { field: "status", title: "Status", type: "feedback-form-status", width: "15%" },
    { field: "final_weighted_grade", title: "Final Weighted Grade", type: "percentage", width: "15%" },
    {
      title: "Actions",
      field: "actions",
      type: "buttons",
      visible: () => true,
      columnClass: "app-table-sticky-right",
      columnHeaderClass: "app-table-sticky-right",
      width: "10%",
      buttons: [
        {
          name: "Go to form",
          class: "icon-eye"
        }
      ]
    }
  ];
  data = new MatTableDataSource();
  historyData = new MatTableDataSource();
  appConstants = AppConstants;
  currentEmployee;
  profileEmployee;
  feedbacksColumns = [
    { field: "template_id", title: "ID", width: "5%" },
    { field: "criteria", title: "Criteria", width: "15%" },
    { field: "trend", title: "Trend", type: "trend", width: "10%" },
    { field: "weight", title: "Weight", type: "percentage", width: "10%" },
    { field: "periodic_score", title: "Periodic Score", type: "percentage", width: "7%" },
    { field: "weighted_score", title: "Weighted Score", type: "percentage", width: "7%" },
    { field: "improvement_employee", title: "Improvement (Employee)", type: "percentage", width: "12%" },
    { field: "improvement_manager", title: "Improvement (Manager)", width: "12%" },
    { field: "preservation_employee", title: "Preservation (Employee)", width: "12%" },
    { field: "preservation_manager", title: "Preservation (Manager)", width: "12%" }
  ];
  expandedData = new MatTableDataSource();
  constructor(supabaseAuthService, feedbackFormsRepository, idService, router, translate, eventService, employeeService) {
    this.supabaseAuthService = supabaseAuthService;
    this.feedbackFormsRepository = feedbackFormsRepository;
    this.idService = idService;
    this.router = router;
    this.translate = translate;
    this.eventService = eventService;
    this.employeeService = employeeService;
  }
  ngOnInit() {
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      if (!employee) {
        return;
      }
      this.currentEmployee = employee;
    });
    this.employeeService.profileEmployeeSubject.subscribe((employee) => {
      if (employee) {
        this.profileEmployee = {};
        this.profileEmployee = employee;
        this.initFeedbackForms();
      }
    });
  }
  initFeedbackForms() {
    this.feedbackFormsRepository.getActiveFeedbackFormsForEmployee(this.profileEmployee.getEmployeeId()).then((data) => {
      this.data.data = data;
      this.eventService.next(EventConstants.FEEDBACK_TAB_LOADED, { employeeId: this.profileEmployee.getEmployeeId(), count: this.data.data.length });
    }).catch((error) => {
      this.eventService.next(EventConstants.FEEDBACK_TAB_LOAD_ERROR, { employeeId: this.profileEmployee.getEmployeeId(), error });
    });
    this.feedbackFormsRepository.getHistoryFeedbackFormsForEmployee(this.profileEmployee.getEmployeeId()).then((data) => {
      this.historyData.data = data;
    });
  }
  onActionClick(event, table) {
    switch (event.action) {
      case "Go to form": {
        this.idService.setId("feedback-form", event.data.id);
        this.router.navigate(["/feedback-form"]);
        break;
      }
      case "sort": {
        if (table === "history") {
          this.historyData.data = AppConstants.sortData(event.data, this.historyData.data);
        } else {
          this.data.data = AppConstants.sortData(event.data, this.data.data);
        }
        break;
      }
      case "expand": {
        this.expandedData.data = event.data.feedbacks || [];
        break;
      }
    }
  }
  static \u0275fac = function FeedbackTabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FeedbackTabComponent)(\u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(FeedbackFormsRepository), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(TranslateService), \u0275\u0275directiveInject(EventService), \u0275\u0275directiveInject(EmployeeService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _FeedbackTabComponent, selectors: [["app-feedback"]], decls: 17, vars: 14, consts: [["expandedRowContentTemplateActive", ""], ["expandedRowContentTemplateHistory", ""], [1, "m-3", "feedback-section"], [1, "tab-section-title", "d-flex", "align-items-center", "gap-2", "mb-3"], ["alt", "", 3, "src"], ["tableLayout", "fixed", "tableClasses", "feedback-table app-table no-wrap", 3, "action", "dataSource", "columns", "expandableContentTemplate"], [1, "tab-section-title", "d-flex", "align-items-center", "gap-2", "mt-3", "mb-3"], ["tableLayout", "fixed", "tableClasses", "app-table no-wrap", 3, "dataSource", "columns", "action", 4, "ngIf"], ["tableLayout", "fixed", "tableClasses", "app-table no-wrap", 3, "action", "dataSource", "columns"]], template: function FeedbackTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "h6");
      \u0275\u0275text(3);
      \u0275\u0275pipe(4, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "img", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "app-table", 5);
      \u0275\u0275listener("action", function FeedbackTabComponent_Template_app_table_action_6_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onActionClick($event, "active"));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(7, FeedbackTabComponent_ng_template_7_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(9, "div", 6)(10, "h6");
      \u0275\u0275text(11);
      \u0275\u0275pipe(12, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275element(13, "img", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(14, "app-table", 5);
      \u0275\u0275listener("action", function FeedbackTabComponent_Template_app_table_action_14_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onActionClick($event, "history"));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(15, FeedbackTabComponent_ng_template_15_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const expandedRowContentTemplateActive_r5 = \u0275\u0275reference(8);
      const expandedRowContentTemplateHistory_r6 = \u0275\u0275reference(16);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 10, "Active Feedbacks"));
      \u0275\u0275advance(2);
      \u0275\u0275property("src", ctx.appConstants.getAsset("assets/images/raking-icon.svg"), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance();
      \u0275\u0275property("dataSource", ctx.data)("columns", ctx.columnsActive)("expandableContentTemplate", expandedRowContentTemplateActive_r5);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(12, 12, "History Feedbacks"));
      \u0275\u0275advance(2);
      \u0275\u0275property("src", ctx.appConstants.getAsset("assets/images/raking-icon.svg"), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance();
      \u0275\u0275property("dataSource", ctx.historyData)("columns", ctx.columnsHistory)("expandableContentTemplate", expandedRowContentTemplateHistory_r6);
    }
  }, dependencies: [
    TableComponent,
    CommonModule,
    NgIf,
    TranslatePipe
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(FeedbackTabComponent, { className: "FeedbackTabComponent", filePath: "src/app/main/employee/profile/components/feedback/feedback.component.ts", lineNumber: 28 });
})();

// node_modules/d3-brush/node_modules/d3-drag/src/noevent.js
var nonpassivecapture = {
  capture: true,
  passive: false
};
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-brush/node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection = select_default(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection = select_default(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-brush/src/constant.js
var constant_default = (x2) => () => x2;

// node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection,
  mode,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {
      value: type2,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    selection: {
      value: selection,
      enumerable: true,
      configurable: true
    },
    mode: {
      value: mode,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}

// node_modules/d3-brush/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-brush/src/brush.js
var MODE_DRAG = {
  name: "drag"
};
var MODE_SPACE = {
  name: "space"
};
var MODE_HANDLE = {
  name: "handle"
};
var MODE_CENTER = {
  name: "center"
};
var {
  abs,
  max: max2,
  min: min2
} = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x2, e) {
    return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y2, e) {
    return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t) {
  return {
    type: t
  };
}
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}
function empty(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}
function brushX() {
  return brush(X);
}
function brush(dim) {
  var extent = defaultExtent, filter = defaultFilter, touchable = defaultTouchable, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent2 = local(this).extent;
      select_default(this).attr("x", extent2[0][0]).attr("y", extent2[0][1]).attr("width", extent2[1][0] - extent2[0][0]).attr("height", extent2[1][1] - extent2[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection, event) {
    if (group.tween) {
      group.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent), i = value_default(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group, event) {
    brush2.move(group, null, event);
  };
  function redraw() {
    var group = select_default(this), selection = local(this).selection;
    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode) {
      if (this.starting) this.starting = false, this.emit("start", event, mode);
      else this.emit("brush", event);
      return this;
    },
    brush: function(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function(event, mode) {
      if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function(type2, event, mode) {
      var d = select_default(this.that).datum();
      listeners.call(type2, this.that, new BrushEvent(type2, {
        sourceEvent: event,
        target: brush2,
        selection: dim.output(this.state.selection),
        mode,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches) return;
    if (!filter.apply(this, arguments)) return;
    var that = this, type2 = event.target.__data__.type, mode = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent2 = state.extent, selection = state.selection, W = extent2[0][0], w0, w1, N = extent2[0][1], n0, n1, E = extent2[1][0], e0, e1, S = extent2[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {
      const i = t.identifier;
      t = pointer_default(t, that);
      t.point0 = t.slice();
      t.identifier = i;
      return t;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection) moving = true;
      const pts = [points[0], points[1] || points[0]];
      state.selection = selection = [[w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]), n0 = dim === X ? N : min2(pts[0][1], pts[1][1])], [e0 = dim === Y ? E : max2(pts[0][0], pts[1][0]), s0 = dim === X ? S : max2(pts[0][1], pts[1][1])]];
      if (points.length > 1) move(event);
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select_default(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event2) {
      for (const p of event2.changedTouches || [event2]) {
        for (const d of points) if (d.identifier === p.identifier) d.cur = pointer_default(p, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point2 = points[0];
        if (abs(point2.cur[0] - point2[0]) > abs(point2.cur[1] - point2[1])) lockY = true;
        else lockX = true;
      }
      for (const point2 of points) if (point2.cur) point2[0] = point2.cur[0], point2[1] = point2.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point2 = points[0], point0 = point2.point0;
      var t;
      dx = point2[0] - point0[0];
      dy = point2[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = max2(W - w0, min2(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX) w1 = max2(W, min2(E, points[0][0])), e1 = max2(W, min2(E, points[1][0])), signX = 1;
            if (signY) n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;
          } else {
            if (signX < 0) dx = max2(W - w0, min2(E - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0) dx = max2(W - e0, min2(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0) dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = max2(W, min2(E, w0 - dx * signX)), e1 = max2(W, min2(E, e0 + dx * signX));
          if (signY) n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type2 in flipX) overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type2 in flipY) overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection) selection = state.selection;
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];
      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode.name);
      }
    }
    function ended(event2) {
      nopropagation(event2);
      if (event2.touches) {
        if (event2.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection;
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end(event2, mode.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx;
            else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy;
            else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1;
            else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1;
            else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event2.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1;
              else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;
              else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || {
      selection: null
    };
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default(number2(_)), brush2) : extent;
  };
  brush2.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant_default(!!_), brush2) : filter;
  };
  brush2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default(!!_), brush2) : touchable;
  };
  brush2.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush2) : keys;
  };
  brush2.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? brush2 : value2;
  };
  return brush2;
}

// node_modules/@swimlane/ngx-charts/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/@swimlane/ngx-charts/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4) h = (g - b) / s + (g < b) * 6;
    else if (g === max4) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children = node.children, i = children && children.length;
  if (!i) sum2 = 1;
  else while (--i >= 0) sum2 += children[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum2 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0) sum2 += children[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root2 = new Node(data), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = {
  depth: -1
};
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId, path2;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root2) throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2) throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0) throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify) : id2;
  };
  stratify.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify) : parentId;
  };
  stratify.path = function(x2) {
    return arguments.length ? (path2 = optional(x2), stratify) : path2;
  };
  return stratify;
}
function normalize(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path2, i)) break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k = 0;
    while (i > 0 && path2[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) dice_default(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else slice_default(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function(x2) {
    return custom((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root2.eachBefore(round_default);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap) : round;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-sankey/node_modules/d3-array/src/max.js
function max3(values, valueof) {
  let max4;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max4 < value2 || max4 === void 0 && value2 >= value2)) {
        max4 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (max4 < value2 || max4 === void 0 && value2 >= value2)) {
        max4 = value2;
      }
    }
  }
  return max4;
}

// node_modules/d3-sankey/node_modules/d3-array/src/min.js
function min3(values, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min4 > value2 || min4 === void 0 && value2 >= value2)) {
        min4 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (min4 > value2 || min4 === void 0 && value2 >= value2)) {
        min4 = value2;
      }
    }
  }
  return min4;
}

// node_modules/d3-sankey/node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 = +value2) {
        sum2 += value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if (value2 = +valueof(value2, ++index, values)) {
        sum2 += value2;
      }
    }
  }
  return sum2;
}

// node_modules/d3-sankey/src/align.js
function left(node) {
  return node.depth;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}

// node_modules/d3-sankey/src/constant.js
function constant(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId2(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  const node = nodeById.get(id2);
  if (!node) throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths({
  nodes
}) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link2 of node.sourceLinks) {
      link2.y0 = y0 + link2.width / 2;
      y0 += link2.width;
    }
    for (const link2 of node.targetLinks) {
      link2.y1 = y1 + link2.width / 2;
      y1 += link2.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId2;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = {
      nodes: nodes.apply(null, arguments),
      links: links.apply(null, arguments)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks({
    nodes: nodes2,
    links: links2
  }) {
    for (const [i, node] of nodes2.entries()) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i) => [id2(d, i, nodes2), d]));
    for (const [i, link2] of links2.entries()) {
      link2.index = i;
      let {
        source,
        target
      } = link2;
      if (typeof source !== "object") source = link2.source = find(nodeById, source);
      if (typeof target !== "object") target = link2.target = find(nodeById, target);
      source.sourceLinks.push(link2);
      target.targetLinks.push(link2);
    }
    if (linkSort != null) {
      for (const {
        sourceLinks,
        targetLinks
      } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({
    nodes: nodes2
  }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({
    nodes: nodes2
  }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x2;
        for (const {
          target
        } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x2 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({
    nodes: nodes2
  }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x2;
        for (const {
          source
        } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x2 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({
    nodes: nodes2
  }) {
    const x2 = max3(nodes2, (d) => d.depth) + 1;
    const kx = (x1 - x0 - dx) / (x2 - 1);
    const columns = new Array(x2);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i]) columns[i].push(node);
      else columns[i] = [node];
    }
    if (sort) for (const column of columns) {
      column.sort(sort);
    }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky = min3(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
    for (const nodes2 of columns) {
      let y2 = y0;
      for (const node of nodes2) {
        node.y0 = y2;
        node.y1 = y2 + node.value * ky;
        y2 = node.y1 + py;
        for (const link2 of node.sourceLinks) {
          link2.width = link2.value * ky;
        }
      }
      y2 = (y1 - y2 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y2 * (i + 1);
        node.y1 += y2 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max3(columns, (c) => c.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (const target of column) {
        let y2 = 0;
        let w = 0;
        for (const {
          source,
          value: value2
        } of target.targetLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0)) continue;
        let dy2 = (y2 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column = columns[i];
      for (const source of column) {
        let y2 = 0;
        let w = 0;
        for (const {
          target,
          value: value2
        } of source.sourceLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0)) continue;
        let dy2 = (y2 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y2 - node.y0) * alpha;
      if (dy2 > 1e-6) node.y0 += dy2, node.y1 += dy2;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y2) * alpha;
      if (dy2 > 1e-6) node.y0 -= dy2, node.y1 -= dy2;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks({
    sourceLinks,
    targetLinks
  }) {
    if (linkSort === void 0) {
      for (const {
        source: {
          sourceLinks: sourceLinks2
        }
      } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const {
        target: {
          targetLinks: targetLinks2
        }
      } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const {
        sourceLinks,
        targetLinks
      } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const {
      target: node,
      width
    } of source.sourceLinks) {
      if (node === target) break;
      y2 += width + py;
    }
    for (const {
      source: node,
      width
    } of target.targetLinks) {
      if (node === source) break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const {
      source: node,
      width
    } of target.targetLinks) {
      if (node === source) break;
      y2 += width + py;
    }
    for (const {
      target: node,
      width
    } of source.sourceLinks) {
      if (node === target) break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}

// node_modules/d3-sankey/node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default2 = path;

// node_modules/d3-sankey/node_modules/d3-shape/src/constant.js
function constant_default3(x2) {
  return function constant2() {
    return x2;
  };
}

// node_modules/d3-sankey/node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-sankey/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-sankey/node_modules/d3-shape/src/link/index.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x2 = x, y2 = y, context = null;
  function link2() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = path_default2();
    curve(context, +x2.apply(this, (argv[0] = s, argv)), +y2.apply(this, argv), +x2.apply(this, (argv[0] = t, argv)), +y2.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default3(+_), link2) : x2;
  };
  link2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default3(+_), link2) : y2;
  };
  link2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function linkHorizontal2() {
  return link(curveHorizontal);
}

// node_modules/d3-sankey/src/sankeyLinkHorizontal.js
function horizontalSource(d) {
  return [d.source.x1, d.y0];
}
function horizontalTarget(d) {
  return [d.target.x0, d.y1];
}
function sankeyLinkHorizontal_default() {
  return linkHorizontal2().source(horizontalSource).target(horizontalTarget);
}

// node_modules/@swimlane/ngx-charts/fesm2022/swimlane-ngx-charts.mjs
var _c03 = ["caretElm"];
var _c13 = (a0) => ({
  model: a0
});
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) {
}
function TooltipContentComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c13, ctx_r0.context));
  }
}
function TooltipContentComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.title, \u0275\u0275sanitizeHtml);
  }
}
function LegendComponent_header_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "header", 4)(1, "span", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function LegendComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 6)(1, "ngx-charts-legend-entry", 7);
    \u0275\u0275listener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.labelClick.emit($event));
    })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate($event));
    })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const entry_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("label", entry_r3.label)("formattedLabel", entry_r3.formattedLabel)("color", entry_r3.color)("isActive", ctx_r0.isActive(entry_r3));
  }
}
var _c2 = ["*"];
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "ngx-charts-scale-legend", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === ctx_r0.LegendPosition.Below)("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
  }
}
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ngx-charts-legend", 5);
    \u0275\u0275listener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelClick.emit($event));
    })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelActivate.emit($event));
    })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelDeactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === ctx_r0.LegendPosition.Below)("data", ctx_r0.legendOptions.domain)("title", ctx_r0.legendOptions.title)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth)("activeEntries", ctx_r0.activeEntries);
  }
}
var _c3 = ["ngx-charts-axis-label", ""];
var _c4 = ["ticksel"];
var _c5 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainer(0);
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_tspan_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "tspan", 10);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tickLine_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    \u0275\u0275attribute("y", i_r2 * 12);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tickLine_r1, " ");
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_tspan_1_Template, 2, 2, "tspan", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r3 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", tickLines_r3);
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template, 2, 1, "ng-container", 6);
  }
  if (rf & 2) {
    const tick_r4 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r4.tickChunks(tick_r4));
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const tickFormatted_r6 = \u0275\u0275nextContext().ngIf;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r4.tickTrim(tickFormatted_r6), " ");
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 7);
    \u0275\u0275template(4, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template, 1, 0, "ng-container", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(7, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickFormatted_r6 = ctx.ngIf;
    const tmplMultilineTick_r7 = \u0275\u0275reference(6);
    const tmplSinglelineTick_r8 = \u0275\u0275reference(8);
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(tickFormatted_r6);
    \u0275\u0275advance();
    \u0275\u0275attribute("text-anchor", ctx_r4.textAnchor)("transform", ctx_r4.textTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.isWrapTicksSupported)("ngIfThen", tmplMultilineTick_r7)("ngIfElse", tmplSinglelineTick_r8);
  }
}
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_2__svg_ng_container_1_Template, 9, 6, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r4.tickTransform(tick_r4));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.tickFormat(tick_r4));
  }
}
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "line", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r4.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275attribute("y1", -ctx_r4.gridLineHeight);
  }
}
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r9 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r4.tickTransform(tick_r9));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.showGridLines);
  }
}
var _c6 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("dimensionsChanged", function XAxisComponent__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.emitTicksHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("trimTicks", ctx_r1.trimTicks)("rotateTicks", ctx_r1.rotateTicks)("maxTickLength", ctx_r1.maxTickLength)("tickFormatting", ctx_r1.tickFormatting)("tickArguments", ctx_r1.tickArguments)("tickStroke", ctx_r1.tickStroke)("scale", ctx_r1.xScale)("orient", ctx_r1.xOrient)("showGridLines", ctx_r1.showGridLines)("gridLineHeight", ctx_r1.dims.height)("width", ctx_r1.dims.width)("tickValues", ctx_r1.ticks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function XAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.orientation.Bottom)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
var _c7 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainer(0);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1__svg_tspan_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "tspan", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tickLine_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext(6);
    \u0275\u0275attribute("y", i_r2 * (8 + ctx_r2.tickSpacing));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tickLine_r1, " ");
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1__svg_tspan_1_Template, 2, 2, "tspan", 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r4 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", tickLines_r4);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1_Template, 2, 1, "ng-container", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r4 = ctx.ngIf;
    \u0275\u0275nextContext(2);
    const tmplSinglelineTick_r5 = \u0275\u0275reference(8);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tickLines_r4.length > 1)("ngIfElse", tmplSinglelineTick_r5);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template, 2, 2, "ng-container", 7);
  }
  if (rf & 2) {
    const tick_r6 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.tickChunks(tick_r6));
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const tickFormatted_r7 = \u0275\u0275nextContext().ngIf;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r2.tickTrim(tickFormatted_r7), " ");
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 8);
    \u0275\u0275template(4, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(7, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickFormatted_r7 = ctx.ngIf;
    const tmplMultilineTick_r8 = \u0275\u0275reference(6);
    const tmplSinglelineTick_r5 = \u0275\u0275reference(8);
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(tickFormatted_r7);
    \u0275\u0275advance();
    \u0275\u0275styleProp("font-size", "12px");
    \u0275\u0275attribute("dy", ctx_r2.dy)("x", ctx_r2.x1)("y", ctx_r2.y1)("text-anchor", ctx_r2.textAnchor);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.wrapTicks)("ngIfThen", tmplMultilineTick_r8)("ngIfElse", tmplSinglelineTick_r5);
  }
}
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1_Template, 9, 10, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(tick_r6));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.tickFormat(tick_r6));
  }
}
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 13);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 15);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("x2", ctx_r2.gridLineWidth);
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 15);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("x2", -ctx_r2.gridLineWidth);
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 14)(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r2.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.orient === ctx_r2.Orientation.Left);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.orient === ctx_r2.Orientation.Right);
  }
}
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r9 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(tick_r9));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showGridLines);
  }
}
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 17);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const refLine_r10 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.tickTrim(ctx_r2.tickFormat(refLine_r10.value)));
    \u0275\u0275advance();
    \u0275\u0275attribute("dy", ctx_r2.dy)("y", -6)("x", ctx_r2.gridLineWidth)("text-anchor", ctx_r2.textAnchor);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", refLine_r10.name, " ");
  }
}
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "line", 16);
    \u0275\u0275template(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const refLine_r10 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(refLine_r10.value));
    \u0275\u0275advance();
    \u0275\u0275attribute("x2", ctx_r2.gridLineWidth)("transform", ctx_r2.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showRefLabels);
  }
}
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showRefLines);
  }
}
var _c8 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("dimensionsChanged", function YAxisComponent__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.emitTicksWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("trimTicks", ctx_r1.trimTicks)("maxTickLength", ctx_r1.maxTickLength)("tickFormatting", ctx_r1.tickFormatting)("tickArguments", ctx_r1.tickArguments)("tickValues", ctx_r1.ticks)("tickStroke", ctx_r1.tickStroke)("scale", ctx_r1.yScale)("orient", ctx_r1.yOrient)("showGridLines", ctx_r1.showGridLines)("gridLineWidth", ctx_r1.dims.width)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels)("height", ctx_r1.dims.height)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function YAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
var _c9 = ["ngx-charts-circle", ""];
var _c10 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "stop");
  }
  if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    \u0275\u0275styleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    \u0275\u0275attribute("offset", stop_r1.offset + "%");
  }
}
var _c11 = ["ngx-charts-circle-series", ""];
var _c122 = (a0) => ({
  name: a0
});
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
  }
}
function CircleSeriesComponent__svg_g_0__svg_rect_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
  }
}
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "defs");
    \u0275\u0275element(2, "g", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2)(4, CircleSeriesComponent__svg_g_0__svg_rect_4_Template, 1, 5, "rect", 2);
    \u0275\u0275elementStart(5, "g", 3);
    \u0275\u0275listener("select", function CircleSeriesComponent__svg_g_0_Template_g_select_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick(ctx_r1.circle.data));
    })("activate", function CircleSeriesComponent__svg_g_0_Template_g_activate_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activateCircle());
    })("deactivate", function CircleSeriesComponent__svg_g_0_Template_g_deactivate_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivateCircle());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("orientation", ctx_r1.barOrientation.Vertical)("name", ctx_r1.gradientId)("stops", ctx_r1.circle.gradientStops);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isSSR && ctx_r1.barVisible && ctx_r1.type === "standard");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isSSR && ctx_r1.barVisible && ctx_r1.type === "standard");
    \u0275\u0275advance();
    \u0275\u0275classProp("active", ctx_r1.isActive(\u0275\u0275pureFunction1(20, _c122, ctx_r1.circle.seriesName)));
    \u0275\u0275property("cx", ctx_r1.circle.cx)("cy", ctx_r1.circle.cy)("r", ctx_r1.circle.radius)("fill", ctx_r1.circle.color)("pointerEvents", ctx_r1.circle.value === 0 ? "none" : "all")("data", ctx_r1.circle.value)("classNames", ctx_r1.circle.classNames)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.getTooltipText(ctx_r1.circle))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", ctx_r1.circle.data);
  }
}
var _c132 = ["ngx-charts-grid-panel", ""];
var _c14 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 1);
  }
  if (rf & 2) {
    const gridPanel_r1 = ctx.$implicit;
    \u0275\u0275classProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    \u0275\u0275property("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
  }
}
var _c15 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "stop");
  }
  if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    \u0275\u0275styleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    \u0275\u0275attribute("offset", stop_r1.offset + "%");
  }
}
var _c16 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c17 = ["ngx-charts-count-up", ""];
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__svg_ng_template_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275element(1, "span", 7);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tooltipItem_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275styleProp("background-color", tooltipItem_r2.color);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r2.getToolTipText(tooltipItem_r2), " ");
  }
}
function TooltipArea__svg_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275template(1, TooltipArea__svg_ng_template_2_div_1_Template, 3, 3, "div", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const model_r4 = ctx.model;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", model_r4);
  }
}
var _c20 = ["ngx-charts-timeline", ""];
function AdvancedLegendComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function AdvancedLegendComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.valueFormatting ? ctx_r0.valueFormatting(ctx_r0.roundedTotal) : ctx_r0.defaultValueFormatting(ctx_r0.roundedTotal), " ");
  }
}
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 16);
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", legendItem_r3._value)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.valueFormatting ? ctx_r0.valueFormatting(legendItem_r3.value) : ctx_r0.defaultValueFormatting(legendItem_r3.value), " ");
  }
}
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 18);
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("countTo", legendItem_r3.percentage)("countSuffix", "%");
  }
}
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
  }
}
function AdvancedLegendComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate.emit(legendItem_r3.data));
    })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate.emit(legendItem_r3.data));
    })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.select.emit(legendItem_r3.data));
    });
    \u0275\u0275element(1, "div", 10);
    \u0275\u0275template(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11)(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    \u0275\u0275elementStart(4, "div", 13);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14)(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275styleProp("border-left-color", legendItem_r3.color);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(legendItem_r3.displayLabel);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
  }
}
var _c21 = ["ngx-charts-area-series", ""];
var _c22 = ["tooltipTemplate"];
var _c23 = ["seriesTooltipTemplate"];
var _c24 = (a0, a1) => [a0, a1];
function AreaChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("baseValue", ctx_r1.baseValue)("colors", ctx_r1.colors)("data", series_r4)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("baseValue", ctx_r1.baseValue)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 14);
    \u0275\u0275listener("onDomainChange", function AreaChartComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("scaleType", ctx_r1.scaleType)("activeEntries", ctx_r1.activeEntries)("gradient", ctx_r1.gradient)("normalized", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.seriesType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartNormalizedComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 10, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("showPercentage", true)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("normalized", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 14);
    \u0275\u0275listener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c25 = ".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n";
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("activeEntries", ctx_r1.activeEntries)("stacked", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 12);
    \u0275\u0275listener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.seriesType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartStackedComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 10, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("stacked", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 13);
    \u0275\u0275listener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c26 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c27 = ["ngx-charts-bar-label", ""];
var _c28 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesHorizontal__svg_g_0_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.click($event));
    })("activate", function SeriesHorizontal__svg_g_0_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesHorizontal__svg_g_0_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("@animationState", "active")("width", bar_r3.width)("height", bar_r3.height)("x", bar_r3.x)("y", bar_r3.y)("fill", bar_r3.color)("stops", bar_r3.gradientStops)("data", bar_r3.data)("orientation", ctx_r1.barOrientation.Horizontal)("roundEdges", bar_r3.roundEdges)("gradient", ctx_r1.gradient)("isActive", ctx_r1.isActive(bar_r3.data))("ariaLabel", bar_r3.ariaLabel)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r3.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r3.data)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275listener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      const i_r5 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.dataLabelWidthChanged.emit({
        size: $event,
        index: i_r5
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const b_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("barX", b_r6.x)("barY", b_r6.y)("barWidth", b_r6.width)("barHeight", b_r6.height)("value", b_r6.total)("valueFormatting", ctx_r1.dataLabelFormatting)("orientation", ctx_r1.barOrientation.Horizontal);
  }
}
function SeriesHorizontal__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
  }
}
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("activeEntries", ctx_r1.activeEntries)("yScale", ctx_r1.innerScale)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontal2DComponent__svg_g_5__svg_g_1_Template, 2, 17, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("activeEntries", ctx_r1.activeEntries)("yScale", ctx_r1.innerScale)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r8.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontal2DComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontal2DComponent__svg_g_6__svg_g_1_Template, 2, 16, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template, 2, 15, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r7));
    })("activate", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r7));
    })("deactivate", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r7));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r7));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r7.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template, 2, 14, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("series", group_r5.series)("activeEntries", ctx_r1.activeEntries)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template, 2, 17, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("series", group_r8.series)("activeEntries", ctx_r1.activeEntries)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r8.name)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template, 2, 16, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c29 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active")("@.disabled", !ctx_r1.animations)("width", bar_r3.width)("height", bar_r3.height)("x", bar_r3.x)("y", bar_r3.y)("fill", bar_r3.color)("stops", bar_r3.gradientStops)("data", bar_r3.data)("orientation", ctx_r1.barOrientation.Vertical)("roundEdges", bar_r3.roundEdges)("gradient", ctx_r1.gradient)("ariaLabel", bar_r3.ariaLabel)("isActive", ctx_r1.isActive(bar_r3.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r3.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r3.data)("noBarWhenZero", ctx_r1.noBarWhenZero)("animations", ctx_r1.animations);
  }
}
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_0__svg_g_1_Template, 1, 22, "g", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.bars)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("width", bar_r5.width)("height", bar_r5.height)("x", bar_r5.x)("y", bar_r5.y)("fill", bar_r5.color)("stops", bar_r5.gradientStops)("data", bar_r5.data)("orientation", ctx_r1.barOrientation.Vertical)("roundEdges", bar_r5.roundEdges)("gradient", ctx_r1.gradient)("ariaLabel", bar_r5.ariaLabel)("isActive", ctx_r1.isActive(bar_r5.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r5.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r5.data)("noBarWhenZero", ctx_r1.noBarWhenZero)("animations", ctx_r1.animations);
  }
}
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 20, "g", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.bars)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function SeriesVerticalComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275listener("dimensionsChanged", function SeriesVerticalComponent__svg_g_2__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      const i_r7 = \u0275\u0275restoreView(_r6).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.dataLabelHeightChanged.emit({
        size: $event,
        index: i_r7
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const b_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r1.dataLabelFormatting)("orientation", ctx_r1.barOrientation.Vertical);
  }
}
function SeriesVerticalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_2__svg_g_1_Template, 1, 7, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
  }
}
function BarVerticalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 9);
    \u0275\u0275listener("select", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_select_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_activate_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_deactivate_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_dataLabelHeightChanged_0_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r6));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active")("activeEntries", ctx_r1.activeEntries)("xScale", ctx_r1.innerScale)("yScale", ctx_r1.valueScale)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r5.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
  }
}
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVertical2DComponent__svg_g_5__svg_g_1_Template, 1, 17, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVertical2DComponent__svg_g_6__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 9);
    \u0275\u0275listener("select", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_select_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_activate_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_deactivate_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_dataLabelHeightChanged_0_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r9));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("activeEntries", ctx_r1.activeEntries)("xScale", ctx_r1.innerScale)("yScale", ctx_r1.valueScale)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r8.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
  }
}
function BarVertical2DComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVertical2DComponent__svg_g_6__svg_g_1_Template, 1, 16, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template, 2, 15, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r7));
    })("activate", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r7));
    })("deactivate", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r7));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r7));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r7.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template, 2, 14, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_dataLabelHeightChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalStackedComponent__svg_g_4__svg_g_1_Template, 2, 17, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_dataLabelHeightChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r8.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalStackedComponent__svg_g_5__svg_g_1_Template, 2, 16, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c30 = ["ngx-charts-box", ""];
function BoxComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("orientation", ctx_r0.BarOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function BoxComponent__svg_line_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 6);
  }
  if (rf & 2) {
    const line_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("hidden", ctx_r0.hideBar);
    \u0275\u0275attribute("x1", line_r2.v1.x)("y1", line_r2.v1.y)("x2", line_r2.v2.x)("y2", line_r2.v2.y)("stroke", ctx_r0.strokeColor)("stroke-width", i_r3 === 2 ? ctx_r0.medianLineWidth : ctx_r0.whiskerStrokeWidth)("mask", i_r3 ? void 0 : ctx_r0.maskLine);
  }
}
var _c31 = ["ngx-charts-box-series", ""];
function BoxChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 5);
    \u0275\u0275listener("activate", function BoxChartComponent__svg_g_5_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BoxChartComponent__svg_g_5_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    })("select", function BoxChartComponent__svg_g_5_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const result_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("roundEdges", ctx_r1.roundEdges)("strokeColor", ctx_r1.strokeColor)("strokeWidth", ctx_r1.strokeWidth)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("series", result_r3)("dims", ctx_r1.dims)("animations", ctx_r1.animations)("gradient", ctx_r1.gradient);
  }
}
var _c32 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_select_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(circle_r2.data));
    })("activate", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_activate_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activateCircle(circle_r2));
    })("deactivate", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_deactivate_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivateCircle(circle_r2));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", circle_r2.opacity);
    \u0275\u0275classProp("active", circle_r2.isActive);
    \u0275\u0275property("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r2.radius)("fill", circle_r2.color)("pointerEvents", "all")("data", circle_r2.value)("classNames", circle_r2.classNames)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.getTooltipText(circle_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", circle_r2.data);
  }
}
function BubbleSeriesComponent__svg_g_0__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_select_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(circle_r2.data));
    })("activate", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_activate_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activateCircle(circle_r2));
    })("deactivate", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_deactivate_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivateCircle(circle_r2));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", circle_r2.opacity);
    \u0275\u0275classProp("active", circle_r2.isActive);
    \u0275\u0275property("cx", 0)("cy", 0)("r", circle_r2.radius)("fill", circle_r2.color)("pointerEvents", "all")("data", circle_r2.value)("classNames", circle_r2.classNames)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.getTooltipText(circle_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", circle_r2.data);
  }
}
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g");
    \u0275\u0275template(2, BubbleSeriesComponent__svg_g_0__svg_g_2_Template, 1, 18, "g", 1)(3, BubbleSeriesComponent__svg_g_0__svg_g_3_Template, 1, 17, "g", 1);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const circle_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("transform", circle_r2.transform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.isSSR);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.isSSR);
  }
}
function BubbleChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("showGridLines", ctx_r1.showGridLines)("dims", ctx_r1.dims)("xScale", ctx_r1.xScale)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BubbleChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BubbleChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_select_1_listener($event) {
      const series_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r5));
    })("activate", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("rScale", ctx_r1.rScale)("xScaleType", ctx_r1.xScaleType)("yScaleType", ctx_r1.yScaleType)("xAxisLabel", ctx_r1.xAxisLabel)("yAxisLabel", ctx_r1.yAxisLabel)("colors", ctx_r1.colors)("data", series_r5)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function BubbleChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BubbleChartComponent__svg_g_8__svg_g_1_Template, 2, 13, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("clip-path", ctx_r1.clipPath);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.data)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BubbleChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("rScale", ctx_r1.rScale)("xScaleType", ctx_r1.xScaleType)("yScaleType", ctx_r1.yScaleType)("xAxisLabel", ctx_r1.xAxisLabel)("yAxisLabel", ctx_r1.yAxisLabel)("colors", ctx_r1.colors)("data", series_r7)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function BubbleChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BubbleChartComponent__svg_g_9__svg_g_1_Template, 2, 12, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("clip-path", ctx_r1.clipPath);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.data)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c33 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c34 = ["ngx-charts-heat-map-cell-series", ""];
var _c35 = (a0, a1, a2) => ({
  series: a0,
  name: a1,
  value: a2
});
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 1);
    \u0275\u0275listener("select", function HeatCellSeriesComponent__svg_g_0_Template_g_select_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(c_r2.cell));
    })("activate", function HeatCellSeriesComponent__svg_g_0_Template_g_activate_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(c_r2.cell));
    })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template_g_deactivate_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivate.emit(c_r2.cell));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height)("fill", c_r2.fill)("data", c_r2.data)("gradient", ctx_r2.gradient)("animations", ctx_r2.animations)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.tooltipText(c_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", \u0275\u0275pureFunction3(14, _c35, c_r2.series, c_r2.label, c_r2.data));
  }
}
function HeatMapComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function HeatMapComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function HeatMapComponent__svg_rect_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect");
  }
  if (rf & 2) {
    const rect_r4 = ctx.$implicit;
    \u0275\u0275attribute("x", rect_r4.x)("y", rect_r4.y)("rx", rect_r4.rx)("width", rect_r4.width)("height", rect_r4.height)("fill", rect_r4.fill);
  }
}
var _c36 = ["ngx-charts-line", ""];
function LineComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "path", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("d", ctx_r0.initialPath)("fill", ctx_r0.fill)("stroke", ctx_r0.stroke);
  }
}
function LineComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "path", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("d", ctx_r0.initialPath)("fill", ctx_r0.fill)("stroke", ctx_r0.stroke);
  }
}
var _c37 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function LineSeriesComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.isActive(ctx_r0.data))("inactive", ctx_r0.isInactive(ctx_r0.data));
    \u0275\u0275property("data", ctx_r0.data)("path", ctx_r0.outerPath)("fill", ctx_r0.hasGradient ? ctx_r0.gradientUrl : ctx_r0.colors.getColor(ctx_r0.data.name))("opacity", ctx_r0.rangeFillOpacity)("animations", ctx_r0.animations);
  }
}
function LineChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function LineChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function LineChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function LineChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function LineChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, LineChartComponent__svg_g_8__svg_g_1_Template, 2, 11, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function LineChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r5)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, LineChartComponent__svg_g_9__svg_g_1_Template, 2, 10, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function LineChartComponent__svg_g_10__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 14);
    \u0275\u0275listener("select", function LineChartComponent__svg_g_10__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function LineChartComponent__svg_g_10__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function LineChartComponent__svg_g_10__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r8)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function LineChartComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 11);
    \u0275\u0275listener("mouseleave", function LineChartComponent__svg_g_10_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 12);
    \u0275\u0275listener("hover", function LineChartComponent__svg_g_10_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, LineChartComponent__svg_g_10__svg_g_2_Template, 2, 9, "g", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function LineChartComponent__svg_g_11__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r10)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 15);
    \u0275\u0275listener("onDomainChange", function LineChartComponent__svg_g_11_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, LineChartComponent__svg_g_11__svg_g_1_Template, 2, 8, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("scaleType", ctx_r1.scaleType)("legend", ctx_r1.legend);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c38 = ["ngx-charts-pie-label", ""];
var _c39 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
  }
}
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("select", function PolarSeriesComponent__svg_g_4_Template_g_select_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.select.emit(circle_r3.data));
    })("activate", function PolarSeriesComponent__svg_g_4_Template_g_activate_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate.emit({
        name: circle_r3.data.series
      }));
    })("deactivate", function PolarSeriesComponent__svg_g_4_Template_g_deactivate_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate.emit({
        name: circle_r3.data.series
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", ctx_r0.inactive ? 0.2 : 1);
    \u0275\u0275property("cx", circle_r3.cx)("cy", circle_r3.cy)("r", ctx_r0.circleRadius)("fill", circle_r3.color)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.placementTypes.Top)("tooltipType", ctx_r0.styleTypes.tooltip)("tooltipTitle", ctx_r0.tooltipTemplate ? void 0 : ctx_r0.tooltipText(circle_r3))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r3.data);
  }
}
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "circle", 7);
  }
  if (rf & 2) {
    const r_r1 = ctx.$implicit;
    \u0275\u0275attribute("r", r_r1);
  }
}
function PolarChartComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.radiusTicks);
  }
}
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 9);
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("data", tick_r3)("radius", ctx_r1.outerRadius)("label", tick_r3.label)("max", ctx_r1.outerRadius)("value", ctx_r1.showGridLines ? 1 : ctx_r1.outerRadius)("explodeSlices", true)("animations", ctx_r1.animations)("labelTrim", ctx_r1.labelTrim)("labelTrimSize", ctx_r1.labelTrimSize);
  }
}
function PolarChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.thetaTicks);
  }
}
function PolarChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yAxisScale)("dims", ctx_r1.yAxisDims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("wrapTicks", ctx_r1.wrapTicks);
    \u0275\u0275attribute("transform", ctx_r1.transformYAxis);
  }
}
function PolarChartComponent__svg_g_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.xAxisLabel)("offset", ctx_r1.labelOffset)("orient", ctx_r1.orientation.Bottom)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
function PolarChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("gradient", ctx_r1.gradient)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r6)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function PolarChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_8__svg_g_1_Template, 2, 13, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformPlot);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PolarChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("gradient", ctx_r1.gradient)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r8)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function PolarChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_9__svg_g_1_Template, 2, 12, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformPlot);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c40 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
  }
}
var _c41 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const arc_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("data", arc_r2)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r2))("label", ctx_r2.labelText(arc_r2))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r2.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
  }
}
function PieSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    \u0275\u0275elementStart(2, "g", 2);
    \u0275\u0275listener("select", function PieSeriesComponent__svg_g_0_Template_g_select_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick($event));
    })("activate", function PieSeriesComponent__svg_g_0_Template_g_activate_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit($event));
    })("deactivate", function PieSeriesComponent__svg_g_0_Template_g_deactivate_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivate.emit($event));
    })("dblclick", function PieSeriesComponent__svg_g_0_Template_g_dblclick_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.dblclick.emit($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const arc_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.labelVisible(arc_r2));
    \u0275\u0275advance();
    \u0275\u0275property("startAngle", arc_r2.startAngle)("endAngle", arc_r2.endAngle)("innerRadius", ctx_r2.innerRadius)("outerRadius", ctx_r2.outerRadius)("fill", ctx_r2.color(arc_r2))("value", arc_r2.data.value)("gradient", ctx_r2.gradient)("data", arc_r2.data)("max", ctx_r2.max)("explodeSlices", ctx_r2.explodeSlices)("isActive", ctx_r2.isActive(arc_r2.data))("animate", ctx_r2.animations)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.getTooltipTitle(arc_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", arc_r2.data);
  }
}
var _c42 = ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n";
var _c43 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function PieGridSeriesComponent__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PieGridSeriesComponent__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function PieGridSeriesComponent__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const arc_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("startAngle", arc_r3.startAngle)("endAngle", arc_r3.endAngle)("innerRadius", ctx_r1.innerRadius)("outerRadius", ctx_r1.outerRadius)("fill", ctx_r1.color(arc_r3))("value", arc_r3.data.value)("data", arc_r3.data)("gradient", false)("pointerEvents", arc_r3.pointerEvents)("animate", arc_r3.animate);
    \u0275\u0275attribute("class", arc_r3.class);
  }
}
var _c44 = (a0) => ({
  data: a0
});
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "text", 10);
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("countTo", series_r3.percent)("countSuffix", "%");
  }
}
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", series_r3.percent.toLocaleString(), " ");
  }
}
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "text", 12);
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", series_r3.total)("countPrefix", ctx_r1.label + ": ");
    \u0275\u0275attribute("y", series_r3.outerRadius);
  }
}
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 13);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("y", series_r3.outerRadius);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" ", ctx_r1.label, ": ", series_r3.total.toLocaleString(), " ");
  }
}
function PieGridComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 3)(1, "g", 4);
    \u0275\u0275listener("select", function PieGridComponent__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PieGridComponent__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PieGridComponent__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5)(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    \u0275\u0275elementStart(4, "text", 7);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8)(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", series_r3.transform);
    \u0275\u0275advance();
    \u0275\u0275property("colors", series_r3.colors)("data", series_r3.data)("innerRadius", series_r3.innerRadius)("outerRadius", series_r3.outerRadius)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.tooltipText(\u0275\u0275pureFunction1(17, _c44, series_r3)))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", series_r3.data[0].data);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.animations);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", series_r3.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.animations);
  }
}
var _c45 = ["textEl"];
var _c46 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("fill", ctx_r1.bandColor)("transform", ctx_r1.transformBand)("d", ctx_r1.bandPath);
  }
}
var _c47 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 2);
  }
  if (rf & 2) {
    const c_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("fill", ctx_r1.emptyColor);
    \u0275\u0275attribute("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height);
  }
}
function CardSeriesComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 3);
    \u0275\u0275listener("select", function CardSeriesComponent__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("x", c_r4.x)("y", c_r4.y)("width", c_r4.width)("height", c_r4.height)("color", c_r4.color)("bandColor", c_r4.bandColor)("textColor", c_r4.textColor)("data", c_r4.data)("label", c_r4.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
  }
}
var _c48 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.orientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function TreeMapCellComponent__svg_foreignObject_3_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("countTo", ctx_r0.value)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function TreeMapCellComponent__svg_foreignObject_3_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.formattedValue, " ");
  }
}
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "foreignObject", 4);
    \u0275\u0275namespaceHTML();
    \u0275\u0275elementStart(1, "p");
    \u0275\u0275element(2, "span", 5)(3, "br");
    \u0275\u0275template(4, TreeMapCellComponent__svg_foreignObject_3_span_4_Template, 1, 2, "span", 6)(5, TreeMapCellComponent__svg_foreignObject_3_span_5_Template, 2, 1, "span", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("pointer-events", "none");
    \u0275\u0275attribute("x", ctx_r0.x)("y", ctx_r0.y)("width", ctx_r0.width)("height", ctx_r0.height);
    \u0275\u0275advance();
    \u0275\u0275styleProp("color", ctx_r0.getTextColor())("height", ctx_r0.height + "px")("width", ctx_r0.width + "px");
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", ctx_r0.formattedLabel, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
  }
}
var _c49 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 1);
    \u0275\u0275listener("select", function TreeMapCellSeriesComponent__svg_g_0_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("data", c_r3.data)("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("fill", c_r3.fill)("label", c_r3.label)("value", c_r3.value)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("gradient", ctx_r1.gradient)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.getTooltipText(c_r3))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", c_r3.data);
  }
}
var _c50 = ["valueTextEl"];
var _c51 = ["unitsTextEl"];
var _c52 = () => ({});
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
  }
}
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
  }
}
var _c53 = ["ngx-charts-gauge-arc", ""];
var _c54 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275element(1, "path");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275attribute("d", tick_r1.line);
  }
}
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2)(1, "text", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tick_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275styleProp("text-anchor", tick_r2.textAnchor);
    \u0275\u0275attribute("transform", tick_r2.textTransform);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tick_r2.text, " ");
  }
}
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275element(1, "path");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275attribute("d", tick_r3.line);
  }
}
function GaugeComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 6);
    \u0275\u0275listener("select", function GaugeComponent__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function GaugeComponent__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function GaugeComponent__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const arc_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.rotation);
    \u0275\u0275advance();
    \u0275\u0275property("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r1.cornerRadius)("colors", ctx_r1.colors)("isActive", ctx_r1.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("valueFormatting", ctx_r1.valueFormatting)("animations", ctx_r1.animations);
  }
}
function GaugeComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
  }
}
function GaugeComponent__svg_text_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 8, 0)(2, "tspan", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "tspan", 10);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("text-anchor", "middle");
    \u0275\u0275attribute("transform", ctx_r1.textTransform);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.displayValue);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.units);
  }
}
function PercentGaugeComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "rect");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tic_r1 = ctx.$implicit;
    \u0275\u0275attribute("transform", tic_r1.transform);
    \u0275\u0275advance();
    \u0275\u0275attribute("y", -tic_r1.height / 2)("x", -tic_r1.width)("width", tic_r1.width)("height", tic_r1.height)("fill", tic_r1.fill);
  }
}
function PercentGaugeComponent__svg_circle_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "circle", 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("stroke-width", ctx_r1.targetRadius / 10);
    \u0275\u0275attribute("r", ctx_r1.targetRadius)("stroke", ctx_r1.targetColor)("cx", -ctx_r1.targetRadius / 2)("cy", -ctx_r1.targetRadius / 2);
  }
}
function PercentGaugeComponent__svg_g_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "text", 12);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.labelTransform);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.label, " ");
  }
}
function SankeyComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5)(1, "defs")(2, "linearGradient", 6);
    \u0275\u0275element(3, "stop", 7)(4, "stop", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "path", 9);
    \u0275\u0275listener("click", function SankeyComponent__svg_g_2_Template_path_click_5_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.select.emit(link_r2.data));
    })("mouseenter", function SankeyComponent__svg_g_2_Template_path_mouseenter_5_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(link_r2.data));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipPlacement", "top")("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : link_r2.tooltip)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", link_r2.data);
    \u0275\u0275advance(2);
    \u0275\u0275attribute("id", link_r2.id)("x1", link_r2.source.x1)("x2", link_r2.target.x0);
    \u0275\u0275advance();
    \u0275\u0275attribute("stop-color", link_r2.startColor);
    \u0275\u0275advance();
    \u0275\u0275attribute("stop-color", link_r2.endColor);
    \u0275\u0275advance();
    \u0275\u0275attribute("d", link_r2.path)("stroke", link_r2.gradientFill)("stroke-width", link_r2.strokeWidth);
  }
}
function SankeyComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10)(1, "rect", 11);
    \u0275\u0275listener("click", function SankeyComponent__svg_g_3_Template_rect_click_1_listener() {
      const rect_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.select.emit(rect_r5.data));
    })("mouseenter", function SankeyComponent__svg_g_3_Template_rect_mouseenter_1_listener() {
      const rect_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(rect_r5.data));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const rect_r5 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", rect_r5.transform);
    \u0275\u0275advance();
    \u0275\u0275property("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipPlacement", "top")("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : rect_r5.tooltip)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", rect_r5.data);
    \u0275\u0275attribute("x", 0)("y", 0)("width", rect_r5.width)("height", rect_r5.height)("fill", rect_r5.fill);
  }
}
function SankeyComponent__svg_g_4__svg_text_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 13);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const rect_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275attribute("x", rect_r6.width + 5)("y", rect_r6.height / 2)("text-anchor", rect_r6.labelAnchor)("dx", rect_r6.labelAnchor === "end" ? -25 : 0);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", rect_r6.label, " ");
  }
}
function SankeyComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SankeyComponent__svg_g_4__svg_text_1_Template, 2, 5, "text", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const rect_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", rect_r6.transform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showLabels && rect_r6.height > 15);
  }
}
function throttle(func, wait, options) {
  options = options || {};
  let context;
  let args;
  let result;
  let timeout = null;
  let previous = 0;
  function later() {
    previous = options.leading === false ? 0 : +/* @__PURE__ */ new Date();
    timeout = null;
    result = func.apply(context, args);
  }
  return function() {
    const now = +/* @__PURE__ */ new Date();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}
function throttleable(duration, options) {
  return function innerDecorator(target, key, descriptor) {
    return {
      configurable: true,
      enumerable: descriptor.enumerable,
      get: function getter() {
        Object.defineProperty(this, key, {
          configurable: true,
          enumerable: descriptor.enumerable,
          value: throttle(descriptor.value, duration, options)
        });
        return this[key];
      }
    };
  };
}
var PlacementTypes;
(function(PlacementTypes2) {
  PlacementTypes2["Top"] = "top";
  PlacementTypes2["Bottom"] = "bottom";
  PlacementTypes2["Left"] = "left";
  PlacementTypes2["Right"] = "right";
  PlacementTypes2["Center"] = "center";
})(PlacementTypes || (PlacementTypes = {}));
var caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
  if (alignment === PlacementTypes.Top) {
    return elDimensions.top - caretOffset;
  }
  if (alignment === PlacementTypes.Bottom) {
    return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
  }
  if (alignment === PlacementTypes.Center) {
    return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
  }
  return void 0;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
  if (alignment === PlacementTypes.Left) {
    return elDimensions.left - caretOffset;
  }
  if (alignment === PlacementTypes.Right) {
    return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
  }
  if (alignment === PlacementTypes.Center) {
    return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
  }
  return void 0;
}
var PositionHelper = class _PositionHelper {
  /**
   * Calculate vertical alignment position
   *
   * @memberOf PositionHelper
   */
  static calculateVerticalAlignment(elDimensions, popoverDimensions, alignment) {
    let result = verticalPosition(elDimensions, popoverDimensions, alignment);
    if (result + popoverDimensions.height > window.innerHeight) {
      result = window.innerHeight - popoverDimensions.height;
    }
    return result;
  }
  /**
   * Calculate vertical caret position
   *
   * @memberOf PositionHelper
   */
  static calculateVerticalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
    let result;
    if (alignment === PlacementTypes.Top) {
      result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
    }
    if (alignment === PlacementTypes.Bottom) {
      result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
    }
    if (alignment === PlacementTypes.Center) {
      result = popoverDimensions.height / 2 - caretDimensions.height / 2;
    }
    const popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
    if (popoverPosition + popoverDimensions.height > window.innerHeight) {
      result += popoverPosition + popoverDimensions.height - window.innerHeight;
    }
    return result;
  }
  /**
   * Calculate horz alignment position
   *
   * @memberOf PositionHelper
   */
  static calculateHorizontalAlignment(elDimensions, popoverDimensions, alignment) {
    let result = horizontalPosition(elDimensions, popoverDimensions, alignment);
    if (result + popoverDimensions.width > window.innerWidth) {
      result = window.innerWidth - popoverDimensions.width;
    }
    return result;
  }
  /**
   * Calculate horz caret position
   *
   * @memberOf PositionHelper
   */
  static calculateHorizontalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
    let result;
    if (alignment === PlacementTypes.Left) {
      result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
    }
    if (alignment === PlacementTypes.Right) {
      result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
    }
    if (alignment === PlacementTypes.Center) {
      result = popoverDimensions.width / 2 - caretDimensions.width / 2;
    }
    const popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
    if (popoverPosition + popoverDimensions.width > window.innerWidth) {
      result += popoverPosition + popoverDimensions.width - window.innerWidth;
    }
    return result;
  }
  /**
   * Checks if the element's position should be flipped
   *
   * @memberOf PositionHelper
   */
  static shouldFlip(elDimensions, popoverDimensions, placement, spacing) {
    let flip = false;
    if (placement === PlacementTypes.Right) {
      if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
        flip = true;
      }
    }
    if (placement === PlacementTypes.Left) {
      if (elDimensions.left - popoverDimensions.width - spacing < 0) {
        flip = true;
      }
    }
    if (placement === PlacementTypes.Top) {
      if (elDimensions.top - popoverDimensions.height - spacing < 0) {
        flip = true;
      }
    }
    if (placement === PlacementTypes.Bottom) {
      if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
        flip = true;
      }
    }
    return flip;
  }
  /**
   * Position caret
   *
   * @memberOf PositionHelper
   */
  static positionCaret(placement, elmDim, hostDim, caretDimensions, alignment) {
    let top = 0;
    let left2 = 0;
    if (placement === PlacementTypes.Right) {
      left2 = -7;
      top = _PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Left) {
      left2 = elmDim.width;
      top = _PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Top) {
      top = elmDim.height;
      left2 = _PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Bottom) {
      top = -7;
      left2 = _PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
    }
    return {
      top,
      left: left2
    };
  }
  /**
   * Position content
   *
   * @memberOf PositionHelper
   */
  static positionContent(placement, elmDim, hostDim, spacing, alignment) {
    let top = 0;
    let left2 = 0;
    if (placement === PlacementTypes.Right) {
      left2 = hostDim.left + hostDim.width + spacing;
      top = _PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Left) {
      left2 = hostDim.left - elmDim.width - spacing;
      top = _PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Top) {
      top = hostDim.top - elmDim.height - spacing;
      left2 = _PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Bottom) {
      top = hostDim.top + hostDim.height + spacing;
      left2 = _PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
    }
    return {
      top,
      left: left2
    };
  }
  /**
   * Determine placement based on flip
   *
   * @memberOf PositionHelper
   */
  static determinePlacement(placement, elmDim, hostDim, spacing) {
    const shouldFlip = _PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
    if (shouldFlip) {
      if (placement === PlacementTypes.Right) {
        return PlacementTypes.Left;
      } else if (placement === PlacementTypes.Left) {
        return PlacementTypes.Right;
      } else if (placement === PlacementTypes.Top) {
        return PlacementTypes.Bottom;
      } else if (placement === PlacementTypes.Bottom) {
        return PlacementTypes.Top;
      }
    }
    return placement;
  }
};
var TooltipContentComponent = class _TooltipContentComponent {
  get cssClasses() {
    let clz = "ngx-charts-tooltip-content";
    clz += ` position-${this.placement}`;
    clz += ` type-${this.type}`;
    clz += ` ${this.cssClass}`;
    return clz;
  }
  constructor(element, renderer, platformId) {
    this.element = element;
    this.renderer = renderer;
    this.platformId = platformId;
  }
  ngAfterViewInit() {
    setTimeout(this.position.bind(this));
  }
  position() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const nativeElm = this.element.nativeElement;
    const hostDim = this.host.nativeElement.getBoundingClientRect();
    if (!hostDim.height && !hostDim.width) return;
    const elmDim = nativeElm.getBoundingClientRect();
    this.checkFlip(hostDim, elmDim);
    this.positionContent(nativeElm, hostDim, elmDim);
    if (this.showCaret) {
      this.positionCaret(hostDim, elmDim);
    }
    setTimeout(() => this.renderer.addClass(nativeElm, "animate"), 1);
  }
  positionContent(nativeElm, hostDim, elmDim) {
    const {
      top,
      left: left2
    } = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment);
    this.renderer.setStyle(nativeElm, "top", `${top}px`);
    this.renderer.setStyle(nativeElm, "left", `${left2}px`);
  }
  positionCaret(hostDim, elmDim) {
    const caretElm = this.caretElm.nativeElement;
    const caretDimensions = caretElm.getBoundingClientRect();
    const {
      top,
      left: left2
    } = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment);
    this.renderer.setStyle(caretElm, "top", `${top}px`);
    this.renderer.setStyle(caretElm, "left", `${left2}px`);
  }
  checkFlip(hostDim, elmDim) {
    this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
  }
  onWindowResize() {
    this.position();
  }
  static {
    this.\u0275fac = function TooltipContentComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TooltipContentComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TooltipContentComponent,
      selectors: [["ngx-tooltip-content"]],
      viewQuery: function TooltipContentComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c03, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.caretElm = _t.first);
        }
      },
      hostVars: 2,
      hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("resize", function TooltipContentComponent_resize_HostBindingHandler() {
            return ctx.onWindowResize();
          }, false, \u0275\u0275resolveWindow);
        }
        if (rf & 2) {
          \u0275\u0275classMap(ctx.cssClasses);
        }
      },
      inputs: {
        host: "host",
        showCaret: "showCaret",
        type: "type",
        placement: "placement",
        alignment: "alignment",
        spacing: "spacing",
        cssClass: "cssClass",
        title: "title",
        template: "template",
        context: "context"
      },
      standalone: false,
      decls: 6,
      vars: 6,
      consts: [["caretElm", ""], [3, "hidden"], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]],
      template: function TooltipContentComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div");
          \u0275\u0275element(1, "span", 1, 0);
          \u0275\u0275elementStart(3, "div", 2);
          \u0275\u0275template(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3)(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275classMapInterpolate1("tooltip-caret position-", ctx.placement, "");
          \u0275\u0275property("hidden", !ctx.showCaret);
          \u0275\u0275advance(3);
          \u0275\u0275property("ngIf", !ctx.title);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.title);
        }
      },
      dependencies: [NgIf, NgTemplateOutlet],
      styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:#000000bf;font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translateZ(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"],
      encapsulation: 2
    });
  }
};
__decorate([throttleable(100)], TooltipContentComponent.prototype, "onWindowResize", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipContentComponent, [{
    type: Component,
    args: [{
      selector: "ngx-tooltip-content",
      template: `
    <div>
      <span #caretElm [hidden]="!showCaret" class="tooltip-caret position-{{ this.placement }}"> </span>
      <div class="tooltip-content">
        <span *ngIf="!title">
          <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ model: context }"> </ng-template>
        </span>
        <span *ngIf="title" [innerHTML]="title"> </span>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:#000000bf;font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translateZ(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    host: [{
      type: Input
    }],
    showCaret: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    alignment: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    caretElm: [{
      type: ViewChild,
      args: ["caretElm"]
    }],
    cssClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onWindowResize: [{
      type: HostListener,
      args: ["window:resize"]
    }]
  });
})();
var InjectionRegisteryService = class {
  constructor(injectionService) {
    this.injectionService = injectionService;
    this.defaults = {};
    this.components = /* @__PURE__ */ new Map();
  }
  getByType(type2 = this.type) {
    return this.components.get(type2);
  }
  create(bindings) {
    return this.createByType(this.type, bindings);
  }
  createByType(type2, bindings) {
    bindings = this.assignDefaults(bindings);
    const component = this.injectComponent(type2, bindings);
    this.register(type2, component);
    return component;
  }
  destroy(instance) {
    const compsByType = this.components.get(instance.componentType);
    if (compsByType && compsByType.length) {
      const idx = compsByType.indexOf(instance);
      if (idx > -1) {
        const component = compsByType[idx];
        component.destroy();
        compsByType.splice(idx, 1);
      }
    }
  }
  destroyAll() {
    this.destroyByType(this.type);
  }
  destroyByType(type2) {
    const comps = this.components.get(type2);
    if (comps && comps.length) {
      let i = comps.length - 1;
      while (i >= 0) {
        this.destroy(comps[i--]);
      }
    }
  }
  injectComponent(type2, bindings) {
    return this.injectionService.appendComponent(type2, bindings);
  }
  assignDefaults(bindings) {
    const inputs = __spreadValues({}, this.defaults.inputs);
    const outputs = __spreadValues({}, this.defaults.outputs);
    if (!bindings.inputs && !bindings.outputs) {
      bindings = {
        inputs: bindings
      };
    }
    if (inputs) {
      bindings.inputs = __spreadValues(__spreadValues({}, inputs), bindings.inputs);
    }
    if (outputs) {
      bindings.outputs = __spreadValues(__spreadValues({}, outputs), bindings.outputs);
    }
    return bindings;
  }
  register(type2, component) {
    if (!this.components.has(type2)) {
      this.components.set(type2, []);
    }
    const types = this.components.get(type2);
    types.push(component);
  }
};
function isViewContainerRef(x2) {
  return x2.element;
}
var InjectionService = class _InjectionService {
  static {
    this.globalRootViewContainer = null;
  }
  /**
   * Sets a default global root view container. This is useful for
   * things like ngUpgrade that doesn't have a ApplicationRef root.
   *
   * @param container
   */
  static setGlobalRootViewContainer(container) {
    _InjectionService.globalRootViewContainer = container;
  }
  constructor(applicationRef, componentFactoryResolver, injector) {
    this.applicationRef = applicationRef;
    this.componentFactoryResolver = componentFactoryResolver;
    this.injector = injector;
  }
  /**
   * Gets the root view container to inject the component to.
   *
   * @memberOf InjectionService
   */
  getRootViewContainer() {
    if (this._container) return this._container;
    if (_InjectionService.globalRootViewContainer) return _InjectionService.globalRootViewContainer;
    if (this.applicationRef.components.length) return this.applicationRef.components[0];
    throw new Error("View Container not found! ngUpgrade needs to manually set this via setRootViewContainer or setGlobalRootViewContainer.");
  }
  /**
   * Overrides the default root view container. This is useful for
   * things like ngUpgrade that doesn't have a ApplicationRef root.
   *
   * @param container
   *
   * @memberOf InjectionService
   */
  setRootViewContainer(container) {
    this._container = container;
  }
  /**
   * Gets the html element for a component ref.
   *
   * @param componentRef
   *
   * @memberOf InjectionService
   */
  getComponentRootNode(component) {
    if (isViewContainerRef(component)) {
      return component.element.nativeElement;
    }
    if (component.hostView && component.hostView.rootNodes.length > 0) {
      return component.hostView.rootNodes[0];
    }
    return component.location.nativeElement;
  }
  /**
   * Gets the root component container html element.
   *
   * @memberOf InjectionService
   */
  getRootViewContainerNode(component) {
    return this.getComponentRootNode(component);
  }
  /**
   * Projects the bindings onto the component
   *
   * @param component
   * @param options
   *
   * @memberOf InjectionService
   */
  projectComponentBindings(component, bindings) {
    if (bindings) {
      if (bindings.inputs !== void 0) {
        const bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
        for (const bindingName of bindingKeys) {
          component.instance[bindingName] = bindings.inputs[bindingName];
        }
      }
      if (bindings.outputs !== void 0) {
        const eventKeys = Object.getOwnPropertyNames(bindings.outputs);
        for (const eventName of eventKeys) {
          component.instance[eventName] = bindings.outputs[eventName];
        }
      }
    }
    return component;
  }
  /**
   * Appends a component to a adjacent location
   *
   * @param componentClass
   * @param [options={}]
   * @param [location]
   *
   * @memberOf InjectionService
   */
  appendComponent(componentClass, bindings = {}, location) {
    if (!location) location = this.getRootViewContainer();
    const appendLocation = this.getComponentRootNode(location);
    const portalHost = new DomPortalOutlet(appendLocation, this.componentFactoryResolver, this.applicationRef, this.injector);
    const portal = new ComponentPortal(componentClass);
    const componentRef = portalHost.attach(portal);
    this.projectComponentBindings(componentRef, bindings);
    return componentRef;
  }
  static {
    this.\u0275fac = function InjectionService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _InjectionService)(\u0275\u0275inject(ApplicationRef), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(Injector));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _InjectionService,
      factory: _InjectionService.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InjectionService, [{
    type: Injectable
  }], () => [{
    type: ApplicationRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Injector
  }], null);
})();
var TooltipService = class _TooltipService extends InjectionRegisteryService {
  constructor(injectionService) {
    super(injectionService);
    this.type = TooltipContentComponent;
  }
  static {
    this.\u0275fac = function TooltipService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TooltipService)(\u0275\u0275inject(InjectionService));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _TooltipService,
      factory: _TooltipService.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipService, [{
    type: Injectable
  }], () => [{
    type: InjectionService
  }], null);
})();
var LegendPosition;
(function(LegendPosition2) {
  LegendPosition2["Right"] = "right";
  LegendPosition2["Below"] = "below";
})(LegendPosition || (LegendPosition = {}));
var LegendType;
(function(LegendType2) {
  LegendType2["ScaleLegend"] = "scaleLegend";
  LegendType2["Legend"] = "legend";
})(LegendType || (LegendType = {}));
var ScaleType;
(function(ScaleType2) {
  ScaleType2["Time"] = "time";
  ScaleType2["Linear"] = "linear";
  ScaleType2["Ordinal"] = "ordinal";
  ScaleType2["Quantile"] = "quantile";
})(ScaleType || (ScaleType = {}));
function formatLabel(label) {
  if (label instanceof Date) {
    label = label.toLocaleDateString();
  } else {
    label = label.toLocaleString();
  }
  return label;
}
function escapeLabel(label) {
  return label.toLocaleString().replace(/[&'`"<>]/g, (match) => {
    return {
      "&": "&amp;",
      // tslint:disable-next-line: quotemark
      "'": "&#x27;",
      "`": "&#x60;",
      '"': "&quot;",
      "<": "&lt;",
      ">": "&gt;"
    }[match];
  });
}
var LegendEntryComponent = class _LegendEntryComponent {
  constructor() {
    this.isActive = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.toggle = new EventEmitter();
  }
  get trimmedLabel() {
    return this.formattedLabel || "(empty)";
  }
  onMouseEnter() {
    this.activate.emit({
      name: this.label
    });
  }
  onMouseLeave() {
    this.deactivate.emit({
      name: this.label
    });
  }
  static {
    this.\u0275fac = function LegendEntryComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LegendEntryComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LegendEntryComponent,
      selectors: [["ngx-charts-legend-entry"]],
      hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() {
            return ctx.onMouseLeave();
          });
        }
      },
      inputs: {
        color: "color",
        label: "label",
        formattedLabel: "formattedLabel",
        isActive: "isActive"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate",
        toggle: "toggle"
      },
      standalone: false,
      decls: 4,
      vars: 6,
      consts: [["tabindex", "-1", 3, "click", "title"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]],
      template: function LegendEntryComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "span", 0);
          \u0275\u0275listener("click", function LegendEntryComponent_Template_span_click_0_listener() {
            return ctx.select.emit(ctx.formattedLabel);
          });
          \u0275\u0275elementStart(1, "span", 1);
          \u0275\u0275listener("click", function LegendEntryComponent_Template_span_click_1_listener() {
            return ctx.toggle.emit(ctx.formattedLabel);
          });
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(2, "span", 2);
          \u0275\u0275text(3);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275classProp("active", ctx.isActive);
          \u0275\u0275property("title", ctx.formattedLabel);
          \u0275\u0275advance();
          \u0275\u0275styleProp("background-color", ctx.color);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate1(" ", ctx.trimmedLabel, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendEntryComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-legend-entry",
      template: `
    <span [title]="formattedLabel" tabindex="-1" [class.active]="isActive" (click)="select.emit(formattedLabel)">
      <span class="legend-label-color" [style.background-color]="color" (click)="toggle.emit(formattedLabel)"> </span>
      <span class="legend-label-text">
        {{ trimmedLabel }}
      </span>
    </span>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    color: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    formattedLabel: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    toggle: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var LegendComponent = class _LegendComponent {
  constructor(cd) {
    this.cd = cd;
    this.horizontal = false;
    this.labelClick = new EventEmitter();
    this.labelActivate = new EventEmitter();
    this.labelDeactivate = new EventEmitter();
    this.legendEntries = [];
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.cd.markForCheck();
    this.legendEntries = this.getLegendEntries();
  }
  getLegendEntries() {
    const items = [];
    for (const label of this.data) {
      const formattedLabel = formatLabel(label);
      const idx = items.findIndex((i) => {
        return i.label === formattedLabel;
      });
      if (idx === -1) {
        items.push({
          label,
          formattedLabel,
          color: this.colors.getColor(label)
        });
      }
    }
    return items;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.label === d.name;
    });
    return item !== void 0;
  }
  activate(item) {
    this.labelActivate.emit(item);
  }
  deactivate(item) {
    this.labelDeactivate.emit(item);
  }
  trackBy(index, item) {
    return item.label;
  }
  static {
    this.\u0275fac = function LegendComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LegendComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LegendComponent,
      selectors: [["ngx-charts-legend"]],
      inputs: {
        data: "data",
        title: "title",
        colors: "colors",
        height: "height",
        width: "width",
        activeEntries: "activeEntries",
        horizontal: "horizontal"
      },
      outputs: {
        labelClick: "labelClick",
        labelActivate: "labelActivate",
        labelDeactivate: "labelDeactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 5,
      vars: 9,
      consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "select", "activate", "deactivate", "label", "formattedLabel", "color", "isActive"]],
      template: function LegendComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div");
          \u0275\u0275template(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
          \u0275\u0275elementStart(2, "div", 1)(3, "ul", 2);
          \u0275\u0275template(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.width, "px");
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
          \u0275\u0275advance(2);
          \u0275\u0275styleProp("max-height", ctx.height - 45, "px");
          \u0275\u0275classProp("horizontal-legend", ctx.horizontal);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, NgIf, LegendEntryComponent],
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:#0000000d}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-legend",
      template: `
    <div [style.width.px]="width">
      <header class="legend-title" *ngIf="title?.length > 0">
        <span class="legend-title-text">{{ title }}</span>
      </header>
      <div class="legend-wrap">
        <ul class="legend-labels" [class.horizontal-legend]="horizontal" [style.max-height.px]="height - 45">
          <li *ngFor="let entry of legendEntries; trackBy: trackBy" class="legend-label">
            <ngx-charts-legend-entry
              [label]="entry.label"
              [formattedLabel]="entry.formattedLabel"
              [color]="entry.color"
              [isActive]="isActive(entry)"
              (select)="labelClick.emit($event)"
              (activate)="activate($event)"
              (deactivate)="deactivate($event)"
            >
            </ngx-charts-legend-entry>
          </li>
        </ul>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:#0000000d}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    data: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    horizontal: [{
      type: Input
    }],
    labelClick: [{
      type: Output
    }],
    labelActivate: [{
      type: Output
    }],
    labelDeactivate: [{
      type: Output
    }]
  });
})();
var ScaleLegendComponent = class _ScaleLegendComponent {
  constructor() {
    this.horizontal = false;
  }
  ngOnChanges(changes) {
    const gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
    const direction = this.horizontal ? "right" : "bottom";
    this.gradient = `linear-gradient(to ${direction}, ${gradientValues})`;
  }
  /**
   * Generates the string used in the gradient stylesheet properties
   * @param colors array of colors
   * @param splits array of splits on a scale of (0, 1)
   */
  gradientString(colors, splits) {
    splits.push(1);
    const pairs = [];
    colors.reverse().forEach((c, i) => {
      pairs.push(`${c} ${Math.round(splits[i] * 100)}%`);
    });
    return pairs.join(", ");
  }
  static {
    this.\u0275fac = function ScaleLegendComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScaleLegendComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ScaleLegendComponent,
      selectors: [["ngx-charts-scale-legend"]],
      inputs: {
        valueRange: "valueRange",
        colors: "colors",
        height: "height",
        width: "width",
        horizontal: "horizontal"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 8,
      vars: 10,
      consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]],
      template: function ScaleLegendComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "span");
          \u0275\u0275text(3);
          \u0275\u0275elementEnd()();
          \u0275\u0275element(4, "div", 2);
          \u0275\u0275elementStart(5, "div", 1)(6, "span");
          \u0275\u0275text(7);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("height", ctx.horizontal ? void 0 : ctx.height, "px")("width", ctx.width, "px");
          \u0275\u0275classProp("horizontal-legend", ctx.horizontal);
          \u0275\u0275advance(3);
          \u0275\u0275textInterpolate(ctx.valueRange[1].toLocaleString());
          \u0275\u0275advance();
          \u0275\u0275styleProp("background", ctx.gradient);
          \u0275\u0275advance(3);
          \u0275\u0275textInterpolate(ctx.valueRange[0].toLocaleString());
        }
      },
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScaleLegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-scale-legend",
      template: `
    <div
      class="scale-legend"
      [class.horizontal-legend]="horizontal"
      [style.height.px]="horizontal ? undefined : height"
      [style.width.px]="width"
    >
      <div class="scale-legend-label">
        <span>{{ valueRange[1].toLocaleString() }}</span>
      </div>
      <div class="scale-legend-wrap" [style.background]="gradient"></div>
      <div class="scale-legend-label">
        <span>{{ valueRange[0].toLocaleString() }}</span>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}\n"]
    }]
  }], null, {
    valueRange: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    horizontal: [{
      type: Input
    }]
  });
})();
var ChartComponent = class _ChartComponent {
  constructor() {
    this.showLegend = false;
    this.animations = true;
    this.legendLabelClick = new EventEmitter();
    this.legendLabelActivate = new EventEmitter();
    this.legendLabelDeactivate = new EventEmitter();
    this.LegendPosition = LegendPosition;
    this.LegendType = LegendType;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    let legendColumns = 0;
    if (this.showLegend) {
      this.legendType = this.getLegendType();
      if (!this.legendOptions || this.legendOptions.position === LegendPosition.Right) {
        if (this.legendType === LegendType.ScaleLegend) {
          legendColumns = 1;
        } else {
          legendColumns = 2;
        }
      }
    }
    const chartColumns = 12 - legendColumns;
    this.chartWidth = Math.floor(this.view[0] * chartColumns / 12);
    this.legendWidth = !this.legendOptions || this.legendOptions.position === LegendPosition.Right ? Math.floor(this.view[0] * legendColumns / 12) : this.chartWidth;
  }
  getLegendType() {
    return this.legendOptions.scaleType === ScaleType.Linear ? LegendType.ScaleLegend : LegendType.Legend;
  }
  static {
    this.\u0275fac = function ChartComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChartComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ChartComponent,
      selectors: [["ngx-charts-chart"]],
      inputs: {
        view: "view",
        showLegend: "showLegend",
        legendOptions: "legendOptions",
        legendType: "legendType",
        activeEntries: "activeEntries",
        animations: "animations"
      },
      outputs: {
        legendLabelClick: "legendLabelClick",
        legendLabelActivate: "legendLabelActivate",
        legendLabelDeactivate: "legendLabelDeactivate"
      },
      standalone: false,
      features: [\u0275\u0275ProvidersFeature([TooltipService]), \u0275\u0275NgOnChangesFeature],
      ngContentSelectors: _c2,
      decls: 5,
      vars: 8,
      consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "labelClick", "labelActivate", "labelDeactivate", "horizontal", "data", "title", "colors", "height", "width", "activeEntries"]],
      template: function ChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "svg", 1);
          \u0275\u0275projection(2);
          \u0275\u0275elementEnd();
          \u0275\u0275template(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2)(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.view[0], "px")("height", ctx.view[1], "px");
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.chartWidth)("height", ctx.view[1]);
          \u0275\u0275advance(2);
          \u0275\u0275property("ngIf", ctx.showLegend && ctx.legendType === ctx.LegendType.ScaleLegend);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showLegend && ctx.legendType === ctx.LegendType.Legend);
        }
      },
      dependencies: [NgIf, LegendComponent, ScaleLegendComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      providers: [TooltipService],
      selector: "ngx-charts-chart",
      template: `
    <div class="ngx-charts-outer" [style.width.px]="view[0]" [style.height.px]="view[1]">
      <svg class="ngx-charts" [attr.width]="chartWidth" [attr.height]="view[1]">
        <ng-content></ng-content>
      </svg>
      <ngx-charts-scale-legend
        *ngIf="showLegend && legendType === LegendType.ScaleLegend"
        class="chart-legend"
        [horizontal]="legendOptions && legendOptions.position === LegendPosition.Below"
        [valueRange]="legendOptions.domain"
        [colors]="legendOptions.colors"
        [height]="view[1]"
        [width]="legendWidth"
      >
      </ngx-charts-scale-legend>
      <ngx-charts-legend
        *ngIf="showLegend && legendType === LegendType.Legend"
        class="chart-legend"
        [horizontal]="legendOptions && legendOptions.position === LegendPosition.Below"
        [data]="legendOptions.domain"
        [title]="legendOptions.title"
        [colors]="legendOptions.colors"
        [height]="view[1]"
        [width]="legendWidth"
        [activeEntries]="activeEntries"
        (labelClick)="legendLabelClick.emit($event)"
        (labelActivate)="legendLabelActivate.emit($event)"
        (labelDeactivate)="legendLabelDeactivate.emit($event)"
      >
      </ngx-charts-legend>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    view: [{
      type: Input
    }],
    showLegend: [{
      type: Input
    }],
    legendOptions: [{
      type: Input
    }],
    legendType: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    legendLabelClick: [{
      type: Output
    }],
    legendLabelActivate: [{
      type: Output
    }],
    legendLabelDeactivate: [{
      type: Output
    }]
  });
})();
var VisibilityObserver = class _VisibilityObserver {
  constructor(element, zone) {
    this.element = element;
    this.zone = zone;
    this.visible = new EventEmitter();
    this.isVisible = false;
    this.runCheck();
  }
  destroy() {
    clearTimeout(this.timeout);
  }
  onVisibilityChange() {
    this.zone.run(() => {
      this.isVisible = true;
      this.visible.emit(true);
    });
  }
  runCheck() {
    const check = () => {
      if (!this.element) {
        return;
      }
      const {
        offsetHeight,
        offsetWidth
      } = this.element.nativeElement;
      if (offsetHeight && offsetWidth) {
        clearTimeout(this.timeout);
        this.onVisibilityChange();
      } else {
        clearTimeout(this.timeout);
        this.zone.runOutsideAngular(() => {
          this.timeout = setTimeout(() => check(), 100);
        });
      }
    };
    this.zone.runOutsideAngular(() => {
      this.timeout = setTimeout(() => check());
    });
  }
  static {
    this.\u0275fac = function VisibilityObserver_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _VisibilityObserver)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone));
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _VisibilityObserver,
      selectors: [["visibility-observer"]],
      outputs: {
        visible: "visible"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VisibilityObserver, [{
    type: Directive,
    args: [{
      selector: "visibility-observer"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }], {
    visible: [{
      type: Output
    }]
  });
})();
function isDate(value2) {
  return toString.call(value2) === "[object Date]";
}
function isNumber(value2) {
  return typeof value2 === "number";
}
var BaseChartComponent = class _BaseChartComponent {
  constructor(chartElement, zone, cd, platformId) {
    this.chartElement = chartElement;
    this.zone = zone;
    this.cd = cd;
    this.platformId = platformId;
    this.scheme = "cool";
    this.schemeType = ScaleType.Ordinal;
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.animations = false;
    }
  }
  ngAfterViewInit() {
    this.bindWindowResizeEvent();
    this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
    this.visibilityObserver.visible.subscribe(this.update.bind(this));
  }
  ngOnDestroy() {
    this.unbindEvents();
    if (this.visibilityObserver) {
      this.visibilityObserver.visible.unsubscribe();
      this.visibilityObserver.destroy();
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    if (this.results) {
      this.results = this.cloneData(this.results);
    } else {
      this.results = [];
    }
    if (this.view) {
      this.width = this.view[0];
      this.height = this.view[1];
    } else {
      const dims = this.getContainerDims();
      if (dims) {
        this.width = dims.width;
        this.height = dims.height;
      }
    }
    if (!this.width) {
      this.width = 600;
    }
    if (!this.height) {
      this.height = 400;
    }
    this.width = Math.floor(this.width);
    this.height = Math.floor(this.height);
    if (this.cd) {
      this.cd.markForCheck();
    }
  }
  getContainerDims() {
    let width;
    let height;
    const hostElem = this.chartElement.nativeElement;
    if (isPlatformBrowser(this.platformId) && hostElem.parentNode !== null) {
      const dims = hostElem.parentNode.getBoundingClientRect();
      width = dims.width;
      height = dims.height;
    }
    if (width && height) {
      return {
        width,
        height
      };
    }
    return null;
  }
  /**
   * Converts all date objects that appear as name
   * into formatted date strings
   */
  formatDates() {
    for (let i = 0; i < this.results.length; i++) {
      const g = this.results[i];
      g.label = g.name;
      if (isDate(g.label)) {
        g.label = g.label.toLocaleDateString();
      }
      if (g.series) {
        for (let j = 0; j < g.series.length; j++) {
          const d = g.series[j];
          d.label = d.name;
          if (isDate(d.label)) {
            d.label = d.label.toLocaleDateString();
          }
        }
      }
    }
  }
  unbindEvents() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  bindWindowResizeEvent() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const source = fromEvent(window, "resize");
    const subscription = source.pipe(debounceTime(200)).subscribe((e) => {
      this.update();
      if (this.cd) {
        this.cd.markForCheck();
      }
    });
    this.resizeSubscription = subscription;
  }
  /**
   * Clones the data into a new object
   *
   * @memberOf BaseChart
   */
  cloneData(data) {
    const results = [];
    for (const item of data) {
      const copy = {};
      if (item["name"] !== void 0) {
        copy["name"] = item["name"];
      }
      if (item["value"] !== void 0) {
        copy["value"] = item["value"];
      }
      if (item["series"] !== void 0) {
        copy["series"] = [];
        for (const seriesItem of item["series"]) {
          const seriesItemCopy = Object.assign({}, seriesItem);
          copy["series"].push(seriesItemCopy);
        }
      }
      if (item["extra"] !== void 0) {
        copy["extra"] = JSON.parse(JSON.stringify(item["extra"]));
      }
      if (item["source"] !== void 0) {
        copy["source"] = item["source"];
      }
      if (item["target"] !== void 0) {
        copy["target"] = item["target"];
      }
      results.push(copy);
    }
    return results;
  }
  static {
    this.\u0275fac = function BaseChartComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BaseChartComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BaseChartComponent,
      selectors: [["base-chart"]],
      inputs: {
        results: "results",
        view: "view",
        scheme: "scheme",
        schemeType: "schemeType",
        customColors: "customColors",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 1,
      vars: 0,
      template: function BaseChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "div");
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseChartComponent, [{
    type: Component,
    args: [{
      selector: "base-chart",
      template: ` <div></div> `
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    results: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    scheme: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    customColors: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var Orientation;
(function(Orientation2) {
  Orientation2["Top"] = "top";
  Orientation2["Bottom"] = "bottom";
  Orientation2["Left"] = "left";
  Orientation2["Right"] = "right";
})(Orientation || (Orientation = {}));
var AxisLabelComponent = class _AxisLabelComponent {
  constructor(element) {
    this.textHeight = 25;
    this.margin = 5;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.strokeWidth = "0.01";
    this.textAnchor = "middle";
    this.transform = "";
    switch (this.orient) {
      case Orientation.Top:
        this.y = this.offset;
        this.x = this.width / 2;
        break;
      case Orientation.Bottom:
        this.y = this.offset;
        this.x = this.width / 2;
        break;
      case Orientation.Left:
        this.y = -(this.offset + this.textHeight + this.margin);
        this.x = -this.height / 2;
        this.transform = "rotate(270)";
        break;
      case Orientation.Right:
        this.y = this.offset + this.margin;
        this.x = -this.height / 2;
        this.transform = "rotate(270)";
        break;
      default:
    }
  }
  static {
    this.\u0275fac = function AxisLabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AxisLabelComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AxisLabelComponent,
      selectors: [["g", "ngx-charts-axis-label", ""]],
      inputs: {
        orient: "orient",
        label: "label",
        offset: "offset",
        width: "width",
        height: "height"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c3,
      decls: 2,
      vars: 6,
      template: function AxisLabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "text");
          \u0275\u0275text(1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.label, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-axis-label]",
      template: `
    <svg:text
      [attr.stroke-width]="strokeWidth"
      [attr.x]="x"
      [attr.y]="y"
      [attr.text-anchor]="textAnchor"
      [attr.transform]="transform"
    >
      {{ label }}
    </svg:text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    orient: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }]
  });
})();
function trimLabel(s, max4 = 16) {
  if (typeof s !== "string") {
    if (typeof s === "number") {
      return s + "";
    } else {
      return "";
    }
  }
  s = s.trim();
  if (s.length <= max4) {
    return s;
  } else {
    return `${s.slice(0, max4)}...`;
  }
}
function reduceTicks(ticks, maxTicks) {
  if (ticks.length > maxTicks) {
    const reduced = [];
    const modulus = Math.floor(ticks.length / maxTicks);
    for (let i = 0; i < ticks.length; i++) {
      if (i % modulus === 0) {
        reduced.push(ticks[i]);
      }
    }
    ticks = reduced;
  }
  return ticks;
}
function getTickLines(label, maxLength, maxLines) {
  const labelString = (label || "").toString();
  let totalLines = [];
  if (/\s/.test(labelString)) {
    totalLines = labelString.split(/\s+/).reduce((lines, line) => {
      const last = (lines.pop() || "") + " ";
      return last.length + line.length > maxLength ? [...lines, last.trim(), line.trim()] : [...lines, last + line];
    }, []);
  } else {
    let startIndex = 0;
    while (startIndex < labelString.length) {
      totalLines.push(labelString.substring(startIndex, startIndex + maxLength));
      startIndex += maxLength;
    }
  }
  if (totalLines.length > maxLines) {
    totalLines = totalLines.splice(0, maxLines);
    totalLines[totalLines.length - 1] += "...";
  }
  return totalLines;
}
var TextAnchor;
(function(TextAnchor2) {
  TextAnchor2["Start"] = "start";
  TextAnchor2["Middle"] = "middle";
  TextAnchor2["End"] = "end";
})(TextAnchor || (TextAnchor = {}));
var XAxisTicksComponent = class _XAxisTicksComponent {
  get isWrapTicksSupported() {
    return this.wrapTicks && this.scale.step;
  }
  constructor(platformId) {
    this.platformId = platformId;
    this.tickArguments = [5];
    this.tickStroke = "#ccc";
    this.trimTicks = true;
    this.maxTickLength = 16;
    this.showGridLines = false;
    this.rotateTicks = true;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.verticalSpacing = 20;
    this.rotateLabels = false;
    this.innerTickSize = 6;
    this.outerTickSize = 6;
    this.tickPadding = 3;
    this.textAnchor = TextAnchor.Middle;
    this.maxTicksLength = 0;
    this.maxAllowedLength = 16;
    this.height = 0;
    this.approxHeight = 10;
    this.maxPossibleLengthForTickIfWrapped = 16;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngAfterViewInit() {
    setTimeout(() => this.updateDims());
  }
  updateDims() {
    if (!isPlatformBrowser(this.platformId)) {
      this.dimensionsChanged.emit({
        height: this.approxHeight
      });
      return;
    }
    const height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
    if (height !== this.height) {
      this.height = height;
      this.dimensionsChanged.emit({
        height: this.height
      });
      setTimeout(() => this.updateDims());
    }
  }
  update() {
    const scale = this.scale;
    this.ticks = this.getTicks();
    if (this.tickFormatting) {
      this.tickFormat = this.tickFormatting;
    } else if (scale.tickFormat) {
      this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
    } else {
      this.tickFormat = function(d) {
        if (d.constructor.name === "Date") {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    const angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
    this.adjustedScale = this.scale.bandwidth ? function(d) {
      return this.scale(d) + this.scale.bandwidth() * 0.5;
    } : this.scale;
    this.textTransform = "";
    if (angle && angle !== 0) {
      this.textTransform = `rotate(${angle})`;
      this.textAnchor = TextAnchor.End;
      this.verticalSpacing = 10;
    } else {
      this.textAnchor = TextAnchor.Middle;
    }
    setTimeout(() => this.updateDims());
  }
  getRotationAngle(ticks) {
    let angle = 0;
    this.maxTicksLength = 0;
    for (let i = 0; i < ticks.length; i++) {
      const tick = this.tickFormat(ticks[i]).toString();
      let tickLength = tick.length;
      if (this.trimTicks) {
        tickLength = this.tickTrim(tick).length;
      }
      if (tickLength > this.maxTicksLength) {
        this.maxTicksLength = tickLength;
      }
    }
    const len = Math.min(this.maxTicksLength, this.maxAllowedLength);
    const charWidth = 7;
    const wordWidth = len * charWidth;
    let baseWidth = wordWidth;
    const maxBaseWidth = Math.floor(this.width / ticks.length);
    while (baseWidth > maxBaseWidth && angle > -90) {
      angle -= 30;
      baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
    }
    let labelHeight = 14;
    if (this.isWrapTicksSupported) {
      const longestTick = this.ticks.reduce((earlier, current) => current.length > earlier.length ? current : earlier, "");
      const tickLines = this.tickChunks(longestTick);
      labelHeight = 14 * (tickLines.length || 1);
      this.maxPossibleLengthForTickIfWrapped = this.getMaxPossibleLengthForTick(longestTick);
    }
    const requiredHeight = angle !== 0 ? Math.max(Math.abs(Math.sin(angle * Math.PI / 180)) * this.maxTickLength * charWidth, 10) : labelHeight;
    this.approxHeight = Math.min(requiredHeight, 200);
    return angle;
  }
  getTicks() {
    let ticks;
    const maxTicks = this.getMaxTicks(20);
    const maxScaleTicks = this.getMaxTicks(100);
    if (this.tickValues) {
      ticks = this.tickValues;
    } else if (this.scale.ticks) {
      ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
    } else {
      ticks = this.scale.domain();
      ticks = reduceTicks(ticks, maxTicks);
    }
    return ticks;
  }
  getMaxTicks(tickWidth) {
    return Math.floor(this.width / tickWidth);
  }
  tickTransform(tick) {
    return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
  }
  gridLineTransform() {
    return `translate(0,${-this.verticalSpacing - 5})`;
  }
  tickTrim(label) {
    return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
  }
  getMaxPossibleLengthForTick(longestLabel) {
    if (this.scale.bandwidth) {
      const averageCharacterWidth = 7;
      const maxCharacters = Math.floor(this.scale.bandwidth() / averageCharacterWidth);
      const truncatedText = longestLabel.slice(0, maxCharacters);
      return Math.max(truncatedText.length, this.maxTickLength);
    }
    return this.maxTickLength;
  }
  tickChunks(label) {
    if (label.toString().length > this.maxTickLength && this.scale.bandwidth) {
      const maxAllowedLines = 5;
      let maxLines = this.rotateTicks ? Math.floor(this.scale.step() / 14) : maxAllowedLines;
      if (maxLines <= 1) {
        return [this.tickTrim(label)];
      }
      let possibleStringLength = Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength);
      if (!isPlatformBrowser(this.platformId)) {
        possibleStringLength = Math.floor(Math.min(this.approxHeight / maxAllowedLines, Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength)));
      }
      maxLines = Math.min(maxLines, maxAllowedLines);
      const lines = getTickLines(label, possibleStringLength, maxLines < 1 ? 1 : maxLines);
      return lines;
    }
    return [this.tickTrim(label)];
  }
  static {
    this.\u0275fac = function XAxisTicksComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _XAxisTicksComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _XAxisTicksComponent,
      selectors: [["g", "ngx-charts-x-axis-ticks", ""]],
      viewQuery: function XAxisTicksComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c4, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksElement = _t.first);
        }
      },
      inputs: {
        scale: "scale",
        orient: "orient",
        tickArguments: "tickArguments",
        tickValues: "tickValues",
        tickStroke: "tickStroke",
        trimTicks: "trimTicks",
        maxTickLength: "maxTickLength",
        tickFormatting: "tickFormatting",
        showGridLines: "showGridLines",
        gridLineHeight: "gridLineHeight",
        width: "width",
        rotateTicks: "rotateTicks",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        dimensionsChanged: "dimensionsChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c5,
      decls: 4,
      vars: 2,
      consts: [["ticksel", ""], ["tmplMultilineTick", ""], ["tmplSinglelineTick", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], [4, "ngIf"], ["stroke-width", "0.01", "font-size", "12px"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["x", "0", 4, "ngFor", "ngForOf"], ["x", "0"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]],
      template: function XAxisTicksComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", null, 0);
          \u0275\u0275template(2, XAxisTicksComponent__svg_g_2_Template, 2, 2, "g", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275template(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 4);
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("ngForOf", ctx.ticks);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks);
        }
      },
      dependencies: [NgForOf, NgIf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisTicksComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-x-axis-ticks]",
      template: `
    <svg:g #ticksel>
      <svg:g *ngFor="let tick of ticks" class="tick" [attr.transform]="tickTransform(tick)">
        <ng-container *ngIf="tickFormat(tick) as tickFormatted">
          <title>{{ tickFormatted }}</title>
          <svg:text
            stroke-width="0.01"
            font-size="12px"
            [attr.text-anchor]="textAnchor"
            [attr.transform]="textTransform"
          >
            <ng-container *ngIf="isWrapTicksSupported; then tmplMultilineTick; else tmplSinglelineTick"></ng-container>
          </svg:text>

          <ng-template #tmplMultilineTick>
            <ng-container *ngIf="tickChunks(tick) as tickLines">
              <svg:tspan *ngFor="let tickLine of tickLines; let i = index" x="0" [attr.y]="i * 12">
                {{ tickLine }}
              </svg:tspan>
            </ng-container>
          </ng-template>

          <ng-template #tmplSinglelineTick>
            {{ tickTrim(tickFormatted) }}
          </ng-template>
        </ng-container>
      </svg:g>
    </svg:g>

    <svg:g *ngFor="let tick of ticks" [attr.transform]="tickTransform(tick)">
      <svg:g *ngIf="showGridLines" [attr.transform]="gridLineTransform()">
        <svg:line class="gridline-path gridline-path-vertical" [attr.y1]="-gridLineHeight" y2="0" />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    scale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }],
    tickArguments: [{
      type: Input
    }],
    tickValues: [{
      type: Input
    }],
    tickStroke: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    gridLineHeight: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    rotateTicks: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksElement: [{
      type: ViewChild,
      args: ["ticksel"]
    }]
  });
})();
var XAxisComponent = class _XAxisComponent {
  constructor() {
    this.rotateTicks = true;
    this.showGridLines = false;
    this.xOrient = Orientation.Bottom;
    this.xAxisOffset = 0;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.xAxisClassName = "x axis";
    this.labelOffset = 0;
    this.fill = "none";
    this.stroke = "stroke";
    this.tickStroke = "#ccc";
    this.strokeWidth = "none";
    this.padding = 5;
    this.orientation = Orientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.transform = `translate(0,${this.xAxisOffset + this.padding + this.dims.height})`;
    if (typeof this.xAxisTickCount !== "undefined") {
      this.tickArguments = [this.xAxisTickCount];
    }
  }
  emitTicksHeight({
    height
  }) {
    const newLabelOffset = height + 25 + 5;
    if (newLabelOffset !== this.labelOffset) {
      this.labelOffset = newLabelOffset;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          height
        });
      }, 0);
    }
  }
  static {
    this.\u0275fac = function XAxisComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _XAxisComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _XAxisComponent,
      selectors: [["g", "ngx-charts-x-axis", ""]],
      viewQuery: function XAxisComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(XAxisTicksComponent, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksComponent = _t.first);
        }
      },
      inputs: {
        xScale: "xScale",
        dims: "dims",
        trimTicks: "trimTicks",
        rotateTicks: "rotateTicks",
        maxTickLength: "maxTickLength",
        tickFormatting: "tickFormatting",
        showGridLines: "showGridLines",
        showLabel: "showLabel",
        labelText: "labelText",
        ticks: "ticks",
        xAxisTickCount: "xAxisTickCount",
        xOrient: "xOrient",
        xAxisOffset: "xAxisOffset",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        dimensionsChanged: "dimensionsChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c6,
      decls: 3,
      vars: 4,
      consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "dimensionsChanged", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]],
      template: function XAxisComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g");
          \u0275\u0275template(1, XAxisComponent__svg_g_1_Template, 1, 13, "g", 0)(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("class", ctx.xAxisClassName)("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xScale);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showLabel);
        }
      },
      dependencies: [NgIf, AxisLabelComponent, XAxisTicksComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-x-axis]",
      template: `
    <svg:g [attr.class]="xAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-x-axis-ticks
        *ngIf="xScale"
        [trimTicks]="trimTicks"
        [rotateTicks]="rotateTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickStroke]="tickStroke"
        [scale]="xScale"
        [orient]="xOrient"
        [showGridLines]="showGridLines"
        [gridLineHeight]="dims.height"
        [width]="dims.width"
        [tickValues]="ticks"
        [wrapTicks]="wrapTicks"
        (dimensionsChanged)="emitTicksHeight($event)"
      />
      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="orientation.Bottom"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    xScale: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    rotateTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    showLabel: [{
      type: Input
    }],
    labelText: [{
      type: Input
    }],
    ticks: [{
      type: Input
    }],
    xAxisTickCount: [{
      type: Input
    }],
    xOrient: [{
      type: Input
    }],
    xAxisOffset: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksComponent: [{
      type: ViewChild,
      args: [XAxisTicksComponent]
    }]
  });
})();
function roundedRect(x2, y2, w, h, r, [tl, tr, bl, br]) {
  let retval = "";
  w = Math.floor(w);
  h = Math.floor(h);
  w = w === 0 ? 1 : w;
  h = h === 0 ? 1 : h;
  retval = `M${[x2 + r, y2]}`;
  retval += `h${w - 2 * r}`;
  if (tr) {
    retval += `a${[r, r]} 0 0 1 ${[r, r]}`;
  } else {
    retval += `h${r}v${r}`;
  }
  retval += `v${h - 2 * r}`;
  if (br) {
    retval += `a${[r, r]} 0 0 1 ${[-r, r]}`;
  } else {
    retval += `v${r}h${-r}`;
  }
  retval += `h${2 * r - w}`;
  if (bl) {
    retval += `a${[r, r]} 0 0 1 ${[-r, -r]}`;
  } else {
    retval += `h${-r}v${-r}`;
  }
  retval += `v${2 * r - h}`;
  if (tl) {
    retval += `a${[r, r]} 0 0 1 ${[r, -r]}`;
  } else {
    retval += `v${-r}h${r}`;
  }
  retval += `z`;
  return retval;
}
var YAxisTicksComponent = class _YAxisTicksComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.tickArguments = [5];
    this.tickStroke = "#ccc";
    this.trimTicks = true;
    this.maxTickLength = 16;
    this.showGridLines = false;
    this.showRefLabels = false;
    this.showRefLines = false;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.innerTickSize = 6;
    this.tickPadding = 3;
    this.verticalSpacing = 20;
    this.textAnchor = TextAnchor.Middle;
    this.width = 0;
    this.outerTickSize = 6;
    this.rotateLabels = false;
    this.referenceLineLength = 0;
    this.Orientation = Orientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngAfterViewInit() {
    setTimeout(() => this.updateDims());
  }
  updateDims() {
    if (!isPlatformBrowser(this.platformId)) {
      this.width = this.getApproximateAxisWidth();
      this.dimensionsChanged.emit({
        width: this.width
      });
      return;
    }
    const width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
    if (width !== this.width) {
      this.width = width;
      this.dimensionsChanged.emit({
        width
      });
      setTimeout(() => this.updateDims());
    }
  }
  update() {
    const scale = this.scale;
    const sign = this.orient === Orientation.Top || this.orient === Orientation.Right ? -1 : 1;
    this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
    this.ticks = this.getTicks();
    if (this.tickFormatting) {
      this.tickFormat = this.tickFormatting;
    } else if (scale.tickFormat) {
      this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
    } else {
      this.tickFormat = function(d) {
        if (d.constructor.name === "Date") {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    this.adjustedScale = scale.bandwidth ? (d) => {
      const positionMiddle = scale(d) + scale.bandwidth() * 0.5;
      if (this.wrapTicks && d.toString().length > this.maxTickLength) {
        const chunksLength = this.tickChunks(d).length;
        if (chunksLength === 1) {
          return positionMiddle;
        }
        const bandWidth = scale.bandwidth();
        const heightOfLines = chunksLength * 8;
        const availableFreeSpace = bandWidth * 0.5 - heightOfLines * 0.5;
        return scale(d) + availableFreeSpace;
      }
      return positionMiddle;
    } : scale;
    if (this.showRefLines && this.referenceLines) {
      this.setReferencelines();
    }
    switch (this.orient) {
      case Orientation.Top:
        this.transform = function(tick) {
          return "translate(" + this.adjustedScale(tick) + ",0)";
        };
        this.textAnchor = TextAnchor.Middle;
        this.y2 = this.innerTickSize * sign;
        this.y1 = this.tickSpacing * sign;
        this.dy = sign < 0 ? "0em" : ".71em";
        break;
      case Orientation.Bottom:
        this.transform = function(tick) {
          return "translate(" + this.adjustedScale(tick) + ",0)";
        };
        this.textAnchor = TextAnchor.Middle;
        this.y2 = this.innerTickSize * sign;
        this.y1 = this.tickSpacing * sign;
        this.dy = sign < 0 ? "0em" : ".71em";
        break;
      case Orientation.Left:
        this.transform = function(tick) {
          return "translate(0," + this.adjustedScale(tick) + ")";
        };
        this.textAnchor = TextAnchor.End;
        this.x2 = this.innerTickSize * -sign;
        this.x1 = this.tickSpacing * -sign;
        this.dy = ".32em";
        break;
      case Orientation.Right:
        this.transform = function(tick) {
          return "translate(0," + this.adjustedScale(tick) + ")";
        };
        this.textAnchor = TextAnchor.Start;
        this.x2 = this.innerTickSize * -sign;
        this.x1 = this.tickSpacing * -sign;
        this.dy = ".32em";
        break;
      default:
    }
    setTimeout(() => this.updateDims());
  }
  setReferencelines() {
    this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map((item) => item.value)));
    this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map((item) => item.value)));
    this.referenceLineLength = this.referenceLines.length;
    this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [false, false, false, false]);
  }
  getTicks() {
    let ticks;
    const maxTicks = this.getMaxTicks(20);
    const maxScaleTicks = this.getMaxTicks(50);
    if (this.tickValues) {
      ticks = this.tickValues;
    } else if (this.scale.ticks) {
      ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
    } else {
      ticks = this.scale.domain();
      ticks = reduceTicks(ticks, maxTicks);
    }
    return ticks;
  }
  getMaxTicks(tickHeight) {
    return Math.floor(this.height / tickHeight);
  }
  tickTransform(tick) {
    return `translate(${this.adjustedScale(tick)},${this.verticalSpacing})`;
  }
  gridLineTransform() {
    return `translate(5,0)`;
  }
  tickTrim(label) {
    return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
  }
  getApproximateAxisWidth() {
    const maxChars = Math.max(...this.ticks.map((t) => this.tickTrim(this.tickFormat(t)).length));
    const charWidth = 7;
    return maxChars * charWidth;
  }
  tickChunks(label) {
    if (label.toString().length > this.maxTickLength && this.scale.bandwidth) {
      const preferredWidth = this.maxTickLength;
      const maxLines = Math.floor(this.scale.bandwidth() / 15);
      if (maxLines <= 1) {
        return [this.tickTrim(label)];
      }
      return getTickLines(label, preferredWidth, Math.min(maxLines, 5));
    }
    return [this.tickFormat(label)];
  }
  static {
    this.\u0275fac = function YAxisTicksComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _YAxisTicksComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _YAxisTicksComponent,
      selectors: [["g", "ngx-charts-y-axis-ticks", ""]],
      viewQuery: function YAxisTicksComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c4, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksElement = _t.first);
        }
      },
      inputs: {
        scale: "scale",
        orient: "orient",
        tickArguments: "tickArguments",
        tickValues: "tickValues",
        tickStroke: "tickStroke",
        trimTicks: "trimTicks",
        maxTickLength: "maxTickLength",
        tickFormatting: "tickFormatting",
        showGridLines: "showGridLines",
        gridLineWidth: "gridLineWidth",
        height: "height",
        referenceLines: "referenceLines",
        showRefLabels: "showRefLabels",
        showRefLines: "showRefLines",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        dimensionsChanged: "dimensionsChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c7,
      decls: 6,
      vars: 4,
      consts: [["ticksel", ""], ["tmplMultilineTick", ""], ["tmplSinglelineTick", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], [4, "ngIf"], ["stroke-width", "0.01"], [4, "ngIf", "ngIfThen", "ngIfElse"], [4, "ngIf", "ngIfElse"], ["x", "0", 4, "ngFor", "ngForOf"], ["x", "0"], [1, "reference-area"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]],
      template: function YAxisTicksComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", null, 0);
          \u0275\u0275template(2, YAxisTicksComponent__svg_g_2_Template, 2, 2, "g", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275template(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 4)(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 5)(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 5);
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("ngForOf", ctx.ticks);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.referenceLines);
        }
      },
      dependencies: [NgForOf, NgIf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisTicksComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-y-axis-ticks]",
      template: `
    <svg:g #ticksel>
      <svg:g *ngFor="let tick of ticks" class="tick" [attr.transform]="transform(tick)">
        <ng-container *ngIf="tickFormat(tick) as tickFormatted">
          <title>{{ tickFormatted }}</title>
          <svg:text
            stroke-width="0.01"
            [attr.dy]="dy"
            [attr.x]="x1"
            [attr.y]="y1"
            [attr.text-anchor]="textAnchor"
            [style.font-size]="'12px'"
          >
            <ng-container *ngIf="wrapTicks; then tmplMultilineTick; else tmplSinglelineTick"></ng-container>
          </svg:text>

          <ng-template #tmplMultilineTick>
            <ng-container *ngIf="tickChunks(tick) as tickLines">
              <ng-container *ngIf="tickLines.length > 1; else tmplSinglelineTick">
                <svg:tspan *ngFor="let tickLine of tickLines; let i = index" x="0" [attr.y]="i * (8 + tickSpacing)">
                  {{ tickLine }}
                </svg:tspan>
              </ng-container>
            </ng-container>
          </ng-template>

          <ng-template #tmplSinglelineTick>
            {{ tickTrim(tickFormatted) }}
          </ng-template>
        </ng-container>
      </svg:g>
    </svg:g>

    <svg:path
      *ngIf="referenceLineLength > 1 && refMax && refMin && showRefLines"
      class="reference-area"
      [attr.d]="referenceAreaPath"
      [attr.transform]="gridLineTransform()"
    />
    <svg:g *ngFor="let tick of ticks" [attr.transform]="transform(tick)">
      <svg:g *ngIf="showGridLines" [attr.transform]="gridLineTransform()">
        <svg:line
          *ngIf="orient === Orientation.Left"
          class="gridline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="gridLineWidth"
        />
        <svg:line
          *ngIf="orient === Orientation.Right"
          class="gridline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="-gridLineWidth"
        />
      </svg:g>
    </svg:g>

    <svg:g *ngFor="let refLine of referenceLines">
      <svg:g *ngIf="showRefLines" [attr.transform]="transform(refLine.value)">
        <svg:line
          class="refline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="gridLineWidth"
          [attr.transform]="gridLineTransform()"
        />
        <svg:g *ngIf="showRefLabels">
          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>
          <svg:text
            class="refline-label"
            [attr.dy]="dy"
            [attr.y]="-6"
            [attr.x]="gridLineWidth"
            [attr.text-anchor]="textAnchor"
          >
            {{ refLine.name }}
          </svg:text>
        </svg:g>
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    scale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }],
    tickArguments: [{
      type: Input
    }],
    tickValues: [{
      type: Input
    }],
    tickStroke: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    gridLineWidth: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksElement: [{
      type: ViewChild,
      args: ["ticksel"]
    }]
  });
})();
var YAxisComponent = class _YAxisComponent {
  constructor() {
    this.showGridLines = false;
    this.yOrient = Orientation.Left;
    this.yAxisOffset = 0;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.yAxisClassName = "y axis";
    this.labelOffset = 15;
    this.fill = "none";
    this.stroke = "#CCC";
    this.tickStroke = "#CCC";
    this.strokeWidth = 1;
    this.padding = 5;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.offset = -(this.yAxisOffset + this.padding);
    if (this.yOrient === Orientation.Right) {
      this.labelOffset = 65;
      this.transform = `translate(${this.offset + this.dims.width} , 0)`;
    } else {
      this.transform = `translate(${this.offset} , 0)`;
    }
    if (this.yAxisTickCount !== void 0) {
      this.tickArguments = [this.yAxisTickCount];
    }
  }
  emitTicksWidth({
    width
  }) {
    if (width !== this.labelOffset && this.yOrient === Orientation.Right) {
      this.labelOffset = width + this.labelOffset;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          width
        });
      }, 0);
    } else if (width !== this.labelOffset) {
      this.labelOffset = width;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          width
        });
      }, 0);
    }
  }
  static {
    this.\u0275fac = function YAxisComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _YAxisComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _YAxisComponent,
      selectors: [["g", "ngx-charts-y-axis", ""]],
      viewQuery: function YAxisComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(YAxisTicksComponent, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksComponent = _t.first);
        }
      },
      inputs: {
        yScale: "yScale",
        dims: "dims",
        trimTicks: "trimTicks",
        maxTickLength: "maxTickLength",
        tickFormatting: "tickFormatting",
        ticks: "ticks",
        showGridLines: "showGridLines",
        showLabel: "showLabel",
        labelText: "labelText",
        yAxisTickCount: "yAxisTickCount",
        yOrient: "yOrient",
        referenceLines: "referenceLines",
        showRefLines: "showRefLines",
        showRefLabels: "showRefLabels",
        yAxisOffset: "yAxisOffset",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        dimensionsChanged: "dimensionsChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c8,
      decls: 3,
      vars: 4,
      consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "dimensionsChanged", "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]],
      template: function YAxisComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g");
          \u0275\u0275template(1, YAxisComponent__svg_g_1_Template, 1, 15, "g", 0)(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("class", ctx.yAxisClassName)("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yScale);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showLabel);
        }
      },
      dependencies: [NgIf, AxisLabelComponent, YAxisTicksComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-y-axis]",
      template: `
    <svg:g [attr.class]="yAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-y-axis-ticks
        *ngIf="yScale"
        [trimTicks]="trimTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickValues]="ticks"
        [tickStroke]="tickStroke"
        [scale]="yScale"
        [orient]="yOrient"
        [showGridLines]="showGridLines"
        [gridLineWidth]="dims.width"
        [referenceLines]="referenceLines"
        [showRefLines]="showRefLines"
        [showRefLabels]="showRefLabels"
        [height]="dims.height"
        [wrapTicks]="wrapTicks"
        (dimensionsChanged)="emitTicksWidth($event)"
      />

      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="yOrient"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    yScale: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    ticks: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    showLabel: [{
      type: Input
    }],
    labelText: [{
      type: Input
    }],
    yAxisTickCount: [{
      type: Input
    }],
    yOrient: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    yAxisOffset: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksComponent: [{
      type: ViewChild,
      args: [YAxisTicksComponent]
    }]
  });
})();
var AxesModule = class _AxesModule {
  static {
    this.\u0275fac = function AxesModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AxesModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _AxesModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxesModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
      exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
    }]
  }], null, null);
})();
var StyleTypes;
(function(StyleTypes2) {
  StyleTypes2["popover"] = "popover";
  StyleTypes2["tooltip"] = "tooltip";
})(StyleTypes || (StyleTypes = {}));
var ShowTypes;
(function(ShowTypes2) {
  ShowTypes2[ShowTypes2["all"] = "all"] = "all";
  ShowTypes2[ShowTypes2["focus"] = "focus"] = "focus";
  ShowTypes2[ShowTypes2["mouseover"] = "mouseover"] = "mouseover";
})(ShowTypes || (ShowTypes = {}));
var TooltipDirective = class _TooltipDirective {
  get listensForFocus() {
    return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.focus;
  }
  get listensForHover() {
    return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.mouseover;
  }
  constructor(tooltipService, viewContainerRef, renderer) {
    this.tooltipService = tooltipService;
    this.viewContainerRef = viewContainerRef;
    this.renderer = renderer;
    this.tooltipCssClass = "";
    this.tooltipAppendToBody = true;
    this.tooltipSpacing = 10;
    this.tooltipDisabled = false;
    this.tooltipShowCaret = true;
    this.tooltipPlacement = PlacementTypes.Top;
    this.tooltipAlignment = PlacementTypes.Center;
    this.tooltipType = StyleTypes.popover;
    this.tooltipCloseOnClickOutside = true;
    this.tooltipCloseOnMouseLeave = true;
    this.tooltipHideTimeout = 300;
    this.tooltipShowTimeout = 100;
    this.tooltipShowEvent = ShowTypes.all;
    this.tooltipImmediateExit = false;
    this.show = new EventEmitter();
    this.hide = new EventEmitter();
  }
  ngOnDestroy() {
    this.hideTooltip(true);
  }
  onFocus() {
    if (this.listensForFocus) {
      this.showTooltip();
    }
  }
  onBlur() {
    if (this.listensForFocus) {
      this.hideTooltip(true);
    }
  }
  onMouseEnter() {
    if (this.listensForHover) {
      this.showTooltip();
    }
  }
  onMouseLeave(target) {
    if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
      clearTimeout(this.timeout);
      if (this.component) {
        const contentDom = this.component.instance.element.nativeElement;
        const contains = contentDom.contains(target);
        if (contains) return;
      }
      this.hideTooltip(this.tooltipImmediateExit);
    }
  }
  onMouseClick() {
    if (this.listensForHover) {
      this.hideTooltip(true);
    }
  }
  showTooltip(immediate) {
    if (this.component || this.tooltipDisabled) return;
    const time2 = immediate ? 0 : this.tooltipShowTimeout + (navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) ? 400 : 0);
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => {
      this.tooltipService.destroyAll();
      const options = this.createBoundOptions();
      this.component = this.tooltipService.create(options);
      setTimeout(() => {
        if (this.component) {
          this.addHideListeners(this.component.instance.element.nativeElement);
        }
      }, 10);
      this.show.emit(true);
    }, time2);
  }
  addHideListeners(tooltip) {
    this.mouseEnterContentEvent = this.renderer.listen(tooltip, "mouseenter", () => {
      clearTimeout(this.timeout);
    });
    if (this.tooltipCloseOnMouseLeave) {
      this.mouseLeaveContentEvent = this.renderer.listen(tooltip, "mouseleave", () => {
        this.hideTooltip(this.tooltipImmediateExit);
      });
    }
    if (this.tooltipCloseOnClickOutside) {
      this.documentClickEvent = this.renderer.listen("window", "click", (event) => {
        const contains = tooltip.contains(event.target);
        if (!contains) this.hideTooltip();
      });
    }
  }
  hideTooltip(immediate = false) {
    if (!this.component) return;
    const destroyFn = () => {
      if (this.mouseLeaveContentEvent) this.mouseLeaveContentEvent();
      if (this.mouseEnterContentEvent) this.mouseEnterContentEvent();
      if (this.documentClickEvent) this.documentClickEvent();
      this.hide.emit(true);
      this.tooltipService.destroy(this.component);
      this.component = void 0;
    };
    clearTimeout(this.timeout);
    if (!immediate) {
      this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
    } else {
      destroyFn();
    }
  }
  createBoundOptions() {
    return {
      title: this.tooltipTitle,
      template: this.tooltipTemplate,
      host: this.viewContainerRef.element,
      placement: this.tooltipPlacement,
      alignment: this.tooltipAlignment,
      type: this.tooltipType,
      showCaret: this.tooltipShowCaret,
      cssClass: this.tooltipCssClass,
      spacing: this.tooltipSpacing,
      context: this.tooltipContext
    };
  }
  static {
    this.\u0275fac = function TooltipDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TooltipDirective)(\u0275\u0275directiveInject(TooltipService), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2));
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _TooltipDirective,
      selectors: [["", "ngx-tooltip", ""]],
      hostBindings: function TooltipDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("focusin", function TooltipDirective_focusin_HostBindingHandler() {
            return ctx.onFocus();
          })("blur", function TooltipDirective_blur_HostBindingHandler() {
            return ctx.onBlur();
          })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) {
            return ctx.onMouseLeave($event.target);
          })("click", function TooltipDirective_click_HostBindingHandler() {
            return ctx.onMouseClick();
          });
        }
      },
      inputs: {
        tooltipCssClass: "tooltipCssClass",
        tooltipTitle: "tooltipTitle",
        tooltipAppendToBody: "tooltipAppendToBody",
        tooltipSpacing: "tooltipSpacing",
        tooltipDisabled: "tooltipDisabled",
        tooltipShowCaret: "tooltipShowCaret",
        tooltipPlacement: "tooltipPlacement",
        tooltipAlignment: "tooltipAlignment",
        tooltipType: "tooltipType",
        tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside",
        tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave",
        tooltipHideTimeout: "tooltipHideTimeout",
        tooltipShowTimeout: "tooltipShowTimeout",
        tooltipTemplate: "tooltipTemplate",
        tooltipShowEvent: "tooltipShowEvent",
        tooltipContext: "tooltipContext",
        tooltipImmediateExit: "tooltipImmediateExit"
      },
      outputs: {
        show: "show",
        hide: "hide"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[ngx-tooltip]"
    }]
  }], () => [{
    type: TooltipService
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }], {
    tooltipCssClass: [{
      type: Input
    }],
    tooltipTitle: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipSpacing: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipShowCaret: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipAlignment: [{
      type: Input
    }],
    tooltipType: [{
      type: Input
    }],
    tooltipCloseOnClickOutside: [{
      type: Input
    }],
    tooltipCloseOnMouseLeave: [{
      type: Input
    }],
    tooltipHideTimeout: [{
      type: Input
    }],
    tooltipShowTimeout: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipShowEvent: [{
      type: Input
    }],
    tooltipContext: [{
      type: Input
    }],
    tooltipImmediateExit: [{
      type: Input
    }],
    show: [{
      type: Output
    }],
    hide: [{
      type: Output
    }],
    onFocus: [{
      type: HostListener,
      args: ["focusin"]
    }],
    onBlur: [{
      type: HostListener,
      args: ["blur"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave", ["$event.target"]]
    }],
    onMouseClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var TooltipModule = class _TooltipModule {
  static {
    this.\u0275fac = function TooltipModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TooltipModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _TooltipModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [InjectionService, TooltipService],
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipModule, [{
    type: NgModule,
    args: [{
      declarations: [TooltipContentComponent, TooltipDirective],
      providers: [InjectionService, TooltipService],
      exports: [TooltipContentComponent, TooltipDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var cache = {};
function id() {
  let newId = ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
  newId = `a${newId}`;
  if (!cache[newId]) {
    cache[newId] = true;
    return newId;
  }
  return id();
}
var BarOrientation;
(function(BarOrientation2) {
  BarOrientation2["Vertical"] = "vertical";
  BarOrientation2["Horizontal"] = "horizontal";
})(BarOrientation || (BarOrientation = {}));
var CircleComponent = class _CircleComponent {
  constructor() {
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  onClick() {
    this.select.emit(this.data);
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  ngOnChanges(changes) {
    this.classNames = Array.isArray(this.classNames) ? this.classNames.join(" ") : "";
    this.classNames += "circle";
  }
  static {
    this.\u0275fac = function CircleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CircleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CircleComponent,
      selectors: [["g", "ngx-charts-circle", ""]],
      hostBindings: function CircleComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("click", function CircleComponent_click_HostBindingHandler() {
            return ctx.onClick();
          })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() {
            return ctx.onMouseLeave();
          });
        }
      },
      inputs: {
        cx: "cx",
        cy: "cy",
        r: "r",
        fill: "fill",
        stroke: "stroke",
        data: "data",
        classNames: "classNames",
        circleOpacity: "circleOpacity",
        pointerEvents: "pointerEvents"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c9,
      decls: 1,
      vars: 8,
      template: function CircleComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275element(0, "circle");
        }
        if (rf & 2) {
          \u0275\u0275attribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircleComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-circle]",
      template: `
    <svg:circle
      [attr.cx]="cx"
      [attr.cy]="cy"
      [attr.r]="r"
      [attr.fill]="fill"
      [attr.stroke]="stroke"
      [attr.opacity]="circleOpacity"
      [attr.class]="classNames"
      [attr.pointer-events]="pointerEvents"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    cx: [{
      type: Input
    }],
    cy: [{
      type: Input
    }],
    r: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    classNames: [{
      type: Input
    }],
    circleOpacity: [{
      type: Input
    }],
    pointerEvents: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var SvgLinearGradientComponent = class _SvgLinearGradientComponent {
  constructor() {
    this.orientation = BarOrientation.Vertical;
  }
  ngOnChanges(changes) {
    this.x1 = "0%";
    this.x2 = "0%";
    this.y1 = "0%";
    this.y2 = "0%";
    if (this.orientation === BarOrientation.Horizontal) {
      this.x2 = "100%";
    } else if (this.orientation === BarOrientation.Vertical) {
      this.y1 = "100%";
    }
  }
  static {
    this.\u0275fac = function SvgLinearGradientComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SvgLinearGradientComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SvgLinearGradientComponent,
      selectors: [["g", "ngx-charts-svg-linear-gradient", ""]],
      inputs: {
        orientation: "orientation",
        name: "name",
        stops: "stops"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c10,
      decls: 2,
      vars: 6,
      consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]],
      template: function SvgLinearGradientComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "linearGradient", 0);
          \u0275\u0275template(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("id", ctx.name);
          \u0275\u0275attribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.stops);
        }
      },
      dependencies: [NgForOf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SvgLinearGradientComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-svg-linear-gradient]",
      template: `
    <svg:linearGradient [id]="name" [attr.x1]="x1" [attr.y1]="y1" [attr.x2]="x2" [attr.y2]="y2">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:linearGradient>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    orientation: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    stops: [{
      type: Input
    }]
  });
})();
var SeriesType;
(function(SeriesType2) {
  SeriesType2["Standard"] = "standard";
  SeriesType2["Stacked"] = "stacked";
})(SeriesType || (SeriesType = {}));
var CircleSeriesComponent = class _CircleSeriesComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.type = SeriesType.Standard;
    this.tooltipDisabled = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.barVisible = false;
    this.barOrientation = BarOrientation;
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.isSSR = false;
  }
  ngOnInit() {
    this.gradientId = "grad" + id().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges() {
    this.update();
  }
  update() {
    this.circle = this.getActiveCircle();
  }
  getActiveCircle() {
    const indexActiveDataPoint = this.data.series.findIndex((d) => {
      const label = d.name;
      return label && this.visibleValue && label.toString() === this.visibleValue.toString() && d.value !== void 0;
    });
    if (indexActiveDataPoint === -1) {
      return void 0;
    }
    return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
  }
  mapDataPointToCircle(d, i) {
    const seriesName = this.data.name;
    const value2 = d.value;
    const label = d.name;
    const tooltipLabel = formatLabel(label);
    let cx;
    if (this.scaleType === ScaleType.Time) {
      cx = this.xScale(label);
    } else if (this.scaleType === ScaleType.Linear) {
      cx = this.xScale(Number(label));
    } else {
      cx = this.xScale(label);
    }
    const cy = this.yScale(this.type === SeriesType.Standard ? value2 : d.d1);
    const radius = 5;
    const height = this.yScale.range()[0] - cy;
    const opacity = 1;
    let color2;
    if (this.colors.scaleType === ScaleType.Linear) {
      if (this.type === SeriesType.Standard) {
        color2 = this.colors.getColor(value2);
      } else {
        color2 = this.colors.getColor(d.d1);
      }
    } else {
      color2 = this.colors.getColor(seriesName);
    }
    const data = Object.assign({}, d, {
      series: seriesName,
      value: value2,
      name: label
    });
    return {
      classNames: [`circle-data-${i}`],
      value: value2,
      label,
      data,
      cx,
      cy,
      radius,
      height,
      tooltipLabel,
      color: color2,
      opacity,
      seriesName,
      gradientStops: this.getGradientStops(color2),
      min: d.min,
      max: d.max
    };
  }
  getTooltipText({
    tooltipLabel,
    value: value2,
    seriesName,
    min: min4,
    max: max4
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(seriesName)} \u2022 ${escapeLabel(tooltipLabel)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}${this.getTooltipMinMaxText(min4, max4)}</span>
    `;
  }
  getTooltipMinMaxText(min4, max4) {
    if (min4 !== void 0 || max4 !== void 0) {
      let result = " (";
      if (min4 !== void 0) {
        if (max4 === void 0) {
          result += "\u2265";
        }
        result += min4.toLocaleString();
        if (max4 !== void 0) {
          result += " - ";
        }
      } else if (max4 !== void 0) {
        result += "\u2264";
      }
      if (max4 !== void 0) {
        result += max4.toLocaleString();
      }
      result += ")";
      return result;
    } else {
      return "";
    }
  }
  getGradientStops(color2) {
    return [{
      offset: 0,
      color: color2,
      opacity: 0.2
    }, {
      offset: 100,
      color: color2,
      opacity: 1
    }];
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  activateCircle() {
    this.barVisible = true;
    this.activate.emit({
      name: this.data.name
    });
  }
  deactivateCircle() {
    this.barVisible = false;
    this.circle.opacity = 0;
    this.deactivate.emit({
      name: this.data.name
    });
  }
  static {
    this.\u0275fac = function CircleSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CircleSeriesComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CircleSeriesComponent,
      selectors: [["g", "ngx-charts-circle-series", ""]],
      inputs: {
        data: "data",
        type: "type",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        scaleType: "scaleType",
        visibleValue: "visibleValue",
        activeEntries: "activeEntries",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c11,
      decls: 1,
      vars: 1,
      consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], [1, "tooltip-bar"]],
      template: function CircleSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, CircleSeriesComponent__svg_g_0_Template, 6, 22, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", ctx.circle);
        }
      },
      dependencies: [NgIf, TooltipDirective, CircleComponent, SvgLinearGradientComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":enter", [style({
          opacity: 0
        }), animate(250, style({
          opacity: 1
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircleSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-circle-series]",
      template: `
    <svg:g *ngIf="circle">
      <defs>
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="circle.gradientStops"
        />
      </defs>
      <svg:rect
        *ngIf="!isSSR && barVisible && type === 'standard'"
        [@animationState]="'active'"
        [attr.x]="circle.cx - circle.radius"
        [attr.y]="circle.cy"
        [attr.width]="circle.radius * 2"
        [attr.height]="circle.height"
        [attr.fill]="gradientFill"
        class="tooltip-bar"
      />
      <svg:rect
        *ngIf="isSSR && barVisible && type === 'standard'"
        [attr.x]="circle.cx - circle.radius"
        [attr.y]="circle.cy"
        [attr.width]="circle.radius * 2"
        [attr.height]="circle.height"
        [attr.fill]="gradientFill"
        class="tooltip-bar"
      />
      <svg:g
        ngx-charts-circle
        class="circle"
        [cx]="circle.cx"
        [cy]="circle.cy"
        [r]="circle.radius"
        [fill]="circle.color"
        [class.active]="isActive({ name: circle.seriesName })"
        [pointerEvents]="circle.value === 0 ? 'none' : 'all'"
        [data]="circle.value"
        [classNames]="circle.classNames"
        (select)="onClick(circle.data)"
        (activate)="activateCircle()"
        (deactivate)="deactivateCircle()"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="circle.data"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        opacity: 0
      }), animate(250, style({
        opacity: 1
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    visibleValue: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var GridPanelComponent = class _GridPanelComponent {
  static {
    this.\u0275fac = function GridPanelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GridPanelComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _GridPanelComponent,
      selectors: [["g", "ngx-charts-grid-panel", ""]],
      inputs: {
        width: "width",
        height: "height",
        x: "x",
        y: "y"
      },
      standalone: false,
      attrs: _c132,
      decls: 1,
      vars: 4,
      consts: [["stroke", "none", 1, "gridpanel"]],
      template: function GridPanelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275element(0, "rect", 0);
        }
        if (rf & 2) {
          \u0275\u0275attribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridPanelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-grid-panel]",
      template: `
    <svg:rect [attr.height]="height" [attr.width]="width" [attr.x]="x" [attr.y]="y" stroke="none" class="gridpanel" />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var ClassEnum;
(function(ClassEnum2) {
  ClassEnum2["Odd"] = "odd";
  ClassEnum2["Even"] = "even";
})(ClassEnum || (ClassEnum = {}));
var GridPanelSeriesComponent = class _GridPanelSeriesComponent {
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.gridPanels = this.getGridPanels();
  }
  getGridPanels() {
    return this.data.map((d) => {
      let offset;
      let width;
      let height;
      let x2;
      let y2;
      let className = ClassEnum.Odd;
      if (this.orient === BarOrientation.Vertical) {
        const position = this.xScale(d.name);
        const positionIndex = Number.parseInt((position / this.xScale.step()).toString(), 10);
        if (positionIndex % 2 === 1) {
          className = ClassEnum.Even;
        }
        offset = this.xScale.bandwidth() * this.xScale.paddingInner();
        width = this.xScale.bandwidth() + offset;
        height = this.dims.height;
        x2 = this.xScale(d.name) - offset / 2;
        y2 = 0;
      } else if (this.orient === BarOrientation.Horizontal) {
        const position = this.yScale(d.name);
        const positionIndex = Number.parseInt((position / this.yScale.step()).toString(), 10);
        if (positionIndex % 2 === 1) {
          className = ClassEnum.Even;
        }
        offset = this.yScale.bandwidth() * this.yScale.paddingInner();
        width = this.dims.width;
        height = this.yScale.bandwidth() + offset;
        x2 = 0;
        y2 = this.yScale(d.name) - offset / 2;
      }
      return {
        name: d.name,
        class: className,
        height,
        width,
        x: x2,
        y: y2
      };
    });
  }
  static {
    this.\u0275fac = function GridPanelSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GridPanelSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _GridPanelSeriesComponent,
      selectors: [["g", "ngx-charts-grid-panel-series", ""]],
      inputs: {
        data: "data",
        dims: "dims",
        xScale: "xScale",
        yScale: "yScale",
        orient: "orient"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c14,
      decls: 1,
      vars: 1,
      consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]],
      template: function GridPanelSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.gridPanels);
        }
      },
      dependencies: [NgForOf, GridPanelComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridPanelSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-grid-panel-series]",
      template: `
    <svg:g
      ngx-charts-grid-panel
      *ngFor="let gridPanel of gridPanels"
      [height]="gridPanel.height"
      [width]="gridPanel.width"
      [x]="gridPanel.x"
      [y]="gridPanel.y"
      [class.grid-panel]="true"
      [class.odd]="gridPanel.class === 'odd'"
      [class.even]="gridPanel.class === 'even'"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }]
  });
})();
var SvgRadialGradientComponent = class _SvgRadialGradientComponent {
  constructor() {
    this.endOpacity = 1;
    this.cx = 0;
    this.cy = 0;
  }
  get stops() {
    return this.stopsInput || this.stopsDefault;
  }
  set stops(value2) {
    this.stopsInput = value2;
  }
  ngOnChanges(changes) {
    this.r = "30%";
    if ("color" in changes || "startOpacity" in changes || "endOpacity" in changes) {
      this.stopsDefault = [{
        offset: 0,
        color: this.color,
        opacity: this.startOpacity
      }, {
        offset: 100,
        color: this.color,
        opacity: this.endOpacity
      }];
    }
  }
  static {
    this.\u0275fac = function SvgRadialGradientComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SvgRadialGradientComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SvgRadialGradientComponent,
      selectors: [["g", "ngx-charts-svg-radial-gradient", ""]],
      inputs: {
        color: "color",
        name: "name",
        startOpacity: "startOpacity",
        endOpacity: "endOpacity",
        cx: "cx",
        cy: "cy",
        stops: "stops"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c15,
      decls: 2,
      vars: 5,
      consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]],
      template: function SvgRadialGradientComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "radialGradient", 0);
          \u0275\u0275template(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("id", ctx.name);
          \u0275\u0275attribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.stops);
        }
      },
      dependencies: [NgForOf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SvgRadialGradientComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-svg-radial-gradient]",
      template: `
    <svg:radialGradient [id]="name" [attr.cx]="cx" [attr.cy]="cy" [attr.r]="r" gradientUnits="userSpaceOnUse">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:radialGradient>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    color: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    startOpacity: [{
      type: Input
    }],
    endOpacity: [{
      type: Input
    }],
    cx: [{
      type: Input
    }],
    cy: [{
      type: Input
    }],
    stops: [{
      type: Input
    }]
  });
})();
var AreaComponent = class _AreaComponent {
  constructor(element) {
    this.opacity = 1;
    this.startOpacity = 0.5;
    this.endOpacity = 1;
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.animationsLoaded = false;
    this.hasGradient = false;
    this.barOrientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges() {
    this.update();
    if (!this.animationsLoaded) {
      this.loadAnimation();
      this.animationsLoaded = true;
    }
  }
  update() {
    this.gradientId = "grad" + id().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient || this.stops) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updatePathEl();
  }
  loadAnimation() {
    this.areaPath = this.startingPath;
    setTimeout(this.updatePathEl.bind(this), 100);
  }
  updatePathEl() {
    const node = select_default(this.element).select(".area");
    if (this.animations) {
      node.transition().duration(750).attr("d", this.path);
    } else {
      node.attr("d", this.path);
    }
  }
  getGradient() {
    if (this.stops) {
      return this.stops;
    }
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.startOpacity
    }, {
      offset: 100,
      color: this.fill,
      opacity: this.endOpacity
    }];
  }
  static {
    this.\u0275fac = function AreaComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AreaComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AreaComponent,
      selectors: [["g", "ngx-charts-area", ""]],
      inputs: {
        data: "data",
        path: "path",
        startingPath: "startingPath",
        fill: "fill",
        opacity: "opacity",
        startOpacity: "startOpacity",
        endOpacity: "endOpacity",
        gradient: "gradient",
        stops: "stops",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c16,
      decls: 2,
      vars: 5,
      consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
      template: function AreaComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, AreaComponent__svg_defs_0_Template, 2, 3, "defs", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275element(1, "path", 1);
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", ctx.gradient);
          \u0275\u0275advance();
          \u0275\u0275styleProp("opacity", ctx.opacity);
          \u0275\u0275attribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
        }
      },
      dependencies: [NgIf, SvgLinearGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-area]",
      template: `
    <svg:defs *ngIf="gradient">
      <svg:g
        ngx-charts-svg-linear-gradient
        [orientation]="barOrientation.Vertical"
        [name]="gradientId"
        [stops]="gradientStops"
      />
    </svg:defs>
    <svg:path class="area" [attr.d]="areaPath" [attr.fill]="gradient ? gradientFill : fill" [style.opacity]="opacity" />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    data: [{
      type: Input
    }],
    path: [{
      type: Input
    }],
    startingPath: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    startOpacity: [{
      type: Input
    }],
    endOpacity: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    stops: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
function easeOutExpo(t, b, c, d) {
  return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
}
function count2(countFrom, countTo, countDecimals, countDuration, callback) {
  const startVal = Number(countFrom);
  const endVal = Number(countTo);
  const countDown = startVal > endVal;
  const decimals = Math.max(0, countDecimals);
  const dec = Math.pow(10, decimals);
  const duration = Number(countDuration) * 1e3;
  let startTime;
  function runCount(timestamp) {
    let frameVal;
    const progress = timestamp - startTime;
    if (countDown) {
      frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
    } else {
      frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
    }
    if (countDown) {
      frameVal = frameVal < endVal ? endVal : frameVal;
    } else {
      frameVal = frameVal > endVal ? endVal : frameVal;
    }
    frameVal = Math.round(frameVal * dec) / dec;
    const tick = progress < duration;
    callback({
      value: frameVal,
      progress,
      timestamp,
      finished: !tick
    });
    if (tick) {
      return requestAnimationFrame((val) => runCount(val));
    }
  }
  return requestAnimationFrame((timestamp) => {
    startTime = timestamp;
    return runCount(timestamp);
  });
}
function decimalChecker(countTo) {
  const endVal = Number(countTo);
  if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
    return 2;
  }
  return 0;
}
var CountUpDirective = class _CountUpDirective {
  set countDecimals(val) {
    this._countDecimals = val;
  }
  get countDecimals() {
    if (this._countDecimals) return this._countDecimals;
    return decimalChecker(this.countTo);
  }
  set countTo(val) {
    this._countTo = parseFloat(val);
    this.start();
  }
  get countTo() {
    return this._countTo;
  }
  set countFrom(val) {
    this._countFrom = parseFloat(val);
    this.start();
  }
  get countFrom() {
    return this._countFrom;
  }
  constructor(cd, element) {
    this.cd = cd;
    this.countDuration = 1;
    this.countPrefix = "";
    this.countSuffix = "";
    this.countChange = new EventEmitter();
    this.countFinish = new EventEmitter();
    this.value = "";
    this._countDecimals = 0;
    this._countTo = 0;
    this._countFrom = 0;
    this.nativeElement = element.nativeElement;
  }
  ngOnDestroy() {
    cancelAnimationFrame(this.animationReq);
  }
  start() {
    cancelAnimationFrame(this.animationReq);
    const valueFormatting = this.valueFormatting || ((value2) => `${this.countPrefix}${value2.toLocaleString()}${this.countSuffix}`);
    const callback = ({
      value: value2,
      progress,
      finished
    }) => {
      this.value = valueFormatting(value2);
      this.cd.markForCheck();
      if (!finished) this.countChange.emit({
        value: this.value,
        progress
      });
      if (finished) this.countFinish.emit({
        value: this.value,
        progress
      });
    };
    this.animationReq = count2(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
  }
  static {
    this.\u0275fac = function CountUpDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CountUpDirective)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CountUpDirective,
      selectors: [["", "ngx-charts-count-up", ""]],
      inputs: {
        countDuration: "countDuration",
        countPrefix: "countPrefix",
        countSuffix: "countSuffix",
        valueFormatting: "valueFormatting",
        countDecimals: "countDecimals",
        countTo: "countTo",
        countFrom: "countFrom"
      },
      outputs: {
        countChange: "countChange",
        countFinish: "countFinish"
      },
      standalone: false,
      attrs: _c17,
      decls: 1,
      vars: 1,
      template: function CountUpDirective_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275text(0);
        }
        if (rf & 2) {
          \u0275\u0275textInterpolate1(" ", ctx.value, " ");
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CountUpDirective, [{
    type: Component,
    args: [{
      selector: "[ngx-charts-count-up]",
      template: ` {{ value }} `
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    countDuration: [{
      type: Input
    }],
    countPrefix: [{
      type: Input
    }],
    countSuffix: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    countDecimals: [{
      type: Input
    }],
    countTo: [{
      type: Input
    }],
    countFrom: [{
      type: Input
    }],
    countChange: [{
      type: Output
    }],
    countFinish: [{
      type: Output
    }]
  });
})();
var root;
if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
}
var MouseEvent = root.MouseEvent;
function createMouseEvent(name, bubbles = false, cancelable = true) {
  if (typeof MouseEvent === "function") {
    return new MouseEvent(name, {
      bubbles,
      cancelable
    });
  } else {
    const event = document.createEvent("MouseEvent");
    event.initEvent(name, bubbles, cancelable);
    return event;
  }
}
var TooltipArea = class _TooltipArea {
  constructor(platformId) {
    this.platformId = platformId;
    this.anchorOpacity = 0;
    this.anchorPos = -1;
    this.anchorValues = [];
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.showPercentage = false;
    this.tooltipDisabled = false;
    this.hover = new EventEmitter();
  }
  getValues(xVal) {
    const results = [];
    for (const group of this.results) {
      const item = group.series.find((d) => d.name.toString() === xVal.toString());
      let groupName = group.name;
      if (groupName instanceof Date) {
        groupName = groupName.toLocaleDateString();
      }
      if (item) {
        const label = item.name;
        let val = item.value;
        if (this.showPercentage) {
          val = (item.d1 - item.d0).toFixed(2) + "%";
        }
        let color2;
        if (this.colors.scaleType === ScaleType.Linear) {
          let v = val;
          if (item.d1) {
            v = item.d1;
          }
          color2 = this.colors.getColor(v);
        } else {
          color2 = this.colors.getColor(group.name);
        }
        const data = Object.assign({}, item, {
          value: val,
          name: label,
          series: groupName,
          min: item.min,
          max: item.max,
          color: color2
        });
        results.push(data);
      }
    }
    return results;
  }
  mouseMove(event) {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const xPos = event.pageX - event.target.getBoundingClientRect().left;
    const closestIndex = this.findClosestPointIndex(xPos);
    const closestPoint = this.xSet[closestIndex];
    this.anchorPos = this.xScale(closestPoint);
    this.anchorPos = Math.max(0, this.anchorPos);
    this.anchorPos = Math.min(this.dims.width, this.anchorPos);
    this.anchorValues = this.getValues(closestPoint);
    if (this.anchorPos !== this.lastAnchorPos) {
      const ev = createMouseEvent("mouseleave");
      this.tooltipAnchor.nativeElement.dispatchEvent(ev);
      this.anchorOpacity = 0.7;
      this.hover.emit({
        value: closestPoint
      });
      this.showTooltip();
      this.lastAnchorPos = this.anchorPos;
    }
  }
  findClosestPointIndex(xPos) {
    let minIndex = 0;
    let maxIndex = this.xSet.length - 1;
    let minDiff = Number.MAX_VALUE;
    let closestIndex = 0;
    while (minIndex <= maxIndex) {
      const currentIndex = (minIndex + maxIndex) / 2 | 0;
      const currentElement = this.xScale(this.xSet[currentIndex]);
      const curDiff = Math.abs(currentElement - xPos);
      if (curDiff < minDiff) {
        minDiff = curDiff;
        closestIndex = currentIndex;
      }
      if (currentElement < xPos) {
        minIndex = currentIndex + 1;
      } else if (currentElement > xPos) {
        maxIndex = currentIndex - 1;
      } else {
        minDiff = 0;
        closestIndex = currentIndex;
        break;
      }
    }
    return closestIndex;
  }
  showTooltip() {
    const event = createMouseEvent("mouseenter");
    this.tooltipAnchor.nativeElement.dispatchEvent(event);
  }
  hideTooltip() {
    const event = createMouseEvent("mouseleave");
    this.tooltipAnchor.nativeElement.dispatchEvent(event);
    this.anchorOpacity = 0;
    this.lastAnchorPos = -1;
  }
  getToolTipText(tooltipItem) {
    let result = "";
    if (tooltipItem.series !== void 0) {
      result += tooltipItem.series;
    } else {
      result += "???";
    }
    result += ": ";
    if (tooltipItem.value !== void 0) {
      result += tooltipItem.value.toLocaleString();
    }
    if (tooltipItem.min !== void 0 || tooltipItem.max !== void 0) {
      result += " (";
      if (tooltipItem.min !== void 0) {
        if (tooltipItem.max === void 0) {
          result += "\u2265";
        }
        result += tooltipItem.min.toLocaleString();
        if (tooltipItem.max !== void 0) {
          result += " - ";
        }
      } else if (tooltipItem.max !== void 0) {
        result += "\u2264";
      }
      if (tooltipItem.max !== void 0) {
        result += tooltipItem.max.toLocaleString();
      }
      result += ")";
    }
    return result;
  }
  static {
    this.\u0275fac = function TooltipArea_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TooltipArea)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TooltipArea,
      selectors: [["g", "ngx-charts-tooltip-area", ""]],
      viewQuery: function TooltipArea_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c18, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipAnchor = _t.first);
        }
      },
      inputs: {
        dims: "dims",
        xSet: "xSet",
        xScale: "xScale",
        yScale: "yScale",
        results: "results",
        colors: "colors",
        showPercentage: "showPercentage",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate"
      },
      outputs: {
        hover: "hover"
      },
      standalone: false,
      attrs: _c19,
      decls: 6,
      vars: 18,
      consts: [["defaultTooltipTemplate", ""], ["tooltipAnchor", ""], ["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "'auto'", 3, "mousemove", "mouseleave"], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]],
      template: function TooltipArea_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g")(1, "rect", 2);
          \u0275\u0275listener("mousemove", function TooltipArea_Template_rect_mousemove_1_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.mouseMove($event));
          })("mouseleave", function TooltipArea_Template_rect_mouseleave_1_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.hideTooltip());
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(2, TooltipArea__svg_ng_template_2_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
          \u0275\u0275element(4, "rect", 3, 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          const defaultTooltipTemplate_r5 = \u0275\u0275reference(3);
          \u0275\u0275advance();
          \u0275\u0275attribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
          \u0275\u0275advance(3);
          \u0275\u0275styleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
          \u0275\u0275property("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.placementTypes.Right)("tooltipType", ctx.styleTypes.tooltip)("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : defaultTooltipTemplate_r5)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
          \u0275\u0275attribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
        }
      },
      dependencies: [NgForOf, TooltipDirective],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition("inactive => active", [style({
          opacity: 0
        }), animate(250, style({
          opacity: 0.7
        }))]), transition("active => inactive", [style({
          opacity: 0.7
        }), animate(250, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipArea, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tooltip-area]",
      template: `
    <svg:g>
      <svg:rect
        class="tooltip-area"
        [attr.x]="0"
        y="0"
        [attr.width]="dims.width"
        [attr.height]="dims.height"
        style="opacity: 0; cursor: 'auto';"
        (mousemove)="mouseMove($event)"
        (mouseleave)="hideTooltip()"
      />
      <ng-template #defaultTooltipTemplate let-model="model">
        <xhtml:div class="area-tooltip-container">
          <xhtml:div *ngFor="let tooltipItem of model" class="tooltip-item">
            <xhtml:span class="tooltip-item-color" [style.background-color]="tooltipItem.color"></xhtml:span>
            {{ getToolTipText(tooltipItem) }}
          </xhtml:div>
        </xhtml:div>
      </ng-template>
      <svg:rect
        #tooltipAnchor
        [@animationState]="anchorOpacity !== 0 ? 'active' : 'inactive'"
        class="tooltip-anchor"
        [attr.x]="anchorPos"
        y="0"
        [attr.width]="1"
        [attr.height]="dims.height"
        [style.opacity]="anchorOpacity"
        [style.pointer-events]="'none'"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Right"
        [tooltipType]="styleTypes.tooltip"
        [tooltipSpacing]="15"
        [tooltipTemplate]="tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate"
        [tooltipContext]="anchorValues"
        [tooltipImmediateExit]="true"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition("inactive => active", [style({
        opacity: 0
      }), animate(250, style({
        opacity: 0.7
      }))]), transition("active => inactive", [style({
        opacity: 0.7
      }), animate(250, style({
        opacity: 0
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    dims: [{
      type: Input
    }],
    xSet: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    showPercentage: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    hover: [{
      type: Output
    }],
    tooltipAnchor: [{
      type: ViewChild,
      args: ["tooltipAnchor", {
        static: false
      }]
    }]
  });
})();
var Timeline = class _Timeline {
  constructor(element, cd) {
    this.cd = cd;
    this.height = 50;
    this.select = new EventEmitter();
    this.onDomainChange = new EventEmitter();
    this.initialized = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
    if (!this.initialized) {
      this.addBrush();
      this.initialized = true;
    }
  }
  update() {
    this.dims = this.getDims();
    this.height = this.dims.height;
    const offsetY = this.view[1] - this.height;
    this.xDomain = this.getXDomain();
    this.xScale = this.getXScale();
    if (this.brush) {
      this.updateBrush();
    }
    this.transform = `translate(0 , ${offsetY})`;
    this.filterId = "filter" + id().toString();
    this.filter = `url(#${this.filterId})`;
    this.cd.markForCheck();
  }
  getXDomain() {
    let values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.name)) {
          values.push(d.name);
        }
      }
    }
    let domain = [];
    if (this.scaleType === ScaleType.Time) {
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      domain = [min4, max4];
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      domain = [min4, max4];
    } else {
      domain = values;
    }
    return domain;
  }
  getXScale() {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time().range([0, this.dims.width]).domain(this.xDomain);
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear().range([0, this.dims.width]).domain(this.xDomain);
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().range([0, this.dims.width]).padding(0.1).domain(this.xDomain);
    }
    return scale;
  }
  addBrush() {
    if (this.brush) return;
    const height = this.height;
    const width = this.view[0];
    this.brush = brushX().extent([[0, 0], [width, height]]).on("brush end", ({
      selection
    }) => {
      const newSelection = selection || this.xScale.range();
      const newDomain = newSelection.map(this.xScale.invert);
      this.onDomainChange.emit(newDomain);
      this.cd.markForCheck();
    });
    select_default(this.element).select(".brush").call(this.brush);
  }
  updateBrush() {
    if (!this.brush) return;
    const height = this.height;
    const width = this.view[0];
    this.brush.extent([[0, 0], [width, height]]);
    select_default(this.element).select(".brush").call(this.brush);
    select_default(this.element).select(".selection").attr("fill", void 0).attr("stroke", void 0).attr("fill-opacity", void 0);
    this.cd.markForCheck();
  }
  getDims() {
    const width = this.view[0];
    const dims = {
      width,
      height: this.height
    };
    return dims;
  }
  static {
    this.\u0275fac = function Timeline_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Timeline)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _Timeline,
      selectors: [["g", "ngx-charts-timeline", ""]],
      inputs: {
        view: "view",
        results: "results",
        scheme: "scheme",
        customColors: "customColors",
        legend: "legend",
        autoScale: "autoScale",
        scaleType: "scaleType",
        height: "height"
      },
      outputs: {
        select: "select",
        onDomainChange: "onDomainChange"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c20,
      ngContentSelectors: _c2,
      decls: 7,
      vars: 4,
      consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]],
      template: function Timeline_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0)(1, "filter");
          \u0275\u0275element(2, "feColorMatrix", 1);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(3, "g", 2);
          \u0275\u0275projection(4);
          \u0275\u0275elementEnd();
          \u0275\u0275element(5, "rect", 3)(6, "g", 4);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275attribute("id", ctx.filterId);
          \u0275\u0275advance(4);
          \u0275\u0275attribute("width", ctx.view[0])("height", ctx.height);
        }
      },
      styles: [".timeline .brush-background{fill:#0000000d}.timeline .brush .selection{fill:#0000001a;stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Timeline, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-timeline]",
      template: `
    <svg:g class="timeline" [attr.transform]="transform">
      <svg:filter [attr.id]="filterId">
        <svg:feColorMatrix
          in="SourceGraphic"
          type="matrix"
          values="0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
        />
      </svg:filter>
      <svg:g class="embedded-chart">
        <ng-content></ng-content>
      </svg:g>
      <svg:rect x="0" [attr.width]="view[0]" y="0" [attr.height]="height" class="brush-background" />
      <svg:g class="brush"></svg:g>
    </svg:g>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".timeline .brush-background{fill:#0000000d}.timeline .brush .selection{fill:#0000001a;stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    view: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    scheme: [{
      type: Input
    }],
    customColors: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    onDomainChange: [{
      type: Output
    }]
  });
})();
var AdvancedLegendComponent = class _AdvancedLegendComponent {
  constructor() {
    this.label = "Total";
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.legendItems = [];
    this.labelFormatting = (label) => label;
    this.percentageFormatting = (percentage) => percentage;
    this.defaultValueFormatting = (value2) => value2.toLocaleString();
  }
  ngOnChanges(changes) {
    this.update();
  }
  getTotal() {
    return this.data.map((d) => Number(d.value)).reduce((sum2, d) => sum2 + d, 0);
  }
  update() {
    this.total = this.getTotal();
    this.roundedTotal = this.total;
    this.legendItems = this.getLegendItems();
  }
  getLegendItems() {
    return this.data.map((d) => {
      const label = formatLabel(d.name);
      const value2 = d.value;
      const color2 = this.colors.getColor(label);
      const percentage = this.total > 0 ? value2 / this.total * 100 : 0;
      const formattedLabel = typeof this.labelFormatting === "function" ? this.labelFormatting(label) : label;
      return {
        _value: value2,
        data: d,
        value: value2,
        color: color2,
        label: formattedLabel,
        displayLabel: trimLabel(formattedLabel, 20),
        origialLabel: d.name,
        percentage: this.percentageFormatting ? this.percentageFormatting(percentage) : percentage.toLocaleString()
      };
    });
  }
  trackBy(index, item) {
    return item.label;
  }
  static {
    this.\u0275fac = function AdvancedLegendComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AdvancedLegendComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AdvancedLegendComponent,
      selectors: [["ngx-charts-advanced-legend"]],
      inputs: {
        width: "width",
        data: "data",
        colors: "colors",
        label: "label",
        animations: "animations",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        percentageFormatting: "percentageFormatting"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 8,
      vars: 7,
      consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]],
      template: function AdvancedLegendComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275template(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1)(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
          \u0275\u0275elementStart(3, "div", 3);
          \u0275\u0275text(4);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(5, "div", 4)(6, "div", 5);
          \u0275\u0275template(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.width, "px");
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate1(" ", ctx.label, " ");
          \u0275\u0275advance(3);
          \u0275\u0275property("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, NgIf, CountUpDirective],
      styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdvancedLegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-advanced-legend",
      template: `
    <div class="advanced-pie-legend" [style.width.px]="width">
      <div
        *ngIf="animations"
        class="total-value"
        ngx-charts-count-up
        [countTo]="roundedTotal"
        [valueFormatting]="valueFormatting"
      ></div>
      <div class="total-value" *ngIf="!animations">
        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}
      </div>
      <div class="total-label">
        {{ label }}
      </div>
      <div class="legend-items-container">
        <div class="legend-items">
          <div
            *ngFor="let legendItem of legendItems; trackBy: trackBy"
            tabindex="-1"
            class="legend-item"
            (mouseenter)="activate.emit(legendItem.data)"
            (mouseleave)="deactivate.emit(legendItem.data)"
            (click)="select.emit(legendItem.data)"
          >
            <div class="item-color" [style.border-left-color]="legendItem.color"></div>
            <div
              *ngIf="animations"
              class="item-value"
              ngx-charts-count-up
              [countTo]="legendItem._value"
              [valueFormatting]="valueFormatting"
            ></div>
            <div *ngIf="!animations" class="item-value">
              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}
            </div>
            <div class="item-label">{{ legendItem.displayLabel }}</div>
            <div
              *ngIf="animations"
              class="item-percent"
              ngx-charts-count-up
              [countTo]="legendItem.percentage"
              [countSuffix]="'%'"
            ></div>
            <div *ngIf="!animations" class="item-percent">{{ legendItem.percentage.toLocaleString() }}%</div>
          </div>
        </div>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}\n"]
    }]
  }], null, {
    width: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    percentageFormatting: [{
      type: Input
    }]
  });
})();
var COMPONENTS = [AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent];
var ChartCommonModule = class _ChartCommonModule {
  static {
    this.\u0275fac = function ChartCommonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChartCommonModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ChartCommonModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, AxesModule, TooltipModule, CommonModule, AxesModule, TooltipModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartCommonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, AxesModule, TooltipModule],
      declarations: [...COMPONENTS, VisibilityObserver],
      exports: [CommonModule, AxesModule, TooltipModule, ...COMPONENTS, VisibilityObserver]
    }]
  }], null, null);
})();
function calculateViewDimensions({
  width,
  height,
  margins,
  showXAxis = false,
  showYAxis = false,
  xAxisHeight = 0,
  yAxisWidth = 0,
  showXLabel = false,
  showYLabel = false,
  showLegend = false,
  legendType = ScaleType.Ordinal,
  legendPosition = LegendPosition.Right,
  columns = 12
}) {
  let xOffset = margins[3];
  let chartWidth = width;
  let chartHeight = height - margins[0] - margins[2];
  if (showLegend && legendPosition === LegendPosition.Right) {
    if (legendType === ScaleType.Ordinal) {
      columns -= 2;
    } else {
      columns -= 1;
    }
  }
  chartWidth = chartWidth * columns / 12;
  chartWidth = chartWidth - margins[1] - margins[3];
  if (showXAxis) {
    chartHeight -= 5;
    chartHeight -= xAxisHeight;
    if (showXLabel) {
      const offset = 25 + 5;
      chartHeight -= offset;
    }
  }
  if (showYAxis) {
    chartWidth -= 5;
    chartWidth -= yAxisWidth;
    xOffset += yAxisWidth;
    xOffset += 10;
    if (showYLabel) {
      const offset = 25 + 5;
      chartWidth -= offset;
      xOffset += offset;
    }
  }
  chartWidth = Math.max(0, chartWidth);
  chartHeight = Math.max(0, chartHeight);
  return {
    width: Math.floor(chartWidth),
    height: Math.floor(chartHeight),
    xOffset: Math.floor(xOffset)
  };
}
var colorSets = [{
  name: "vivid",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#647c8a", "#3f51b5", "#2196f3", "#00b862", "#afdf0a", "#a7b61a", "#f3e562", "#ff9800", "#ff5722", "#ff4514"]
}, {
  name: "natural",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#bf9d76", "#e99450", "#d89f59", "#f2dfa7", "#a5d7c6", "#7794b1", "#afafaf", "#707160", "#ba9383", "#d9d5c3"]
}, {
  name: "cool",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#a8385d", "#7aa3e5", "#a27ea8", "#aae3f5", "#adcded", "#a95963", "#8796c0", "#7ed3ed", "#50abcc", "#ad6886"]
}, {
  name: "fire",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#ff3d00", "#bf360c", "#ff8f00", "#ff6f00", "#ff5722", "#e65100", "#ffca28", "#ffab00"]
}, {
  name: "solar",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#fff8e1", "#ffecb3", "#ffe082", "#ffd54f", "#ffca28", "#ffc107", "#ffb300", "#ffa000", "#ff8f00", "#ff6f00"]
}, {
  name: "air",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#e1f5fe", "#b3e5fc", "#81d4fa", "#4fc3f7", "#29b6f6", "#03a9f4", "#039be5", "#0288d1", "#0277bd", "#01579b"]
}, {
  name: "aqua",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#e0f7fa", "#b2ebf2", "#80deea", "#4dd0e1", "#26c6da", "#00bcd4", "#00acc1", "#0097a7", "#00838f", "#006064"]
}, {
  name: "flame",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#A10A28", "#D3342D", "#EF6D49", "#FAAD67", "#FDDE90", "#DBED91", "#A9D770", "#6CBA67", "#2C9653", "#146738"]
}, {
  name: "ocean",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#1D68FB", "#33C0FC", "#4AFFFE", "#AFFFFF", "#FFFC63", "#FDBD2D", "#FC8A25", "#FA4F1E", "#FA141B", "#BA38D1"]
}, {
  name: "forest",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#55C22D", "#C1F33D", "#3CC099", "#AFFFFF", "#8CFC9D", "#76CFFA", "#BA60FB", "#EE6490", "#C42A1C", "#FC9F32"]
}, {
  name: "horizon",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#2597FB", "#65EBFD", "#99FDD0", "#FCEE4B", "#FEFCFA", "#FDD6E3", "#FCB1A8", "#EF6F7B", "#CB96E8", "#EFDEE0"]
}, {
  name: "neons",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#FF3333", "#FF33FF", "#CC33FF", "#0000FF", "#33CCFF", "#33FFFF", "#33FF66", "#CCFF33", "#FFCC00", "#FF6600"]
}, {
  name: "picnic",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#FAC51D", "#66BD6D", "#FAA026", "#29BB9C", "#E96B56", "#55ACD2", "#B7332F", "#2C83C9", "#9166B8", "#92E7E8"]
}, {
  name: "night",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#2B1B5A", "#501356", "#183356", "#28203F", "#391B3C", "#1E2B3C", "#120634", "#2D0432", "#051932", "#453080", "#75267D", "#2C507D", "#4B3880", "#752F7D", "#35547D"]
}, {
  name: "nightLights",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#4e31a5", "#9c25a7", "#3065ab", "#57468b", "#904497", "#46648b", "#32118d", "#a00fb3", "#1052a2", "#6e51bd", "#b63cc3", "#6c97cb", "#8671c1", "#b455be", "#7496c3"]
}];
var ColorHelper = class {
  constructor(scheme, type2, domain, customColors) {
    if (typeof scheme === "string") {
      scheme = colorSets.find((cs) => {
        return cs.name === scheme;
      });
    }
    this.colorDomain = scheme.domain;
    this.scaleType = type2;
    this.domain = domain;
    this.customColors = customColors;
    this.scale = this.generateColorScheme(scheme, type2, this.domain);
  }
  generateColorScheme(scheme, type2, domain) {
    if (typeof scheme === "string") {
      scheme = colorSets.find((cs) => {
        return cs.name === scheme;
      });
    }
    let colorScale;
    switch (type2) {
      case ScaleType.Quantile:
        colorScale = quantile2().range(scheme.domain).domain(domain);
        break;
      case ScaleType.Ordinal:
        colorScale = ordinal().range(scheme.domain).domain(domain);
        break;
      case ScaleType.Linear:
        {
          const colorDomain = [...scheme.domain];
          if (colorDomain.length === 1) {
            colorDomain.push(colorDomain[0]);
            this.colorDomain = colorDomain;
          }
          const points = range(0, 1, 1 / colorDomain.length);
          colorScale = linear().range(colorDomain).domain(points);
        }
        break;
      default:
        break;
    }
    return colorScale;
  }
  getColor(value2) {
    if (value2 === void 0 || value2 === null) {
      throw new Error("Value can not be null");
    }
    if (this.scaleType === ScaleType.Linear) {
      const valueScale = linear().domain(this.domain).range([0, 1]);
      return this.scale(valueScale(value2));
    } else {
      if (typeof this.customColors === "function") {
        return this.customColors(value2);
      }
      const formattedValue = value2.toString();
      let found;
      if (this.customColors && this.customColors.length > 0) {
        found = this.customColors.find((mapping) => {
          return mapping.name.toLowerCase() === formattedValue.toLowerCase();
        });
      }
      if (found) {
        return found.value;
      } else {
        return this.scale(value2);
      }
    }
  }
  getLinearGradientStops(value2, start) {
    if (start === void 0) {
      start = this.domain[0];
    }
    const valueScale = linear().domain(this.domain).range([0, 1]);
    const colorValueScale = band().domain(this.colorDomain).range([0, 1]);
    const endColor = this.getColor(value2);
    const startVal = valueScale(start);
    const startColor = this.getColor(start);
    const endVal = valueScale(value2);
    let i = 1;
    let currentVal = startVal;
    const stops = [];
    stops.push({
      color: startColor,
      offset: startVal,
      originalOffset: startVal,
      opacity: 1
    });
    while (currentVal < endVal && i < this.colorDomain.length) {
      const color2 = this.colorDomain[i];
      const offset = colorValueScale(color2);
      if (offset <= startVal) {
        i++;
        continue;
      }
      if (offset.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
        break;
      }
      stops.push({
        color: color2,
        offset,
        opacity: 1
      });
      currentVal = offset;
      i++;
    }
    if (stops[stops.length - 1].offset < 100) {
      stops.push({
        color: endColor,
        offset: endVal,
        opacity: 1
      });
    }
    if (endVal === startVal) {
      stops[0].offset = 0;
      stops[1].offset = 100;
    } else {
      if (stops[stops.length - 1].offset !== 100) {
        for (const s of stops) {
          s.offset = (s.offset - startVal) / (endVal - startVal) * 100;
        }
      }
    }
    return stops;
  }
};
function getUniqueXDomainValues(results) {
  const valueSet = /* @__PURE__ */ new Set();
  for (const result of results) {
    for (const d of result.series) {
      valueSet.add(d.name);
    }
  }
  return Array.from(valueSet);
}
function getScaleType(values, checkDateType = true) {
  if (checkDateType) {
    const allDates = values.every((value2) => value2 instanceof Date);
    if (allDates) {
      return ScaleType.Time;
    }
  }
  const allNumbers = values.every((value2) => typeof value2 === "number");
  if (allNumbers) {
    return ScaleType.Linear;
  }
  return ScaleType.Ordinal;
}
function sortLinear(data, property, direction = "asc") {
  return data.sort((a, b) => {
    if (direction === "asc") {
      return a[property] - b[property];
    } else {
      return b[property] - a[property];
    }
  });
}
function sortByDomain(data, property, direction = "asc", domain) {
  return data.sort((a, b) => {
    const aVal = a[property];
    const bVal = b[property];
    const aIdx = domain.indexOf(aVal);
    const bIdx = domain.indexOf(bVal);
    if (direction === "asc") {
      return aIdx - bIdx;
    } else {
      return bIdx - aIdx;
    }
  });
}
function sortByTime(data, property, direction = "asc") {
  return data.sort((a, b) => {
    const aDate = a[property].getTime();
    const bDate = b[property].getTime();
    if (direction === "asc") {
      if (aDate > bDate) return 1;
      if (bDate > aDate) return -1;
      return 0;
    } else {
      if (aDate > bDate) return -1;
      if (bDate > aDate) return 1;
      return 0;
    }
  });
}
var AreaSeriesComponent = class _AreaSeriesComponent {
  constructor() {
    this.baseValue = "auto";
    this.stacked = false;
    this.normalized = false;
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradient();
    let currentArea;
    let startingArea;
    const xProperty = (d) => {
      const label = d.name;
      return this.xScale(label);
    };
    if (this.stacked || this.normalized) {
      currentArea = area_default().x(xProperty).y0((d, i) => this.yScale(d.d0)).y1((d, i) => this.yScale(d.d1));
      startingArea = area_default().x(xProperty).y0((d) => this.yScale.range()[0]).y1((d) => this.yScale.range()[0]);
    } else {
      currentArea = area_default().x(xProperty).y0(() => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue)).y1((d) => this.yScale(d.value));
      startingArea = area_default().x(xProperty).y0((d) => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue)).y1((d) => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue));
    }
    currentArea.curve(this.curve);
    startingArea.curve(this.curve);
    this.opacity = 0.8;
    let data = this.data.series;
    if (this.scaleType === ScaleType.Linear) {
      data = sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      data = sortByTime(data, "name");
    } else {
      data = sortByDomain(data, "name", "asc", this.xScale.domain());
    }
    this.path = currentArea(data);
    this.startingPath = startingArea(data);
  }
  updateGradient() {
    if (this.colors.scaleType === ScaleType.Linear) {
      this.hasGradient = true;
      if (this.stacked || this.normalized) {
        const d0values = this.data.series.map((d) => d.d0);
        const d1values = this.data.series.map((d) => d.d1);
        const max4 = Math.max(...d1values);
        const min4 = Math.min(...d0values);
        this.gradientStops = this.colors.getLinearGradientStops(max4, min4);
      } else {
        const values = this.data.series.map((d) => d.value);
        const max4 = Math.max(...values);
        this.gradientStops = this.colors.getLinearGradientStops(max4);
      }
    } else {
      this.hasGradient = false;
      this.gradientStops = void 0;
    }
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
  static {
    this.\u0275fac = function AreaSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AreaSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AreaSeriesComponent,
      selectors: [["g", "ngx-charts-area-series", ""]],
      inputs: {
        data: "data",
        xScale: "xScale",
        yScale: "yScale",
        baseValue: "baseValue",
        colors: "colors",
        scaleType: "scaleType",
        stacked: "stacked",
        normalized: "normalized",
        gradient: "gradient",
        curve: "curve",
        activeEntries: "activeEntries",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c21,
      decls: 1,
      vars: 12,
      consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]],
      template: function AreaSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275element(0, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
          \u0275\u0275property("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
        }
      },
      dependencies: [AreaComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-area-series]",
      template: `
    <svg:g
      ngx-charts-area
      class="area-series"
      [data]="data"
      [path]="path"
      [fill]="colors.getColor(data.name)"
      [stops]="gradientStops"
      [startingPath]="startingPath"
      [opacity]="opacity"
      [gradient]="gradient || hasGradient"
      [animations]="animations"
      [class.active]="isActive(data)"
      [class.inactive]="isInactive(data)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    baseValue: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    stacked: [{
      type: Input
    }],
    normalized: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var AreaChartComponent = class _AreaChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = false;
    this.yAxis = false;
    this.baseValue = "auto";
    this.autoScale = false;
    this.timeline = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset}, ${this.margin[0]})`;
    this.clipPathId = "clip" + id().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min4;
    let max4;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min4 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max4 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min4), new Date(max4)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min4, max4];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const values = [...domain];
    if (!this.autoScale) {
      values.push(0);
    }
    if (this.baseValue !== "auto") {
      values.push(this.baseValue);
    }
    const min4 = this.yScaleMin ? this.yScaleMin : Math.min(...values);
    const max4 = this.yScaleMax ? this.yScaleMax : Math.max(...values);
    return [min4, max4];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getScaleType(values) {
    let date = true;
    let num = true;
    for (const value2 of values) {
      if (isDate(value2)) {
        date = false;
      }
      if (isNumber(value2)) {
        num = false;
      }
    }
    if (date) {
      return ScaleType.Time;
    }
    if (num) {
      return ScaleType.Linear;
    }
    return ScaleType.Ordinal;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275AreaChartComponent_BaseFactory;
      return function AreaChartComponent_Factory(__ngFactoryType__) {
        return (\u0275AreaChartComponent_BaseFactory || (\u0275AreaChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartComponent)))(__ngFactoryType__ || _AreaChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AreaChartComponent,
      selectors: [["ngx-charts-area-chart"]],
      contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
          \u0275\u0275contentQuery(dirIndex, _c23, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
        }
      },
      hostBindings: function AreaChartComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() {
            return ctx.hideCircles();
          });
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        baseValue: "baseValue",
        autoScale: "autoScale",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        timeline: "timeline",
        gradient: "gradient",
        showGridLines: "showGridLines",
        curve: "curve",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        roundDomains: "roundDomains",
        tooltipDisabled: "tooltipDisabled",
        xScaleMin: "xScaleMin",
        xScaleMax: "xScaleMax",
        yScaleMin: "yScaleMin",
        yScaleMax: "yScaleMax",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 11,
      vars: 20,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]],
      template: function AreaChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "defs")(2, "clipPath");
          \u0275\u0275element(3, "rect");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g", 1);
          \u0275\u0275template(5, AreaChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartComponent__svg_g_6_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(7, "g");
          \u0275\u0275template(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
          \u0275\u0275elementEnd()();
          \u0275\u0275template(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("id", ctx.clipPathId);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275attribute("clip-path", ctx.clipPath);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [baseValue]="baseValue"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [gradient]="gradient"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [baseValue]="baseValue"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    baseValue: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var AreaChartNormalizedComponent = class _AreaChartNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showXAxisLabel = false;
    this.showYAxisLabel = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.yDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.seriesType = SeriesType;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let d0 = 0;
      let total = 0;
      for (const group of this.results) {
        const d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          total += d.value;
        }
      }
      for (const group of this.results) {
        let d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          d.d0 = d0;
          d.d1 = d0 + d.value;
          d0 += d.value;
        } else {
          d = {
            name: val,
            value: 0,
            d0,
            d1: d0
          };
          group.series.push(d);
        }
        if (total > 0) {
          d.d0 = d.d0 * 100 / total;
          d.d1 = d.d1 * 100 / total;
        } else {
          d.d0 = 0;
          d.d1 = 0;
        }
      }
    }
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Time) {
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      domain = [new Date(min4), new Date(max4)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      domain = [min4, max4];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275AreaChartNormalizedComponent_BaseFactory;
      return function AreaChartNormalizedComponent_Factory(__ngFactoryType__) {
        return (\u0275AreaChartNormalizedComponent_BaseFactory || (\u0275AreaChartNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartNormalizedComponent)))(__ngFactoryType__ || _AreaChartNormalizedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AreaChartNormalizedComponent,
      selectors: [["ngx-charts-area-chart-normalized"]],
      contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
          \u0275\u0275contentQuery(dirIndex, _c23, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
        }
      },
      hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() {
            return ctx.hideCircles();
          });
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        timeline: "timeline",
        gradient: "gradient",
        showGridLines: "showGridLines",
        curve: "curve",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        roundDomains: "roundDomains",
        tooltipDisabled: "tooltipDisabled",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 11,
      vars: 20,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "normalized", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "normalized", "curve", "animations"]],
      template: function AreaChartNormalizedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "defs")(2, "clipPath");
          \u0275\u0275element(3, "rect");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g", 1);
          \u0275\u0275template(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(7, "g");
          \u0275\u0275template(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
          \u0275\u0275elementEnd()();
          \u0275\u0275template(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("id", ctx.clipPathId);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275attribute("clip-path", ctx.clipPath);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [scaleType]="scaleType"
              [activeEntries]="activeEntries"
              [gradient]="gradient"
              [normalized]="true"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [showPercentage]="true"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [type]="seriesType.Stacked"
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [normalized]="true"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var AreaChartStackedComponent = class _AreaChartStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = false;
    this.yAxis = false;
    this.timeline = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.seriesType = SeriesType;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let d0 = 0;
      for (const group of this.results) {
        let d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          d.d0 = d0;
          d.d1 = d0 + d.value;
          d0 += d.value;
        } else {
          d = {
            name: val,
            value: 0,
            d0,
            d1: d0
          };
          group.series.push(d);
        }
      }
    }
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min4;
    let max4;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min4 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max4 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min4), new Date(max4)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min4, max4];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let sum2 = 0;
      for (const group of this.results) {
        const d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          sum2 += d.value;
        }
      }
      domain.push(sum2);
    }
    const min4 = this.yScaleMin ? this.yScaleMin : Math.min(0, ...domain);
    const max4 = this.yScaleMax ? this.yScaleMax : Math.max(...domain);
    return [min4, max4];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275AreaChartStackedComponent_BaseFactory;
      return function AreaChartStackedComponent_Factory(__ngFactoryType__) {
        return (\u0275AreaChartStackedComponent_BaseFactory || (\u0275AreaChartStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartStackedComponent)))(__ngFactoryType__ || _AreaChartStackedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AreaChartStackedComponent,
      selectors: [["ngx-charts-area-chart-stacked"]],
      contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
          \u0275\u0275contentQuery(dirIndex, _c23, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
        }
      },
      hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() {
            return ctx.hideCircles();
          });
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        timeline: "timeline",
        gradient: "gradient",
        showGridLines: "showGridLines",
        curve: "curve",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        roundDomains: "roundDomains",
        tooltipDisabled: "tooltipDisabled",
        xScaleMin: "xScaleMin",
        xScaleMax: "xScaleMax",
        yScaleMin: "yScaleMin",
        yScaleMax: "yScaleMax",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 11,
      vars: 20,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "stacked", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "stacked", "curve", "animations"]],
      template: function AreaChartStackedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "defs")(2, "clipPath");
          \u0275\u0275element(3, "rect");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g", 1);
          \u0275\u0275template(5, AreaChartStackedComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartStackedComponent__svg_g_6_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(7, "g");
          \u0275\u0275template(8, AreaChartStackedComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
          \u0275\u0275elementEnd()();
          \u0275\u0275template(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("id", ctx.clipPathId);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275attribute("clip-path", ctx.clipPath);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [scaleType]="scaleType"
              [gradient]="gradient"
              [activeEntries]="activeEntries"
              [stacked]="true"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results; trackBy: trackBy">
              <svg:g
                ngx-charts-circle-series
                [type]="seriesType.Stacked"
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [stacked]="true"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var AreaChartModule = class _AreaChartModule {
  static {
    this.\u0275fac = function AreaChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AreaChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _AreaChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent],
      exports: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent]
    }]
  }], null, null);
})();
var BarComponent = class _BarComponent {
  constructor(element) {
    this.roundEdges = true;
    this.gradient = false;
    this.offset = 0;
    this.isActive = false;
    this.animations = true;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.hasGradient = false;
    this.hideBar = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    if (changes.roundEdges) {
      this.loadAnimation();
    }
    this.update();
  }
  update() {
    this.gradientId = "grad" + id().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient || this.stops) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updatePathEl();
    this.checkToHideBar();
  }
  loadAnimation() {
    this.path = this.getStartingPath();
    setTimeout(this.update.bind(this), 100);
  }
  updatePathEl() {
    const node = select_default(this.element).select(".bar");
    const path2 = this.getPath();
    if (this.animations) {
      node.transition().duration(500).attr("d", path2);
    } else {
      node.attr("d", path2);
    }
  }
  getGradient() {
    if (this.stops) {
      return this.stops;
    }
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.getStartOpacity()
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  getStartingPath() {
    if (!this.animations) {
      return this.getPath();
    }
    let radius = this.getRadius();
    let path2;
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        radius = Math.min(this.height, radius);
        path2 = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        radius = Math.min(this.width, radius);
        path2 = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
      }
    } else {
      if (this.orientation === BarOrientation.Vertical) {
        path2 = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        path2 = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
      }
    }
    return path2;
  }
  getPath() {
    let radius = this.getRadius();
    let path2;
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        radius = Math.min(this.height, radius);
        path2 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        radius = Math.min(this.width, radius);
        path2 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
      }
    } else {
      path2 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
    }
    return path2;
  }
  getRadius() {
    let radius = 0;
    if (this.roundEdges && this.height > 5 && this.width > 5) {
      radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
    }
    return radius;
  }
  getStartOpacity() {
    if (this.roundEdges) {
      return 0.2;
    } else {
      return 0.5;
    }
  }
  get edges() {
    let edges = [false, false, false, false];
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        if (this.data.value > 0) {
          edges = [true, true, false, false];
        } else {
          edges = [false, false, true, true];
        }
      } else if (this.orientation === BarOrientation.Horizontal) {
        if (this.data.value > 0) {
          edges = [false, true, false, true];
        } else {
          edges = [true, false, true, false];
        }
      }
    }
    return edges;
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  checkToHideBar() {
    this.hideBar = this.noBarWhenZero && (this.orientation === BarOrientation.Vertical && this.height === 0 || this.orientation === BarOrientation.Horizontal && this.width === 0);
  }
  static {
    this.\u0275fac = function BarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BarComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarComponent,
      selectors: [["g", "ngx-charts-bar", ""]],
      hostBindings: function BarComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() {
            return ctx.onMouseLeave();
          });
        }
      },
      inputs: {
        fill: "fill",
        data: "data",
        width: "width",
        height: "height",
        x: "x",
        y: "y",
        orientation: "orientation",
        roundEdges: "roundEdges",
        gradient: "gradient",
        offset: "offset",
        isActive: "isActive",
        stops: "stops",
        animations: "animations",
        ariaLabel: "ariaLabel",
        noBarWhenZero: "noBarWhenZero"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c26,
      decls: 2,
      vars: 8,
      consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
      template: function BarComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "path", 1);
          \u0275\u0275listener("click", function BarComponent_Template_path_click_1_listener() {
            return ctx.select.emit(ctx.data);
          });
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", ctx.hasGradient);
          \u0275\u0275advance();
          \u0275\u0275classProp("active", ctx.isActive)("hidden", ctx.hideBar);
          \u0275\u0275attribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
        }
      },
      dependencies: [NgIf, SvgLinearGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bar]",
      template: `
    <svg:defs *ngIf="hasGradient">
      <svg:g ngx-charts-svg-linear-gradient [orientation]="orientation" [name]="gradientId" [stops]="gradientStops" />
    </svg:defs>
    <svg:path
      class="bar"
      stroke="none"
      role="img"
      tabIndex="-1"
      [class.active]="isActive"
      [class.hidden]="hideBar"
      [attr.d]="path"
      [attr.aria-label]="ariaLabel"
      [attr.fill]="hasGradient ? gradientFill : fill"
      (click)="select.emit(data)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    stops: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var BarChartType;
(function(BarChartType2) {
  BarChartType2["Standard"] = "standard";
  BarChartType2["Normalized"] = "normalized";
  BarChartType2["Stacked"] = "stacked";
})(BarChartType || (BarChartType = {}));
var D0Types;
(function(D0Types2) {
  D0Types2["positive"] = "positive";
  D0Types2["negative"] = "negative";
})(D0Types || (D0Types = {}));
var BarLabelComponent = class _BarLabelComponent {
  constructor(element) {
    this.dimensionsChanged = new EventEmitter();
    this.horizontalPadding = 2;
    this.verticalPadding = 5;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  getSize() {
    const h = this.element.getBoundingClientRect().height;
    const w = this.element.getBoundingClientRect().width;
    return {
      height: h,
      width: w,
      negative: this.value < 0
    };
  }
  ngAfterViewInit() {
    this.dimensionsChanged.emit(this.getSize());
  }
  update() {
    if (this.valueFormatting) {
      this.formatedValue = this.valueFormatting(this.value);
    } else {
      this.formatedValue = formatLabel(this.value);
    }
    if (this.orientation === "horizontal") {
      this.x = this.barX + this.barWidth;
      if (this.value < 0) {
        this.x = this.x - this.horizontalPadding;
        this.textAnchor = "end";
      } else {
        this.x = this.x + this.horizontalPadding;
        this.textAnchor = "start";
      }
      this.y = this.barY + this.barHeight / 2;
    } else {
      this.x = this.barX + this.barWidth / 2;
      this.y = this.barY + this.barHeight;
      if (this.value < 0) {
        this.y = this.y + this.verticalPadding;
        this.textAnchor = "end";
      } else {
        this.y = this.y - this.verticalPadding;
        this.textAnchor = "start";
      }
      this.transform = `rotate(-45, ${this.x} , ${this.y})`;
    }
  }
  static {
    this.\u0275fac = function BarLabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BarLabelComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarLabelComponent,
      selectors: [["g", "ngx-charts-bar-label", ""]],
      inputs: {
        value: "value",
        valueFormatting: "valueFormatting",
        barX: "barX",
        barY: "barY",
        barWidth: "barWidth",
        barHeight: "barHeight",
        orientation: "orientation"
      },
      outputs: {
        dimensionsChanged: "dimensionsChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c27,
      decls: 2,
      vars: 5,
      consts: [["alignment-baseline", "middle", 1, "textDataLabel"]],
      template: function BarLabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "text", 0);
          \u0275\u0275text(1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.formatedValue, " ");
        }
      },
      styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bar-label]",
      template: `
    <svg:text
      class="textDataLabel"
      alignment-baseline="middle"
      [attr.text-anchor]="textAnchor"
      [attr.transform]="transform"
      [attr.x]="x"
      [attr.y]="y"
    >
      {{ formatedValue }}
    </svg:text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".textDataLabel{font-size:11px}\n"]
    }]
  }], () => [{
    type: ElementRef
  }], {
    value: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    barX: [{
      type: Input
    }],
    barY: [{
      type: Input
    }],
    barWidth: [{
      type: Input
    }],
    barHeight: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }]
  });
})();
var SeriesHorizontal = class _SeriesHorizontal {
  constructor() {
    this.type = BarChartType.Standard;
    this.tooltipDisabled = false;
    this.animations = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dataLabelWidthChanged = new EventEmitter();
    this.barsForDataLabels = [];
    this.barOrientation = BarOrientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateTooltipSettings();
    const d0 = {
      [D0Types.positive]: 0,
      [D0Types.negative]: 0
    };
    let d0Type;
    d0Type = D0Types.positive;
    let total;
    if (this.type === BarChartType.Normalized) {
      total = this.series.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
    }
    const xScaleMin = Math.max(this.xScale.domain()[0], 0);
    this.bars = this.series.map((d) => {
      let value2 = d.value;
      const label = this.getLabel(d);
      const formattedLabel = formatLabel(label);
      const roundEdges = this.roundEdges;
      d0Type = value2 > 0 ? D0Types.positive : D0Types.negative;
      const bar = {
        value: value2,
        label,
        roundEdges,
        data: d,
        formattedLabel
      };
      bar.height = this.yScale.bandwidth();
      if (this.type === BarChartType.Standard) {
        bar.width = Math.abs(this.xScale(value2) - this.xScale(xScaleMin));
        if (value2 < 0) {
          bar.x = this.xScale(value2);
        } else {
          bar.x = this.xScale(xScaleMin);
        }
        bar.y = this.yScale(label);
      } else if (this.type === BarChartType.Stacked) {
        const offset0 = d0[d0Type];
        const offset1 = offset0 + value2;
        d0[d0Type] += value2;
        bar.width = this.xScale(offset1) - this.xScale(offset0);
        bar.x = this.xScale(offset0);
        bar.y = 0;
        bar.offset0 = offset0;
        bar.offset1 = offset1;
      } else if (this.type === BarChartType.Normalized) {
        let offset0 = d0[d0Type];
        let offset1 = offset0 + value2;
        d0[d0Type] += value2;
        if (total > 0) {
          offset0 = offset0 * 100 / total;
          offset1 = offset1 * 100 / total;
        } else {
          offset0 = 0;
          offset1 = 0;
        }
        bar.width = this.xScale(offset1) - this.xScale(offset0);
        bar.x = this.xScale(offset0);
        bar.y = 0;
        bar.offset0 = offset0;
        bar.offset1 = offset1;
        value2 = (offset1 - offset0).toFixed(2) + "%";
      }
      if (this.colors.scaleType === ScaleType.Ordinal) {
        bar.color = this.colors.getColor(label);
      } else {
        if (this.type === BarChartType.Standard) {
          bar.color = this.colors.getColor(value2);
          bar.gradientStops = this.colors.getLinearGradientStops(value2);
        } else {
          bar.color = this.colors.getColor(bar.offset1);
          bar.gradientStops = this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
        }
      }
      let tooltipLabel = formattedLabel;
      bar.ariaLabel = formattedLabel + " " + value2.toLocaleString();
      if (this.seriesName !== null && this.seriesName !== void 0) {
        tooltipLabel = `${this.seriesName} \u2022 ${formattedLabel}`;
        bar.data.series = this.seriesName;
        bar.ariaLabel = this.seriesName + " " + bar.ariaLabel;
      }
      bar.tooltipText = this.tooltipDisabled ? void 0 : `
        <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
        <span class="tooltip-val">${this.dataLabelFormatting ? this.dataLabelFormatting(value2) : value2.toLocaleString()}</span>
      `;
      return bar;
    });
    this.updateDataLabels();
  }
  updateDataLabels() {
    if (this.type === BarChartType.Stacked) {
      this.barsForDataLabels = [];
      const section = {};
      section.series = this.seriesName;
      const totalPositive = this.series.map((d) => d.value).reduce((sum2, d) => d > 0 ? sum2 + d : sum2, 0);
      const totalNegative = this.series.map((d) => d.value).reduce((sum2, d) => d < 0 ? sum2 + d : sum2, 0);
      section.total = totalPositive + totalNegative;
      section.x = 0;
      section.y = 0;
      if (section.total > 0) {
        section.width = this.xScale(totalPositive);
      } else {
        section.width = this.xScale(totalNegative);
      }
      section.height = this.yScale.bandwidth();
      this.barsForDataLabels.push(section);
    } else {
      this.barsForDataLabels = this.series.map((d) => {
        const section = {};
        section.series = this.seriesName ?? d.label;
        section.total = d.value;
        section.x = this.xScale(0);
        section.y = this.yScale(d.label);
        section.width = this.xScale(section.total) - this.xScale(0);
        section.height = this.yScale.bandwidth();
        return section;
      });
    }
  }
  updateTooltipSettings() {
    this.tooltipPlacement = this.tooltipDisabled ? void 0 : PlacementTypes.Top;
    this.tooltipType = this.tooltipDisabled ? void 0 : StyleTypes.tooltip;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((active) => {
      return entry.name === active.name && entry.value === active.value;
    });
    return item !== void 0;
  }
  getLabel(dataItem) {
    if (dataItem.label) {
      return dataItem.label;
    }
    return dataItem.name;
  }
  trackBy(index, bar) {
    return bar.label;
  }
  trackDataLabelBy(index, barLabel) {
    return index + "#" + barLabel.series + "#" + barLabel.total;
  }
  click(data) {
    this.select.emit(data);
  }
  static {
    this.\u0275fac = function SeriesHorizontal_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SeriesHorizontal)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SeriesHorizontal,
      selectors: [["g", "ngx-charts-series-horizontal", ""]],
      inputs: {
        dims: "dims",
        type: "type",
        series: "series",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        activeEntries: "activeEntries",
        seriesName: "seriesName",
        tooltipTemplate: "tooltipTemplate",
        roundEdges: "roundEdges",
        animations: "animations",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate",
        dataLabelWidthChanged: "dataLabelWidthChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c28,
      decls: 2,
      vars: 3,
      consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "dimensionsChanged", "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation"]],
      template: function SeriesHorizontal_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0)(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showDataLabel);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, BarComponent, BarLabelComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesHorizontal, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-series-horizontal]",
      template: `
    <svg:g
      ngx-charts-bar
      *ngFor="let bar of bars; trackBy: trackBy"
      [@animationState]="'active'"
      [width]="bar.width"
      [height]="bar.height"
      [x]="bar.x"
      [y]="bar.y"
      [fill]="bar.color"
      [stops]="bar.gradientStops"
      [data]="bar.data"
      [orientation]="barOrientation.Horizontal"
      [roundEdges]="bar.roundEdges"
      (select)="click($event)"
      [gradient]="gradient"
      [isActive]="isActive(bar.data)"
      [ariaLabel]="bar.ariaLabel"
      [animations]="animations"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="tooltipPlacement"
      [tooltipType]="tooltipType"
      [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="bar.data"
      [noBarWhenZero]="noBarWhenZero"
    ></svg:g>
    <svg:g *ngIf="showDataLabel">
      <svg:g
        ngx-charts-bar-label
        *ngFor="let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy"
        [barX]="b.x"
        [barY]="b.y"
        [barWidth]="b.width"
        [barHeight]="b.height"
        [value]="b.total"
        [valueFormatting]="dataLabelFormatting"
        [orientation]="barOrientation.Horizontal"
        (dimensionsChanged)="dataLabelWidthChanged.emit({ size: $event, index: i })"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], null, {
    dims: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    seriesName: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dataLabelWidthChanged: [{
      type: Output
    }]
  });
})();
var BarHorizontalComponent = class _BarHorizontalComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getXScale() {
    this.xDomain = this.getXDomain();
    const scale = linear().range([0, this.dims.width]).domain(this.xDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale() {
    this.yDomain = this.getYDomain();
    const spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.yDomain);
  }
  getXDomain() {
    const values = this.results.map((d) => d.value);
    const min4 = this.xScaleMin ? Math.min(this.xScaleMin, ...values) : Math.min(0, ...values);
    const max4 = this.xScaleMax ? Math.max(this.xScaleMax, ...values) : Math.max(0, ...values);
    return [min4, max4];
  }
  getYDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.yDomain;
    } else {
      domain = this.xDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === "ordinal") {
      opts.domain = this.yDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.xDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (event.index === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarHorizontalComponent_BaseFactory;
      return function BarHorizontalComponent_Factory(__ngFactoryType__) {
        return (\u0275BarHorizontalComponent_BaseFactory || (\u0275BarHorizontalComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalComponent)))(__ngFactoryType__ || _BarHorizontalComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarHorizontalComponent,
      selectors: [["ngx-charts-bar-horizontal"]],
      contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        roundEdges: "roundEdges",
        xScaleMax: "xScaleMax",
        xScaleMin: "xScaleMin",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 25,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"]],
      template: function BarHorizontalComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, true);
          })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, true);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarHorizontalComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalComponent__svg_g_3_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(4, "g", 4);
          \u0275\u0275listener("select", function BarHorizontalComponent_Template_g_select_4_listener($event) {
            return ctx.onClick($event);
          })("activate", function BarHorizontalComponent_Template_g_activate_4_listener($event) {
            return ctx.onActivate($event);
          })("deactivate", function BarHorizontalComponent_Template_g_deactivate_4_listener($event) {
            return ctx.onDeactivate($event);
          })("dataLabelWidthChanged", function BarHorizontalComponent_Template_g_dataLabelWidthChanged_4_listener($event) {
            return ctx.onDataLabelMaxWidthChanged($event);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(22, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
        }
      },
      dependencies: [NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-series-horizontal
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [series]="results"
          [dims]="dims"
          [gradient]="gradient"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [activeEntries]="activeEntries"
          [roundEdges]="roundEdges"
          [animations]="animations"
          [showDataLabel]="showDataLabel"
          [dataLabelFormatting]="dataLabelFormatting"
          [noBarWhenZero]="noBarWhenZero"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
          (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event)"
        ></svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarHorizontal2DComponent = class _BarHorizontal2DComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.groupPadding = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barOrientation = BarOrientation;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.groupScale = this.getGroupScale();
    this.innerScale = this.getInnerScale();
    this.valueScale = this.getValueScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).paddingOuter(spacing / 2).domain(this.groupDomain);
  }
  getInnerScale() {
    const height = this.groupScale.bandwidth();
    const spacing = this.innerDomain.length / (height / this.barPadding + 1);
    return band().rangeRound([0, height]).paddingInner(spacing).domain(this.innerDomain);
  }
  getValueScale() {
    const scale = linear().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const min4 = Math.min(0, ...domain);
    const max4 = this.xScaleMax ? Math.max(this.xScaleMax, ...domain) : Math.max(0, ...domain);
    return [min4, max4];
  }
  groupTransform(group) {
    return `translate(0, ${this.groupScale(group.label)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarHorizontal2DComponent_BaseFactory;
      return function BarHorizontal2DComponent_Factory(__ngFactoryType__) {
        return (\u0275BarHorizontal2DComponent_BaseFactory || (\u0275BarHorizontal2DComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontal2DComponent)))(__ngFactoryType__ || _BarHorizontal2DComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarHorizontal2DComponent,
      selectors: [["ngx-charts-bar-horizontal-2d"]],
      contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        groupPadding: "groupPadding",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        roundEdges: "roundEdges",
        xScaleMax: "xScaleMax",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 7,
      vars: 18,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", 3, "xScale", "yScale", "data", "dims", "orient"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"]],
      template: function BarHorizontal2DComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275element(2, "g", 2);
          \u0275\u0275template(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 11, "g", 3)(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 10, "g", 4)(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 2, "g", 5)(6, BarHorizontal2DComponent__svg_g_6_Template, 2, 2, "g", 5);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(15, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims)("orient", ctx.barOrientation.Horizontal);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, GridPanelSeriesComponent, SeriesHorizontal],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontal2DComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-2d",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-grid-panel-series
          [xScale]="valueScale"
          [yScale]="groupScale"
          [data]="results"
          [dims]="dims"
          [orient]="barOrientation.Horizontal"
        ></svg:g>
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="valueScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="groupScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>

        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [xScale]="valueScale"
              [activeEntries]="activeEntries"
              [yScale]="innerScale"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [roundEdges]="roundEdges"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [xScale]="valueScale"
              [activeEntries]="activeEntries"
              [yScale]="innerScale"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [roundEdges]="roundEdges"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    groupPadding: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarHorizontalNormalizedComponent = class _BarHorizontalNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.valueDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.barChartType = BarChartType;
    this.isSSR = false;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getYScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
  }
  getXScale() {
    const scale = linear().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(0, ${this.yScale(group.name)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarHorizontalNormalizedComponent_BaseFactory;
      return function BarHorizontalNormalizedComponent_Factory(__ngFactoryType__) {
        return (\u0275BarHorizontalNormalizedComponent_BaseFactory || (\u0275BarHorizontalNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalNormalizedComponent)))(__ngFactoryType__ || _BarHorizontalNormalizedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarHorizontalNormalizedComponent,
      selectors: [["ngx-charts-bar-horizontal-normalized"]],
      contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 13,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero"]],
      template: function BarHorizontalNormalizedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3)(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarHorizontalNormalizedComponent__svg_g_5_Template, 2, 2, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              [noBarWhenZero]="noBarWhenZero"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g *ngFor="let group of results; trackBy: trackBy" [attr.transform]="groupTransform(group)">
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              [noBarWhenZero]="noBarWhenZero"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarHorizontalStackedComponent = class _BarHorizontalStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
    this.barChartType = BarChartType;
    this.isSSR = false;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    let smallest = 0;
    let biggest = 0;
    for (const group of this.results) {
      let smallestSum = 0;
      let biggestSum = 0;
      for (const d of group.series) {
        if (d.value < 0) {
          smallestSum += d.value;
        } else {
          biggestSum += d.value;
        }
        smallest = d.value < smallest ? d.value : smallest;
        biggest = d.value > biggest ? d.value : biggest;
      }
      domain.push(smallestSum);
      domain.push(biggestSum);
    }
    domain.push(smallest);
    domain.push(biggest);
    const min4 = Math.min(0, ...domain);
    const max4 = this.xScaleMax ? Math.max(this.xScaleMax, ...domain) : Math.max(...domain);
    return [min4, max4];
  }
  getYScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
  }
  getXScale() {
    const scale = linear().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(0, ${this.yScale(group.name)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarHorizontalStackedComponent_BaseFactory;
      return function BarHorizontalStackedComponent_Factory(__ngFactoryType__) {
        return (\u0275BarHorizontalStackedComponent_BaseFactory || (\u0275BarHorizontalStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalStackedComponent)))(__ngFactoryType__ || _BarHorizontalStackedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarHorizontalStackedComponent,
      selectors: [["ngx-charts-bar-horizontal-stacked"]],
      contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        xScaleMax: "xScaleMax",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 13,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "type", "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"]],
      template: function BarHorizontalStackedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarHorizontalStackedComponent__svg_g_5_Template, 2, 2, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [series]="group.series"
              [activeEntries]="activeEntries"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [series]="group.series"
              [activeEntries]="activeEntries"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var SeriesVerticalComponent = class _SeriesVerticalComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.type = BarChartType.Standard;
    this.tooltipDisabled = false;
    this.animations = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dataLabelHeightChanged = new EventEmitter();
    this.barsForDataLabels = [];
    this.barOrientation = BarOrientation;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateTooltipSettings();
    let width;
    if (this.series.length) {
      width = this.xScale.bandwidth();
    }
    width = Math.round(width);
    const yScaleMin = Math.max(this.yScale.domain()[0], 0);
    const d0 = {
      [D0Types.positive]: 0,
      [D0Types.negative]: 0
    };
    let d0Type = D0Types.positive;
    let total;
    if (this.type === BarChartType.Normalized) {
      total = this.series.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
    }
    this.bars = this.series.map((d, index) => {
      let value2 = d.value;
      const label = this.getLabel(d);
      const formattedLabel = formatLabel(label);
      const roundEdges = this.roundEdges;
      d0Type = value2 > 0 ? D0Types.positive : D0Types.negative;
      const bar = {
        value: value2,
        label,
        roundEdges,
        data: d,
        width,
        formattedLabel,
        height: 0,
        x: 0,
        y: 0
      };
      if (this.type === BarChartType.Standard) {
        bar.height = Math.abs(this.yScale(value2) - this.yScale(yScaleMin));
        bar.x = this.xScale(label);
        if (value2 < 0) {
          bar.y = this.yScale(0);
        } else {
          bar.y = this.yScale(value2);
        }
      } else if (this.type === BarChartType.Stacked) {
        const offset0 = d0[d0Type];
        const offset1 = offset0 + value2;
        d0[d0Type] += value2;
        bar.height = this.yScale(offset0) - this.yScale(offset1);
        bar.x = 0;
        bar.y = this.yScale(offset1);
        bar.offset0 = offset0;
        bar.offset1 = offset1;
      } else if (this.type === BarChartType.Normalized) {
        let offset0 = d0[d0Type];
        let offset1 = offset0 + value2;
        d0[d0Type] += value2;
        if (total > 0) {
          offset0 = offset0 * 100 / total;
          offset1 = offset1 * 100 / total;
        } else {
          offset0 = 0;
          offset1 = 0;
        }
        bar.height = this.yScale(offset0) - this.yScale(offset1);
        bar.x = 0;
        bar.y = this.yScale(offset1);
        bar.offset0 = offset0;
        bar.offset1 = offset1;
        value2 = (offset1 - offset0).toFixed(2) + "%";
      }
      if (this.colors.scaleType === ScaleType.Ordinal) {
        bar.color = this.colors.getColor(label);
      } else {
        if (this.type === BarChartType.Standard) {
          bar.color = this.colors.getColor(value2);
          bar.gradientStops = this.colors.getLinearGradientStops(value2);
        } else {
          bar.color = this.colors.getColor(bar.offset1);
          bar.gradientStops = this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
        }
      }
      let tooltipLabel = formattedLabel;
      bar.ariaLabel = formattedLabel + " " + value2.toLocaleString();
      if (this.seriesName !== null && this.seriesName !== void 0) {
        tooltipLabel = `${this.seriesName} \u2022 ${formattedLabel}`;
        bar.data.series = this.seriesName;
        bar.ariaLabel = this.seriesName + " " + bar.ariaLabel;
      }
      bar.tooltipText = this.tooltipDisabled ? void 0 : `
        <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
        <span class="tooltip-val">${this.dataLabelFormatting ? this.dataLabelFormatting(value2) : value2.toLocaleString()}</span>
      `;
      return bar;
    });
    this.updateDataLabels();
  }
  updateDataLabels() {
    if (this.type === BarChartType.Stacked) {
      this.barsForDataLabels = [];
      const section = {};
      section.series = this.seriesName;
      const totalPositive = this.series.map((d) => d.value).reduce((sum2, d) => d > 0 ? sum2 + d : sum2, 0);
      const totalNegative = this.series.map((d) => d.value).reduce((sum2, d) => d < 0 ? sum2 + d : sum2, 0);
      section.total = totalPositive + totalNegative;
      section.x = 0;
      section.y = 0;
      if (section.total > 0) {
        section.height = this.yScale(totalPositive);
      } else {
        section.height = this.yScale(totalNegative);
      }
      section.width = this.xScale.bandwidth();
      this.barsForDataLabels.push(section);
    } else {
      this.barsForDataLabels = this.series.map((d) => {
        const section = {};
        section.series = this.seriesName ?? d.label;
        section.total = d.value;
        section.x = this.xScale(d.label);
        section.y = this.yScale(0);
        section.height = this.yScale(section.total) - this.yScale(0);
        section.width = this.xScale.bandwidth();
        return section;
      });
    }
  }
  updateTooltipSettings() {
    this.tooltipPlacement = this.tooltipDisabled ? void 0 : PlacementTypes.Top;
    this.tooltipType = this.tooltipDisabled ? void 0 : StyleTypes.tooltip;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((active) => {
      return entry.name === active.name && entry.value === active.value;
    });
    return item !== void 0;
  }
  onClick(data) {
    this.select.emit(data);
  }
  getLabel(dataItem) {
    if (dataItem.label) {
      return dataItem.label;
    }
    return dataItem.name;
  }
  trackBy(index, bar) {
    return bar.label;
  }
  trackDataLabelBy(index, barLabel) {
    return index + "#" + barLabel.series + "#" + barLabel.total;
  }
  static {
    this.\u0275fac = function SeriesVerticalComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SeriesVerticalComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SeriesVerticalComponent,
      selectors: [["g", "ngx-charts-series-vertical", ""]],
      inputs: {
        dims: "dims",
        type: "type",
        series: "series",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        gradient: "gradient",
        activeEntries: "activeEntries",
        seriesName: "seriesName",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate",
        roundEdges: "roundEdges",
        animations: "animations",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate",
        dataLabelHeightChanged: "dataLabelHeightChanged"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c29,
      decls: 3,
      vars: 3,
      consts: [[4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "dimensionsChanged", "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation"]],
      template: function SeriesVerticalComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, SeriesVerticalComponent__svg_g_0_Template, 2, 2, "g", 0)(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 0)(2, SeriesVerticalComponent__svg_g_2_Template, 2, 2, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showDataLabel);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, BarComponent, BarLabelComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesVerticalComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-series-vertical]",
      template: `
    <svg:g *ngIf="!isSSR">
      <svg:g
        ngx-charts-bar
        *ngFor="let bar of bars; trackBy: trackBy"
        [@animationState]="'active'"
        [@.disabled]="!animations"
        [width]="bar.width"
        [height]="bar.height"
        [x]="bar.x"
        [y]="bar.y"
        [fill]="bar.color"
        [stops]="bar.gradientStops"
        [data]="bar.data"
        [orientation]="barOrientation.Vertical"
        [roundEdges]="bar.roundEdges"
        [gradient]="gradient"
        [ariaLabel]="bar.ariaLabel"
        [isActive]="isActive(bar.data)"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="tooltipPlacement"
        [tooltipType]="tooltipType"
        [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="bar.data"
        [noBarWhenZero]="noBarWhenZero"
        [animations]="animations"
      ></svg:g>
    </svg:g>
    <svg:g *ngIf="isSSR">
      <svg:g
        ngx-charts-bar
        *ngFor="let bar of bars; trackBy: trackBy"
        [width]="bar.width"
        [height]="bar.height"
        [x]="bar.x"
        [y]="bar.y"
        [fill]="bar.color"
        [stops]="bar.gradientStops"
        [data]="bar.data"
        [orientation]="barOrientation.Vertical"
        [roundEdges]="bar.roundEdges"
        [gradient]="gradient"
        [ariaLabel]="bar.ariaLabel"
        [isActive]="isActive(bar.data)"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="tooltipPlacement"
        [tooltipType]="tooltipType"
        [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="bar.data"
        [noBarWhenZero]="noBarWhenZero"
        [animations]="animations"
      ></svg:g>
    </svg:g>
    <svg:g *ngIf="showDataLabel">
      <svg:g
        ngx-charts-bar-label
        *ngFor="let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy"
        [barX]="b.x"
        [barY]="b.y"
        [barWidth]="b.width"
        [barHeight]="b.height"
        [value]="b.total"
        [valueFormatting]="dataLabelFormatting"
        [orientation]="barOrientation.Vertical"
        (dimensionsChanged)="dataLabelHeightChanged.emit({ size: $event, index: i })"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    dims: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    seriesName: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dataLabelHeightChanged: [{
      type: Output
    }]
  });
})();
var BarVerticalComponent = class _BarVerticalComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  getXScale() {
    this.xDomain = this.getXDomain();
    const spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
    return band().range([0, this.dims.width]).paddingInner(spacing).domain(this.xDomain);
  }
  getYScale() {
    this.yDomain = this.getYDomain();
    const scale = linear().range([this.dims.height, 0]).domain(this.yDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getXDomain() {
    return this.results.map((d) => d.label);
  }
  getYDomain() {
    const values = this.results.map((d) => d.value);
    let min4 = this.yScaleMin ? Math.min(this.yScaleMin, ...values) : Math.min(0, ...values);
    if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
      min4 = Math.min(min4, ...this.yAxisTicks);
    }
    let max4 = this.yScaleMax ? Math.max(this.yScaleMax, ...values) : Math.max(0, ...values);
    if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
      max4 = Math.max(max4, ...this.yAxisTicks);
    }
    return [min4, max4];
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.xDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.xDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxHeightChanged(event) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (event.index === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarVerticalComponent_BaseFactory;
      return function BarVerticalComponent_Factory(__ngFactoryType__) {
        return (\u0275BarVerticalComponent_BaseFactory || (\u0275BarVerticalComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalComponent)))(__ngFactoryType__ || _BarVerticalComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarVerticalComponent,
      selectors: [["ngx-charts-bar-vertical"]],
      contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        roundEdges: "roundEdges",
        yScaleMax: "yScaleMax",
        yScaleMin: "yScaleMin",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 25,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activate", "deactivate", "select", "dataLabelHeightChanged", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"]],
      template: function BarVerticalComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, true);
          })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, true);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarVerticalComponent__svg_g_2_Template, 1, 12, "g", 2)(3, BarVerticalComponent__svg_g_3_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(4, "g", 4);
          \u0275\u0275listener("activate", function BarVerticalComponent_Template_g_activate_4_listener($event) {
            return ctx.onActivate($event);
          })("deactivate", function BarVerticalComponent_Template_g_deactivate_4_listener($event) {
            return ctx.onDeactivate($event);
          })("select", function BarVerticalComponent_Template_g_select_4_listener($event) {
            return ctx.onClick($event);
          })("dataLabelHeightChanged", function BarVerticalComponent_Template_g_dataLabelHeightChanged_4_listener($event) {
            return ctx.onDataLabelMaxHeightChanged($event);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(22, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
        }
      },
      dependencies: [NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-series-vertical
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [series]="results"
          [dims]="dims"
          [gradient]="gradient"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [showDataLabel]="showDataLabel"
          [dataLabelFormatting]="dataLabelFormatting"
          [activeEntries]="activeEntries"
          [roundEdges]="roundEdges"
          [animations]="animations"
          [noBarWhenZero]="noBarWhenZero"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
          (select)="onClick($event)"
          (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event)"
        ></svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarVertical2DComponent = class _BarVertical2DComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.scaleType = ScaleType.Ordinal;
    this.showGridLines = true;
    this.activeEntries = [];
    this.schemeType = ScaleType.Ordinal;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.groupPadding = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barOrientation = BarOrientation;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.groupScale = this.getGroupScale();
    this.innerScale = this.getInnerScale();
    this.valueScale = this.getValueScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  onDataLabelMaxHeightChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  getGroupScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).paddingOuter(spacing / 2).domain(this.groupDomain);
  }
  getInnerScale() {
    const width = this.groupScale.bandwidth();
    const spacing = this.innerDomain.length / (width / this.barPadding + 1);
    return band().rangeRound([0, width]).paddingInner(spacing).domain(this.innerDomain);
  }
  getValueScale() {
    const scale = linear().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const min4 = Math.min(0, ...domain);
    const max4 = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(0, ...domain);
    return [min4, max4];
  }
  groupTransform(group) {
    return `translate(${this.groupScale(group.label)}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarVertical2DComponent_BaseFactory;
      return function BarVertical2DComponent_Factory(__ngFactoryType__) {
        return (\u0275BarVertical2DComponent_BaseFactory || (\u0275BarVertical2DComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVertical2DComponent)))(__ngFactoryType__ || _BarVertical2DComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarVertical2DComponent,
      selectors: [["ngx-charts-bar-vertical-2d"]],
      contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        scaleType: "scaleType",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        groupPadding: "groupPadding",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        roundEdges: "roundEdges",
        yScaleMax: "yScaleMax",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 7,
      vars: 18,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", 3, "xScale", "yScale", "data", "dims", "orient"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "dataLabelHeightChanged", "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero"]],
      template: function BarVertical2DComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275element(2, "g", 2);
          \u0275\u0275template(3, BarVertical2DComponent__svg_g_3_Template, 1, 11, "g", 3)(4, BarVertical2DComponent__svg_g_4_Template, 1, 10, "g", 4)(5, BarVertical2DComponent__svg_g_5_Template, 2, 2, "g", 5)(6, BarVertical2DComponent__svg_g_6_Template, 2, 2, "g", 5);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(15, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims)("orient", ctx.barOrientation.Vertical);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, GridPanelSeriesComponent, SeriesVerticalComponent],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVertical2DComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-2d",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-grid-panel-series
          [xScale]="groupScale"
          [yScale]="valueScale"
          [data]="results"
          [dims]="dims"
          [orient]="barOrientation.Vertical"
        ></svg:g>
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="groupScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="valueScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            ngx-charts-series-vertical
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
            [activeEntries]="activeEntries"
            [xScale]="innerScale"
            [yScale]="valueScale"
            [colors]="colors"
            [series]="group.series"
            [dims]="dims"
            [gradient]="gradient"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [showDataLabel]="showDataLabel"
            [dataLabelFormatting]="dataLabelFormatting"
            [seriesName]="group.name"
            [roundEdges]="roundEdges"
            [animations]="animations"
            [noBarWhenZero]="noBarWhenZero"
            (select)="onClick($event, group)"
            (activate)="onActivate($event, group)"
            (deactivate)="onDeactivate($event, group)"
            (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
          ></svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            ngx-charts-series-vertical
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
            [activeEntries]="activeEntries"
            [xScale]="innerScale"
            [yScale]="valueScale"
            [colors]="colors"
            [series]="group.series"
            [dims]="dims"
            [gradient]="gradient"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [showDataLabel]="showDataLabel"
            [dataLabelFormatting]="dataLabelFormatting"
            [seriesName]="group.name"
            [roundEdges]="roundEdges"
            [animations]="animations"
            [noBarWhenZero]="noBarWhenZero"
            (select)="onClick($event, group)"
            (activate)="onActivate($event, group)"
            (deactivate)="onDeactivate($event, group)"
            (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
          ></svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    groupPadding: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarVerticalNormalizedComponent = class _BarVerticalNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.schemeType = ScaleType.Ordinal;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.valueDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.isSSR = false;
    this.barChartType = BarChartType;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getXScale() {
    const spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
  }
  getYScale() {
    const scale = linear().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(${this.xScale(group.name)}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarVerticalNormalizedComponent_BaseFactory;
      return function BarVerticalNormalizedComponent_Factory(__ngFactoryType__) {
        return (\u0275BarVerticalNormalizedComponent_BaseFactory || (\u0275BarVerticalNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalNormalizedComponent)))(__ngFactoryType__ || _BarVerticalNormalizedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarVerticalNormalizedComponent,
      selectors: [["ngx-charts-bar-vertical-normalized"]],
      contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 13,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero"]],
      template: function BarVerticalNormalizedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2)(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarVerticalNormalizedComponent__svg_g_5_Template, 2, 2, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g *ngFor="let group of results; trackBy: trackBy" [attr.transform]="groupTransform(group)">
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
            ></svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarVerticalStackedComponent = class _BarVerticalStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barChartType = BarChartType;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    let smallest = 0;
    let biggest = 0;
    for (const group of this.results) {
      let smallestSum = 0;
      let biggestSum = 0;
      for (const d of group.series) {
        if (d.value < 0) {
          smallestSum += d.value;
        } else {
          biggestSum += d.value;
        }
        smallest = d.value < smallest ? d.value : smallest;
        biggest = d.value > biggest ? d.value : biggest;
      }
      domain.push(smallestSum);
      domain.push(biggestSum);
    }
    domain.push(smallest);
    domain.push(biggest);
    const min4 = Math.min(0, ...domain);
    const max4 = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(...domain);
    return [min4, max4];
  }
  getXScale() {
    const spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
  }
  getYScale() {
    const scale = linear().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  onDataLabelMaxHeightChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  groupTransform(group) {
    return `translate(${this.xScale(group.name) || 0}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BarVerticalStackedComponent_BaseFactory;
      return function BarVerticalStackedComponent_Factory(__ngFactoryType__) {
        return (\u0275BarVerticalStackedComponent_BaseFactory || (\u0275BarVerticalStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalStackedComponent)))(__ngFactoryType__ || _BarVerticalStackedComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BarVerticalStackedComponent,
      selectors: [["ngx-charts-bar-vertical-stacked"]],
      contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        showGridLines: "showGridLines",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        barPadding: "barPadding",
        roundDomains: "roundDomains",
        yScaleMax: "yScaleMax",
        showDataLabel: "showDataLabel",
        dataLabelFormatting: "dataLabelFormatting",
        noBarWhenZero: "noBarWhenZero",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 13,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "dataLabelHeightChanged", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero"]],
      template: function BarVerticalStackedComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, void 0, true);
          })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, void 0, true);
          })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarVerticalStackedComponent__svg_g_5_Template, 2, 2, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1,
          transform: "*"
        }), animate(500, style({
          opacity: 0,
          transform: "scale(0)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
            ></svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BarChartModule = class _BarChartModule {
  static {
    this.\u0275fac = function BarChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BarChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _BarChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent],
      exports: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent]
    }]
  }], null, null);
})();
function clonePoint(original) {
  if (!original) {
    return original;
  }
  return {
    x: original.x,
    y: original.y
  };
}
function cloneVector2d(original) {
  if (!original) {
    return original;
  }
  return {
    v1: clonePoint(original.v1),
    v2: clonePoint(original.v2)
  };
}
function cloneLineCoordinates(original) {
  if (!original) {
    return original;
  }
  return [cloneVector2d(original[0]), cloneVector2d(original[1]), cloneVector2d(original[2]), cloneVector2d(original[3])];
}
var BoxComponent = class _BoxComponent {
  constructor(element, cd) {
    this.cd = cd;
    this.roundEdges = true;
    this.gradient = false;
    this.offset = 0;
    this.isActive = false;
    this.animations = true;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.BarOrientation = BarOrientation;
    this.initialized = false;
    this.hasGradient = false;
    this.hideBar = false;
    this.nativeElm = element.nativeElement;
  }
  ngOnChanges(changes) {
    if (!this.initialized) {
      this.loadAnimation();
      this.initialized = true;
    } else {
      this.update();
    }
  }
  update() {
    this.boxStrokeWidth = Math.max(this.strokeWidth, 1);
    this.whiskerStrokeWidth = Math.max(this.strokeWidth / 2, 1);
    this.medianLineWidth = 1.5 * this.strokeWidth;
    this.gradientId = "grad" + id().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updateLineEl();
    this.updatePathEl();
    this.checkToHideBar();
    this.maskLineId = "mask" + id().toString();
    this.maskLine = `url(#${this.maskLineId})`;
    if (this.cd) {
      this.cd.markForCheck();
    }
  }
  loadAnimation() {
    this.boxPath = this.oldPath = this.getStartingPath();
    this.oldLineCoordinates = this.getStartingLineCoordinates();
    setTimeout(this.update.bind(this), 100);
  }
  updatePathEl() {
    const nodeBar = select_default(this.nativeElm).selectAll(".bar");
    const path2 = this.getPath();
    if (this.animations) {
      nodeBar.attr("d", this.oldPath).transition().ease(sinInOut).duration(500).attrTween("d", this.pathTween(path2, 4));
    } else {
      nodeBar.attr("d", path2);
    }
    this.oldPath = path2;
  }
  updateLineEl() {
    const lineEl = select_default(this.nativeElm).selectAll(".bar-line");
    const lineCoordinates = this.lineCoordinates;
    const oldLineCoordinates = this.oldLineCoordinates;
    if (this.animations) {
      lineEl.attr("x1", (_, index) => oldLineCoordinates[index].v1.x).attr("y1", (_, index) => oldLineCoordinates[index].v1.y).attr("x2", (_, index) => oldLineCoordinates[index].v2.x).attr("y2", (_, index) => oldLineCoordinates[index].v2.y).transition().ease(sinInOut).duration(500).attr("x1", (_, index) => lineCoordinates[index].v1.x).attr("y1", (_, index) => lineCoordinates[index].v1.y).attr("x2", (_, index) => lineCoordinates[index].v2.x).attr("y2", (_, index) => lineCoordinates[index].v2.y);
    } else {
      lineEl.attr("x1", (_, index) => lineCoordinates[index].v1.x).attr("y1", (_, index) => lineCoordinates[index].v1.y).attr("x2", (_, index) => lineCoordinates[index].v2.x).attr("y2", (_, index) => lineCoordinates[index].v2.y);
    }
    this.oldLineCoordinates = [...lineCoordinates];
  }
  /**
   * See [D3 Selections](https://www.d3indepth.com/selections/)
   * @param d The joined data.
   * @param index The index of the element within the selection
   * @param node The node element (Line).
   */
  lineTween(attr, d, index, node) {
    const nodeLineEl = node[index];
    return nodeLineEl[attr].baseVal.value;
  }
  // TODO: Refactor into another .ts file if https://github.com/swimlane/ngx-charts/pull/1179 gets merged.
  pathTween(d1, precision) {
    return function() {
      const path0 = this;
      const path1 = this.cloneNode();
      path1.setAttribute("d", d1);
      const n0 = path0?.getTotalLength();
      const n1 = path1?.getTotalLength();
      const distances = [0];
      let i = 0;
      const dt = precision / Math.max(n0, n1);
      while (i < 1) {
        distances.push(i);
        i += dt;
      }
      distances.push(1);
      const points = distances.map((t) => {
        const p0 = path0.getPointAtLength(t * n0);
        const p1 = path1.getPointAtLength(t * n1);
        return value_default([p0.x, p0.y], [p1.x, p1.y]);
      });
      return (t) => {
        return t < 1 ? "M" + points.map((p) => p(t)).join("L") : d1;
      };
    };
  }
  getStartingPath() {
    if (!this.animations) {
      return this.getPath();
    }
    const radius = this.roundEdges ? 1 : 0;
    const {
      x: x2,
      y: y2
    } = this.lineCoordinates[2].v1;
    return roundedRect(x2 - this.width, y2 - 1, this.width, 2, radius, this.edges);
  }
  getPath() {
    const radius = this.getRadius();
    let path2 = "";
    path2 = roundedRect(this.x, this.y, this.width, this.height, Math.min(this.height, radius), this.edges);
    return path2;
  }
  getStartingLineCoordinates() {
    if (!this.animations) {
      return [...this.lineCoordinates];
    }
    const lineCoordinates = cloneLineCoordinates(this.lineCoordinates);
    lineCoordinates[1].v1.y = lineCoordinates[1].v2.y = lineCoordinates[3].v1.y = lineCoordinates[3].v2.y = lineCoordinates[0].v1.y = lineCoordinates[0].v2.y = lineCoordinates[2].v1.y;
    return lineCoordinates;
  }
  getRadius() {
    let radius = 0;
    if (this.roundEdges && this.height > 5 && this.width > 5) {
      radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
    }
    return radius;
  }
  getGradient() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.getStartOpacity()
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  getStartOpacity() {
    if (this.roundEdges) {
      return 0.2;
    } else {
      return 0.5;
    }
  }
  get edges() {
    let edges = [false, false, false, false];
    if (this.roundEdges) {
      edges = [true, true, true, true];
    }
    return edges;
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  checkToHideBar() {
    this.hideBar = this.noBarWhenZero && this.height === 0;
  }
  static {
    this.\u0275fac = function BoxComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BoxComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BoxComponent,
      selectors: [["g", "ngx-charts-box", ""]],
      hostBindings: function BoxComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function BoxComponent_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function BoxComponent_mouseleave_HostBindingHandler() {
            return ctx.onMouseLeave();
          });
        }
      },
      inputs: {
        strokeColor: "strokeColor",
        strokeWidth: "strokeWidth",
        fill: "fill",
        data: "data",
        width: "width",
        height: "height",
        x: "x",
        y: "y",
        lineCoordinates: "lineCoordinates",
        roundEdges: "roundEdges",
        gradient: "gradient",
        gradientStops: "gradientStops",
        offset: "offset",
        isActive: "isActive",
        animations: "animations",
        ariaLabel: "ariaLabel",
        noBarWhenZero: "noBarWhenZero"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c30,
      decls: 9,
      vars: 13,
      consts: [["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops", 4, "ngIf"], ["height", "100%", "width", "100%", "fill", "white", "fill-opacity", "1"], ["fill", "black", "fill-opacity", "1", 1, "bar"], ["role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["class", "bar-line", "fill", "none", 3, "hidden", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["fill", "none", 1, "bar-line"]],
      template: function BoxComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "defs");
          \u0275\u0275template(1, BoxComponent__svg_g_1_Template, 1, 3, "g", 0);
          \u0275\u0275elementStart(2, "mask")(3, "g");
          \u0275\u0275element(4, "rect", 1)(5, "path", 2);
          \u0275\u0275elementEnd()()();
          \u0275\u0275elementStart(6, "g")(7, "path", 3);
          \u0275\u0275listener("click", function BoxComponent_Template_path_click_7_listener() {
            return ctx.select.emit(ctx.data);
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(8, BoxComponent__svg_line_8_Template, 1, 9, "line", 4);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.hasGradient);
          \u0275\u0275advance();
          \u0275\u0275attribute("id", ctx.maskLineId);
          \u0275\u0275advance(3);
          \u0275\u0275attribute("d", ctx.boxPath);
          \u0275\u0275advance(2);
          \u0275\u0275classProp("active", ctx.isActive)("hidden", ctx.hideBar);
          \u0275\u0275attribute("d", ctx.boxPath)("stroke", ctx.strokeColor)("stroke-width", ctx.boxStrokeWidth)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.lineCoordinates);
        }
      },
      dependencies: [NgForOf, NgIf, SvgLinearGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-box]",
      template: `
    <svg:defs>
      <svg:g
        *ngIf="hasGradient"
        ngx-charts-svg-linear-gradient
        [orientation]="BarOrientation.Vertical"
        [name]="gradientId"
        [stops]="gradientStops"
      />
      <svg:mask [attr.id]="maskLineId">
        <svg:g>
          <rect height="100%" width="100%" fill="white" fill-opacity="1" />
          <path class="bar" [attr.d]="boxPath" fill="black" fill-opacity="1" />
        </svg:g>
      </svg:mask>
    </svg:defs>
    <svg:g>
      <svg:path
        class="bar"
        role="img"
        tabIndex="-1"
        [class.active]="isActive"
        [class.hidden]="hideBar"
        [attr.d]="boxPath"
        [attr.stroke]="strokeColor"
        [attr.stroke-width]="boxStrokeWidth"
        [attr.aria-label]="ariaLabel"
        [attr.fill]="hasGradient ? gradientFill : fill"
        (click)="select.emit(data)"
      />
      <svg:line
        *ngFor="let line of lineCoordinates; let i = index"
        class="bar-line"
        [class.hidden]="hideBar"
        [attr.x1]="line.v1.x"
        [attr.y1]="line.v1.y"
        [attr.x2]="line.v2.x"
        [attr.y2]="line.v2.y"
        [attr.stroke]="strokeColor"
        [attr.stroke-width]="i === 2 ? medianLineWidth : whiskerStrokeWidth"
        [attr.mask]="i ? undefined : maskLine"
        fill="none"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    lineCoordinates: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    gradientStops: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var BoxSeriesComponent = class _BoxSeriesComponent {
  constructor() {
    this.animations = true;
    this.tooltipDisabled = false;
    this.gradient = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  onClick(data) {
    this.select.emit(data);
  }
  update() {
    this.updateTooltipSettings();
    const width = this.series && this.series.series.length ? Math.round(this.xScale.bandwidth()) : null;
    const seriesName = this.series.name;
    this.counts = this.series.series;
    const mappedCounts = this.counts.map((serie) => Number(serie.value));
    this.whiskers = [min(mappedCounts), max(mappedCounts)];
    const groupCounts = this.counts.map((item) => item.value).sort((a, b) => Number(a) - Number(b));
    this.quartiles = this.getBoxQuantiles(groupCounts);
    this.lineCoordinates = this.getLinesCoordinates(seriesName.toString(), this.whiskers, this.quartiles, width);
    const value2 = this.quartiles[1];
    const formattedLabel = formatLabel(seriesName);
    const box = {
      value: value2,
      data: this.counts,
      label: seriesName,
      formattedLabel,
      width,
      height: 0,
      x: 0,
      y: 0,
      roundEdges: this.roundEdges,
      quartiles: this.quartiles,
      lineCoordinates: this.lineCoordinates
    };
    box.height = Math.abs(this.yScale(this.quartiles[0]) - this.yScale(this.quartiles[2]));
    box.x = this.xScale(seriesName.toString());
    box.y = this.yScale(this.quartiles[2]);
    box.ariaLabel = formattedLabel + " - Median: " + value2.toLocaleString();
    if (this.colors.scaleType === ScaleType.Ordinal) {
      box.color = this.colors.getColor(seriesName);
    } else {
      box.color = this.colors.getColor(this.quartiles[1]);
      box.gradientStops = this.colors.getLinearGradientStops(this.quartiles[0], this.quartiles[2]);
    }
    const tooltipLabel = formattedLabel;
    const formattedTooltipLabel = `
    <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
    <span class="tooltip-val">
      \u2022 Q1: ${this.quartiles[0]} \u2022 Q2: ${this.quartiles[1]} \u2022 Q3: ${this.quartiles[2]}<br>
      \u2022 Min: ${this.whiskers[0]} \u2022 Max: ${this.whiskers[1]}
    </span>`;
    box.tooltipText = this.tooltipDisabled ? void 0 : formattedTooltipLabel;
    this.tooltipTitle = this.tooltipDisabled ? void 0 : box.tooltipText;
    this.box = box;
  }
  getBoxQuantiles(inputData) {
    return [quantile(inputData, 0.25), quantile(inputData, 0.5), quantile(inputData, 0.75)];
  }
  getLinesCoordinates(seriesName, whiskers, quartiles, barWidth) {
    const commonX = this.xScale(seriesName);
    const offsetX = commonX + barWidth / 2;
    const medianLineWidth = Math.max(barWidth + 4 * this.strokeWidth, 1);
    const whiskerLineWidth = Math.max(barWidth / 3, 1);
    const whiskerZero = this.yScale(whiskers[0]);
    const whiskerOne = this.yScale(whiskers[1]);
    const median = this.yScale(quartiles[1]);
    const topLine = {
      v1: {
        x: offsetX + whiskerLineWidth / 2,
        y: whiskerZero
      },
      v2: {
        x: offsetX - whiskerLineWidth / 2,
        y: whiskerZero
      }
    };
    const medianLine = {
      v1: {
        x: offsetX + medianLineWidth / 2,
        y: median
      },
      v2: {
        x: offsetX - medianLineWidth / 2,
        y: median
      }
    };
    const bottomLine = {
      v1: {
        x: offsetX + whiskerLineWidth / 2,
        y: whiskerOne
      },
      v2: {
        x: offsetX - whiskerLineWidth / 2,
        y: whiskerOne
      }
    };
    const verticalLine = {
      v1: {
        x: offsetX,
        y: whiskerZero
      },
      v2: {
        x: offsetX,
        y: whiskerOne
      }
    };
    return [verticalLine, topLine, medianLine, bottomLine];
  }
  updateTooltipSettings() {
    if (this.tooltipDisabled) {
      this.tooltipPlacement = void 0;
      this.tooltipType = void 0;
    } else {
      if (!this.tooltipPlacement) {
        this.tooltipPlacement = PlacementTypes.Top;
      }
      if (!this.tooltipType) {
        this.tooltipType = StyleTypes.tooltip;
      }
    }
  }
  static {
    this.\u0275fac = function BoxSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BoxSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BoxSeriesComponent,
      selectors: [["g", "ngx-charts-box-series", ""]],
      inputs: {
        dims: "dims",
        series: "series",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        animations: "animations",
        strokeColor: "strokeColor",
        strokeWidth: "strokeWidth",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate",
        tooltipPlacement: "tooltipPlacement",
        tooltipType: "tooltipType",
        roundEdges: "roundEdges",
        gradient: "gradient"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c31,
      decls: 1,
      vars: 22,
      consts: [["ngx-charts-box", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "roundEdges", "fill", "gradientStops", "strokeColor", "strokeWidth", "data", "lineCoordinates", "gradient", "ariaLabel", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "animations"]],
      template: function BoxSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0);
          \u0275\u0275listener("select", function BoxSeriesComponent_Template_g_select_0_listener($event) {
            return ctx.onClick($event);
          })("activate", function BoxSeriesComponent_Template_g_activate_0_listener($event) {
            return ctx.activate.emit($event);
          })("deactivate", function BoxSeriesComponent_Template_g_deactivate_0_listener($event) {
            return ctx.deactivate.emit($event);
          });
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("@animationState", "active")("@.disabled", !ctx.animations)("width", ctx.box.width)("height", ctx.box.height)("x", ctx.box.x)("y", ctx.box.y)("roundEdges", ctx.box.roundEdges)("fill", ctx.box.color)("gradientStops", ctx.box.gradientStops)("strokeColor", ctx.strokeColor)("strokeWidth", ctx.strokeWidth)("data", ctx.box.data)("lineCoordinates", ctx.box.lineCoordinates)("gradient", ctx.gradient)("ariaLabel", ctx.box.ariaLabel)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.tooltipPlacement)("tooltipType", ctx.tooltipType)("tooltipTitle", ctx.tooltipTitle)("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.box.data)("animations", ctx.animations);
        }
      },
      dependencies: [TooltipDirective, BoxComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-box-series]",
      template: `
    <svg:g
      ngx-charts-box
      [@animationState]="'active'"
      [@.disabled]="!animations"
      [width]="box.width"
      [height]="box.height"
      [x]="box.x"
      [y]="box.y"
      [roundEdges]="box.roundEdges"
      [fill]="box.color"
      [gradientStops]="box.gradientStops"
      [strokeColor]="strokeColor"
      [strokeWidth]="strokeWidth"
      [data]="box.data"
      [lineCoordinates]="box.lineCoordinates"
      [gradient]="gradient"
      [ariaLabel]="box.ariaLabel"
      (select)="onClick($event)"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="tooltipPlacement"
      [tooltipType]="tooltipType"
      [tooltipTitle]="tooltipTitle"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="box.data"
      [animations]="animations"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], null, {
    dims: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipType: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var BoxChartComponent = class _BoxChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendPosition = LegendPosition.Right;
    this.legendTitle = "Legend";
    this.showGridLines = true;
    this.xAxis = true;
    this.yAxis = true;
    this.showXAxisLabel = true;
    this.showYAxisLabel = true;
    this.roundDomains = false;
    this.roundEdges = true;
    this.strokeColor = "#FFFFFF";
    this.strokeWidth = 2;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
  }
  trackBy(index, item) {
    return item.name;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.setScales();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  setColors() {
    let domain = [];
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  setScales() {
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
  }
  getXScale(domain, width) {
    const scale = band().domain(domain.map((d) => d.toString())).rangeRound([0, width]).padding(0.5);
    return scale;
  }
  getYScale(domain, height) {
    const scale = linear().domain(domain).range([height, 0]);
    return this.roundDomains ? scale.nice() : scale;
  }
  getUniqueBoxChartXDomainValues(results) {
    const valueSet = /* @__PURE__ */ new Set();
    for (const result of results) {
      valueSet.add(result.name);
    }
    return Array.from(valueSet);
  }
  getXDomain() {
    let domain = [];
    const values = this.getUniqueBoxChartXDomainValues(this.results);
    let min4;
    let max4;
    if (typeof values[0] === "string") {
      domain = values.map((val) => val.toString());
    } else if (typeof values[0] === "number") {
      const mappedValues = values.map((v) => Number(v));
      min4 = Math.min(...mappedValues);
      max4 = Math.max(...mappedValues);
      domain = [min4, max4];
    } else {
      const mappedValues = values.map((v) => Number(new Date(v)));
      min4 = Math.min(...mappedValues);
      max4 = Math.max(...mappedValues);
      domain = [new Date(min4), new Date(max4)];
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
      }
    }
    const values = [...domain];
    const mappedValues = values.map((v) => Number(v));
    const min4 = Math.min(...mappedValues);
    const max4 = Math.max(...mappedValues);
    return [min4, max4];
  }
  getSeriesDomain() {
    return this.results.map((d) => `${d.name}`);
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onClick(data) {
    this.select.emit(data);
  }
  onActivate(data) {
    this.activate.emit(data);
  }
  onDeactivate(data) {
    this.deactivate.emit(data);
  }
  getLegendOptions() {
    const legendOpts = {
      scaleType: this.schemeType,
      colors: this.colors,
      domain: [],
      position: this.legendPosition,
      title: this.legendTitle
    };
    if (this.schemeType === ScaleType.Ordinal) {
      legendOpts.domain = this.xDomain;
      legendOpts.colors = this.colors;
    } else {
      legendOpts.domain = this.yDomain;
      legendOpts.colors = this.colors.scale;
    }
    return legendOpts;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BoxChartComponent_BaseFactory;
      return function BoxChartComponent_Factory(__ngFactoryType__) {
        return (\u0275BoxChartComponent_BaseFactory || (\u0275BoxChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BoxChartComponent)))(__ngFactoryType__ || _BoxChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BoxChartComponent,
      selectors: [["ngx-charts-box-chart"]],
      contentQueries: function BoxChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendPosition: "legendPosition",
        legendTitle: "legendTitle",
        legendOptionsConfig: "legendOptionsConfig",
        showGridLines: "showGridLines",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        roundDomains: "roundDomains",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        roundEdges: "roundEdges",
        strokeColor: "strokeColor",
        strokeWidth: "strokeWidth",
        tooltipDisabled: "tooltipDisabled",
        gradient: "gradient",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 23,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "animations"], [1, "box-chart", "chart"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "xScale", "showLabel", "labelText", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "yScale", "showLabel", "labelText", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-box-series", "", 3, "activate", "deactivate", "select", "xScale", "yScale", "colors", "roundEdges", "strokeColor", "strokeWidth", "tooltipDisabled", "tooltipTemplate", "series", "dims", "animations", "gradient"]],
      template: function BoxChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function BoxChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function BoxChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function BoxChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
          \u0275\u0275listener("dimensionsChanged", function BoxChartComponent_Template_g_dimensionsChanged_2_listener($event) {
            return ctx.updateXAxisHeight($event);
          });
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(3, "g", 3);
          \u0275\u0275listener("dimensionsChanged", function BoxChartComponent_Template_g_dimensionsChanged_3_listener($event) {
            return ctx.updateYAxisWidth($event);
          });
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g");
          \u0275\u0275template(5, BoxChartComponent__svg_g_5_Template, 2, 12, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(20, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("showGridLines", ctx.showGridLines)("dims", ctx.dims)("xScale", ctx.xScale)("showLabel", ctx.showXAxisLabel)("labelText", ctx.xAxisLabel)("wrapTicks", ctx.wrapTicks);
          \u0275\u0275advance();
          \u0275\u0275property("showGridLines", ctx.showGridLines)("dims", ctx.dims)("yScale", ctx.yScale)("showLabel", ctx.showYAxisLabel)("labelText", ctx.yAxisLabel)("wrapTicks", ctx.wrapTicks);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, XAxisComponent, YAxisComponent, ChartComponent, BoxSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-box-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g [attr.transform]="transform" class="box-chart chart">
        <svg:g
          ngx-charts-x-axis
          [showGridLines]="showGridLines"
          [dims]="dims"
          [xScale]="xScale"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        />
        <svg:g
          ngx-charts-y-axis
          [showGridLines]="showGridLines"
          [dims]="dims"
          [yScale]="yScale"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        />
      </svg:g>
      <svg:g [attr.transform]="transform">
        <svg:g *ngFor="let result of results; trackBy: trackBy">
          <svg:g
            ngx-charts-box-series
            [xScale]="xScale"
            [yScale]="yScale"
            [colors]="colors"
            [roundEdges]="roundEdges"
            [strokeColor]="strokeColor"
            [strokeWidth]="strokeWidth"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [series]="result"
            [dims]="dims"
            [animations]="animations"
            [gradient]="gradient"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
            (select)="onClick($event)"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendOptionsConfig: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate", {
        static: false
      }]
    }]
  });
})();
var BoxChartModule = class _BoxChartModule {
  static {
    this.\u0275fac = function BoxChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BoxChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _BoxChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BoxChartComponent, BoxSeriesComponent, BoxComponent],
      exports: [BoxChartComponent, BoxSeriesComponent, BoxComponent]
    }]
  }], null, null);
})();
function getDomain(values, scaleType, autoScale, minVal, maxVal) {
  let domain = [];
  if (scaleType === ScaleType.Linear) {
    values = values.map((v) => Number(v));
    if (!autoScale) {
      values.push(0);
    }
  }
  if (scaleType === ScaleType.Time || scaleType === ScaleType.Linear) {
    const min4 = minVal || minVal === 0 ? minVal : Math.min(...values);
    const max4 = maxVal ? maxVal : Math.max(...values);
    domain = [min4, max4];
  } else {
    domain = values;
  }
  return domain;
}
function getScale(domain, range2, scaleType, roundDomains) {
  switch (scaleType) {
    case ScaleType.Time:
      return time().range(range2).domain(domain);
    case ScaleType.Linear: {
      const scale = linear().range(range2).domain(domain);
      if (roundDomains) {
        return scale.nice();
      }
      return scale;
    }
    case ScaleType.Ordinal:
      return point().range([range2[0], range2[1]]).domain(domain.map((r) => r.toString()));
    default:
      return void 0;
  }
}
var BubbleSeriesComponent = class _BubbleSeriesComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.tooltipDisabled = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.circles = this.getCircles();
  }
  getCircles() {
    const seriesName = this.data.name;
    return this.data.series.map((d, i) => {
      if (typeof d.y !== "undefined" && typeof d.x !== "undefined") {
        const y2 = d.y;
        const x2 = d.x;
        const r = d.r;
        const radius = this.rScale(r || 1);
        const tooltipLabel = formatLabel(d.name);
        const cx = this.xScaleType === ScaleType.Linear ? this.xScale(Number(x2)) : this.xScale(x2);
        const cy = this.yScaleType === ScaleType.Linear ? this.yScale(Number(y2)) : this.yScale(y2);
        const color2 = this.colors.scaleType === ScaleType.Linear ? this.colors.getColor(r) : this.colors.getColor(seriesName);
        const isActive = !this.activeEntries.length ? true : this.isActive({
          name: seriesName
        });
        const opacity = isActive ? 1 : 0.3;
        const data = Object.assign({}, d, {
          series: seriesName,
          name: d.name,
          value: d.y,
          x: d.x,
          radius: d.r
        });
        return {
          data,
          x: x2,
          y: y2,
          r,
          classNames: [`circle-data-${i}`],
          value: y2,
          label: x2,
          cx,
          cy,
          radius,
          tooltipLabel,
          color: color2,
          opacity,
          seriesName,
          isActive,
          transform: `translate(${cx},${cy})`
        };
      }
    }).filter((circle) => circle !== void 0);
  }
  getTooltipText(circle) {
    const hasRadius = typeof circle.r !== "undefined";
    const hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
    const hasSeriesName = circle.seriesName && circle.seriesName.length;
    const radiusValue = hasRadius ? formatLabel(circle.r) : "";
    const xAxisLabel = this.xAxisLabel && this.xAxisLabel !== "" ? `${this.xAxisLabel}:` : "";
    const yAxisLabel = this.yAxisLabel && this.yAxisLabel !== "" ? `${this.yAxisLabel}:` : "";
    const x2 = formatLabel(circle.x);
    const y2 = formatLabel(circle.y);
    const name = hasSeriesName && hasTooltipLabel ? `${circle.seriesName} \u2022 ${circle.tooltipLabel}` : circle.seriesName + circle.tooltipLabel;
    const tooltipTitle = hasSeriesName || hasTooltipLabel ? `<span class="tooltip-label">${escapeLabel(name)}</span>` : "";
    return `
      ${tooltipTitle}
      <span class="tooltip-label">
        <label>${escapeLabel(xAxisLabel)}</label> ${escapeLabel(x2)}<br />
        <label>${escapeLabel(yAxisLabel)}</label> ${escapeLabel(y2)}
      </span>
      <span class="tooltip-val">
        ${escapeLabel(radiusValue)}
      </span>
    `;
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isVisible(circle) {
    if (this.activeEntries.length > 0) {
      return this.isActive({
        name: circle.seriesName
      });
    }
    return circle.opacity !== 0;
  }
  activateCircle(circle) {
    circle.barVisible = true;
    this.activate.emit({
      name: this.data.name
    });
  }
  deactivateCircle(circle) {
    circle.barVisible = false;
    this.deactivate.emit({
      name: this.data.name
    });
  }
  trackBy(index, circle) {
    return `${circle.data.series} ${circle.data.name}`;
  }
  static {
    this.\u0275fac = function BubbleSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BubbleSeriesComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BubbleSeriesComponent,
      selectors: [["g", "ngx-charts-bubble-series", ""]],
      inputs: {
        data: "data",
        xScale: "xScale",
        yScale: "yScale",
        rScale: "rScale",
        xScaleType: "xScaleType",
        yScaleType: "yScaleType",
        colors: "colors",
        visibleValue: "visibleValue",
        activeEntries: "activeEntries",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c32,
      decls: 1,
      vars: 2,
      consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", 3, "cx", "cy", "r", "fill", "opacity", "active", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
      template: function BubbleSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, BubbleSeriesComponent__svg_g_0_Template, 4, 3, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, CircleComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":enter", [style({
          opacity: 0,
          transform: "scale(0)"
        }), animate(250, style({
          opacity: 1,
          transform: "scale(1)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bubble-series]",
      template: `
    <svg:g *ngFor="let circle of circles; trackBy: trackBy">
      <svg:g [attr.transform]="circle.transform">
        <svg:g
          *ngIf="!isSSR"
          ngx-charts-circle
          [@animationState]="'active'"
          class="circle"
          [cx]="0"
          [cy]="0"
          [r]="circle.radius"
          [fill]="circle.color"
          [style.opacity]="circle.opacity"
          [class.active]="circle.isActive"
          [pointerEvents]="'all'"
          [data]="circle.value"
          [classNames]="circle.classNames"
          (select)="onClick(circle.data)"
          (activate)="activateCircle(circle)"
          (deactivate)="deactivateCircle(circle)"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipPlacement]="placementTypes.Top"
          [tooltipType]="styleTypes.tooltip"
          [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="circle.data"
        />
        <svg:g
          *ngIf="isSSR"
          ngx-charts-circle
          class="circle"
          [cx]="0"
          [cy]="0"
          [r]="circle.radius"
          [fill]="circle.color"
          [style.opacity]="circle.opacity"
          [class.active]="circle.isActive"
          [pointerEvents]="'all'"
          [data]="circle.value"
          [classNames]="circle.classNames"
          (select)="onClick(circle.data)"
          (activate)="activateCircle(circle)"
          (deactivate)="deactivateCircle(circle)"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipPlacement]="placementTypes.Top"
          [tooltipType]="styleTypes.tooltip"
          [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="circle.data"
        />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        opacity: 0,
        transform: "scale(0)"
      }), animate(250, style({
        opacity: 1,
        transform: "scale(1)"
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    rScale: [{
      type: Input
    }],
    xScaleType: [{
      type: Input
    }],
    yScaleType: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    visibleValue: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var BubbleChartComponent = class _BubbleChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.showGridLines = true;
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = true;
    this.yAxis = true;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.maxRadius = 10;
    this.minRadius = 3;
    this.schemeType = ScaleType.Ordinal;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.scaleType = ScaleType.Linear;
    this.margin = [10, 20, 10, 20];
    this.bubblePadding = [0, 0, 0, 0];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.activeEntries = [];
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.seriesDomain = this.results.map((d) => d.name);
    this.rDomain = this.getRDomain();
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.transform = `translate(${this.dims.xOffset},${this.margin[0]})`;
    const colorDomain = this.schemeType === ScaleType.Ordinal ? this.seriesDomain : this.rDomain;
    this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
    this.data = this.results;
    this.minRadius = Math.max(this.minRadius, 1);
    this.maxRadius = Math.max(this.maxRadius, 1);
    this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
    this.bubblePadding = [0, 0, 0, 0];
    this.setScales();
    this.bubblePadding = this.getBubblePadding();
    this.setScales();
    this.legendOptions = this.getLegendOptions();
    this.clipPathId = "clip" + id().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  hideCircles() {
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  getBubblePadding() {
    let yMin = 0;
    let xMin = 0;
    let yMax = this.dims.height;
    let xMax = this.dims.width;
    for (const s of this.data) {
      for (const d of s.series) {
        const r = this.rScale(d.r);
        const cx = this.xScaleType === ScaleType.Linear ? this.xScale(Number(d.x)) : this.xScale(d.x);
        const cy = this.yScaleType === ScaleType.Linear ? this.yScale(Number(d.y)) : this.yScale(d.y);
        xMin = Math.max(r - cx, xMin);
        yMin = Math.max(r - cy, yMin);
        yMax = Math.max(cy + r, yMax);
        xMax = Math.max(cx + r, xMax);
      }
    }
    xMax = Math.max(xMax - this.dims.width, 0);
    yMax = Math.max(yMax - this.dims.height, 0);
    return [yMin, xMax, yMax, xMin];
  }
  setScales() {
    let width = this.dims.width;
    if (this.xScaleMin === void 0 && this.xScaleMax === void 0) {
      width = width - this.bubblePadding[1];
    }
    let height = this.dims.height;
    if (this.yScaleMin === void 0 && this.yScaleMax === void 0) {
      height = height - this.bubblePadding[2];
    }
    this.xScale = this.getXScale(this.xDomain, width);
    this.yScale = this.getYScale(this.yDomain, height);
  }
  getYScale(domain, height) {
    return getScale(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
  }
  getXScale(domain, width) {
    return getScale(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
  }
  getRScale(domain, range2) {
    const scale = linear().range(range2).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      position: this.legendPosition,
      title: void 0
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.rDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  getXDomain() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.x)) {
          values.push(d.x);
        }
      }
    }
    this.xScaleType = getScaleType(values);
    return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
  }
  getYDomain() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.y)) {
          values.push(d.y);
        }
      }
    }
    this.yScaleType = getScaleType(values);
    return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
  }
  getRDomain() {
    let min4 = Infinity;
    let max4 = -Infinity;
    for (const results of this.results) {
      for (const d of results.series) {
        const value2 = Number(d.r) || 1;
        min4 = Math.min(min4, value2);
        max4 = Math.max(max4, value2);
      }
    }
    return [min4, max4];
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BubbleChartComponent_BaseFactory;
      return function BubbleChartComponent_Factory(__ngFactoryType__) {
        return (\u0275BubbleChartComponent_BaseFactory || (\u0275BubbleChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BubbleChartComponent)))(__ngFactoryType__ || _BubbleChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BubbleChartComponent,
      selectors: [["ngx-charts-bubble-chart"]],
      contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() {
            return ctx.hideCircles();
          });
        }
      },
      inputs: {
        showGridLines: "showGridLines",
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        roundDomains: "roundDomains",
        maxRadius: "maxRadius",
        minRadius: "minRadius",
        autoScale: "autoScale",
        schemeType: "schemeType",
        tooltipDisabled: "tooltipDisabled",
        xScaleMin: "xScaleMin",
        xScaleMax: "xScaleMax",
        yScaleMin: "yScaleMin",
        yScaleMax: "yScaleMax",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 10,
      vars: 19,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "activeEntries", "legendOptions", "animations"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "'auto'", 3, "mouseenter"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bubble-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate"]],
      template: function BubbleChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "defs")(2, "clipPath");
          \u0275\u0275element(3, "rect");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g", 1);
          \u0275\u0275template(5, BubbleChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, BubbleChartComponent__svg_g_6_Template, 1, 10, "g", 3);
          \u0275\u0275elementStart(7, "rect", 4);
          \u0275\u0275listener("mouseenter", function BubbleChartComponent_Template_rect_mouseenter_7_listener() {
            return ctx.deactivateAll();
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(8, BubbleChartComponent__svg_g_8_Template, 2, 3, "g", 5)(9, BubbleChartComponent__svg_g_9_Template, 2, 3, "g", 5);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(16, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("id", ctx.clipPathId);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width)("height", ctx.dims.height);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, BubbleSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bubble-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [activeEntries]="activeEntries"
      [legendOptions]="legendOptions"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="bubble-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [showGridLines]="showGridLines"
          [dims]="dims"
          [xScale]="xScale"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        />
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [showGridLines]="showGridLines"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        />
        <svg:rect
          class="bubble-chart-area"
          x="0"
          y="0"
          [attr.width]="dims.width"
          [attr.height]="dims.height"
          style="fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';"
          (mouseenter)="deactivateAll()"
        />
        <svg:g *ngIf="!isSSR" [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of data; trackBy: trackBy" [@animationState]="'active'">
            <svg:g
              ngx-charts-bubble-series
              [xScale]="xScale"
              [yScale]="yScale"
              [rScale]="rScale"
              [xScaleType]="xScaleType"
              [yScaleType]="yScaleType"
              [xAxisLabel]="xAxisLabel"
              [yAxisLabel]="yAxisLabel"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event, series)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR" [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of data; trackBy: trackBy">
            <svg:g
              ngx-charts-bubble-series
              [xScale]="xScale"
              [yScale]="yScale"
              [rScale]="rScale"
              [xScaleType]="xScaleType"
              [yScaleType]="yScaleType"
              [xAxisLabel]="xAxisLabel"
              [yAxisLabel]="yAxisLabel"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event, series)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    showGridLines: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    maxRadius: [{
      type: Input
    }],
    minRadius: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var BubbleChartModule = class _BubbleChartModule {
  static {
    this.\u0275fac = function BubbleChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BubbleChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _BubbleChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BubbleChartComponent, BubbleSeriesComponent],
      exports: [BubbleChartComponent, BubbleSeriesComponent]
    }]
  }], null, null);
})();
var HeatMapCellComponent = class _HeatMapCellComponent {
  constructor(element) {
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.barOrientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.transform = `translate(${this.x} , ${this.y})`;
    this.startOpacity = 0.3;
    this.gradientId = "grad" + id().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    this.gradientStops = this.getGradientStops();
    if (this.animations) {
      this.loadAnimation();
    }
  }
  getGradientStops() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.startOpacity
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  loadAnimation() {
    const node = select_default(this.element).select(".cell");
    node.attr("opacity", 0);
    this.animateToCurrentForm();
  }
  animateToCurrentForm() {
    const node = select_default(this.element).select(".cell");
    node.transition().duration(750).attr("opacity", 1);
  }
  onClick() {
    this.select.emit(this.data);
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  static {
    this.\u0275fac = function HeatMapCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HeatMapCellComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _HeatMapCellComponent,
      selectors: [["g", "ngx-charts-heat-map-cell", ""]],
      hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() {
            return ctx.onMouseEnter();
          })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() {
            return ctx.onMouseLeave();
          });
        }
      },
      inputs: {
        fill: "fill",
        x: "x",
        y: "y",
        width: "width",
        height: "height",
        data: "data",
        gradient: "gradient",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c33,
      decls: 3,
      vars: 5,
      consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
      template: function HeatMapCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0);
          \u0275\u0275template(1, HeatMapCellComponent__svg_defs_1_Template, 2, 3, "defs", 1);
          \u0275\u0275elementStart(2, "rect", 2);
          \u0275\u0275listener("click", function HeatMapCellComponent_Template_rect_click_2_listener() {
            return ctx.onClick();
          });
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.gradient);
          \u0275\u0275advance();
          \u0275\u0275attribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
        }
      },
      dependencies: [NgIf, SvgLinearGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapCellComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-heat-map-cell]",
      template: `
    <svg:g [attr.transform]="transform" class="cell">
      <defs *ngIf="gradient">
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:rect
        [attr.fill]="gradient ? gradientUrl : fill"
        rx="3"
        [attr.width]="width"
        [attr.height]="height"
        class="cell"
        (click)="onClick()"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var HeatCellSeriesComponent = class _HeatCellSeriesComponent {
  constructor() {
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnInit() {
    if (!this.tooltipText) {
      this.tooltipText = this.getTooltipText;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.cells = this.getCells();
  }
  getCells() {
    const cells = [];
    this.data.map((row) => {
      row.series.map((cell) => {
        const value2 = cell.value;
        cell.series = row.name;
        cells.push({
          row,
          cell,
          x: this.xScale(row.name),
          y: this.yScale(cell.name),
          width: this.xScale.bandwidth(),
          height: this.yScale.bandwidth(),
          fill: this.colors.getColor(value2),
          data: value2,
          label: formatLabel(cell.name),
          series: row.name
        });
      });
    });
    return cells;
  }
  getTooltipText({
    label,
    data,
    series
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(series)} \u2022 ${escapeLabel(label)}</span>
      <span class="tooltip-val">${data.toLocaleString()}</span>
    `;
  }
  trackBy(index, item) {
    return item.label;
  }
  onClick(data) {
    this.select.emit(data);
  }
  static {
    this.\u0275fac = function HeatCellSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HeatCellSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _HeatCellSeriesComponent,
      selectors: [["g", "ngx-charts-heat-map-cell-series", ""]],
      inputs: {
        data: "data",
        colors: "colors",
        xScale: "xScale",
        yScale: "yScale",
        gradient: "gradient",
        tooltipDisabled: "tooltipDisabled",
        tooltipText: "tooltipText",
        tooltipTemplate: "tooltipTemplate",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c34,
      decls: 1,
      vars: 2,
      consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
      template: function HeatCellSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, TooltipDirective, HeatMapCellComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatCellSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-heat-map-cell-series]",
      template: `
    <svg:g
      ngx-charts-heat-map-cell
      *ngFor="let c of cells; trackBy: trackBy"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [fill]="c.fill"
      [data]="c.data"
      (select)="onClick(c.cell)"
      (activate)="activate.emit(c.cell)"
      (deactivate)="deactivate.emit(c.cell)"
      [gradient]="gradient"
      [animations]="animations"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(c)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="{ series: c.series, name: c.label, value: c.data }"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var HeatMapComponent = class _HeatMapComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.innerPadding = 8;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.tooltipDisabled = false;
    this.activeEntries = [];
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.scaleType = ScaleType.Linear;
  }
  update() {
    super.update();
    this.formatDates();
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.valueDomain = this.getValueDomain();
    this.scaleType = getScaleType(this.valueDomain, false);
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.scaleType,
      legendPosition: this.legendPosition
    });
    if (this.scaleType === ScaleType.Linear) {
      let min4 = this.min;
      let max4 = this.max;
      if (!this.min) {
        min4 = Math.min(0, ...this.valueDomain);
      }
      if (!this.max) {
        max4 = Math.max(...this.valueDomain);
      }
      this.valueDomain = [min4, max4];
    }
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.rects = this.getRects();
  }
  getXDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.name)) {
        domain.push(group.name);
      }
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.name)) {
          domain.push(d.name);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    return domain;
  }
  /**
   * Converts the input to gap paddingInner in fraction
   * Supports the following inputs:
   *    Numbers: 8
   *    Strings: "8", "8px", "8%"
   *    Arrays: [8,2], "8,2", "[8,2]"
   *    Mixed: [8,"2%"], ["8px","2%"], "8,2%", "[8,2%]"
   *
   * @memberOf HeatMapComponent
   */
  getDimension(value2, index = 0, N, L) {
    if (typeof value2 === "string") {
      value2 = value2.replace("[", "").replace("]", "").replace("px", "").replace("'", "");
      if (value2.includes(",")) {
        value2 = value2.split(",");
      }
    }
    if (Array.isArray(value2) && typeof index === "number") {
      return this.getDimension(value2[index], null, N, L);
    }
    if (typeof value2 === "string" && value2.includes("%")) {
      return +value2.replace("%", "") / 100;
    }
    return N / (L / +value2 + 1);
  }
  getXScale() {
    const f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
    return band().rangeRound([0, this.dims.width]).domain(this.xDomain).paddingInner(f);
  }
  getYScale() {
    const f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
    return band().rangeRound([this.dims.height, 0]).domain(this.yDomain).paddingInner(f);
  }
  getRects() {
    const rects = [];
    this.xDomain.map((xVal) => {
      this.yDomain.map((yVal) => {
        rects.push({
          x: this.xScale(xVal),
          y: this.yScale(yVal),
          rx: 3,
          width: this.xScale.bandwidth(),
          height: this.yScale.bandwidth(),
          fill: "rgba(200,200,200,0.03)"
        });
      });
    });
    return rects;
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
  }
  getLegendOptions() {
    return {
      scaleType: this.scaleType,
      domain: this.valueDomain,
      colors: this.scaleType === ScaleType.Ordinal ? this.colors : this.colors.scale,
      title: this.scaleType === ScaleType.Ordinal ? this.legendTitle : void 0,
      position: this.legendPosition
    };
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g) => g.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275HeatMapComponent_BaseFactory;
      return function HeatMapComponent_Factory(__ngFactoryType__) {
        return (\u0275HeatMapComponent_BaseFactory || (\u0275HeatMapComponent_BaseFactory = \u0275\u0275getInheritedFactory(_HeatMapComponent)))(__ngFactoryType__ || _HeatMapComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _HeatMapComponent,
      selectors: [["ngx-charts-heat-map"]],
      contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        gradient: "gradient",
        innerPadding: "innerPadding",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        tooltipDisabled: "tooltipDisabled",
        tooltipText: "tooltipText",
        min: "min",
        max: "max",
        activeEntries: "activeEntries",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 20,
      consts: [[3, "legendLabelClick", "view", "showLegend", "animations", "legendOptions"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"]],
      template: function HeatMapComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, HeatMapComponent__svg_g_2_Template, 1, 10, "g", 2)(3, HeatMapComponent__svg_g_3_Template, 1, 9, "g", 3)(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
          \u0275\u0275elementStart(5, "g", 5);
          \u0275\u0275listener("select", function HeatMapComponent_Template_g_select_5_listener($event) {
            return ctx.onClick($event);
          })("activate", function HeatMapComponent_Template_g_activate_5_listener($event) {
            return ctx.onActivate($event, void 0);
          })("deactivate", function HeatMapComponent_Template_g_deactivate_5_listener($event) {
            return ctx.onDeactivate($event, void 0);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.rects);
          \u0275\u0275advance();
          \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, HeatCellSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-heat-map",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [animations]="animations"
      [legendOptions]="legendOptions"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="heat-map chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:rect
          *ngFor="let rect of rects"
          [attr.x]="rect.x"
          [attr.y]="rect.y"
          [attr.rx]="rect.rx"
          [attr.width]="rect.width"
          [attr.height]="rect.height"
          [attr.fill]="rect.fill"
        />
        <svg:g
          ngx-charts-heat-map-cell-series
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [data]="results"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (select)="onClick($event)"
          (activate)="onActivate($event, undefined)"
          (deactivate)="onDeactivate($event, undefined)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var HeatMapModule = class _HeatMapModule {
  static {
    this.\u0275fac = function HeatMapModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HeatMapModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _HeatMapModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent],
      exports: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent]
    }]
  }], null, null);
})();
var LineComponent = class _LineComponent {
  constructor(element, platformId) {
    this.element = element;
    this.platformId = platformId;
    this.fill = "none";
    this.animations = true;
    this.initialized = false;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    if (!this.initialized) {
      this.initialized = true;
      this.initialPath = this.path;
    } else {
      this.updatePathEl();
    }
  }
  updatePathEl() {
    const node = select_default(this.element.nativeElement).select(".line");
    if (this.animations) {
      node.transition().duration(750).attr("d", this.path);
    } else {
      node.attr("d", this.path);
    }
  }
  static {
    this.\u0275fac = function LineComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LineComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LineComponent,
      selectors: [["g", "ngx-charts-line", ""]],
      inputs: {
        path: "path",
        stroke: "stroke",
        data: "data",
        fill: "fill",
        animations: "animations"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c36,
      decls: 2,
      vars: 2,
      consts: [[4, "ngIf"], ["stroke-width", "1.5px", 1, "line"]],
      template: function LineComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, LineComponent__svg_g_0_Template, 2, 4, "g", 0)(1, LineComponent__svg_g_1_Template, 2, 3, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgIf],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":enter", [style({
          strokeDasharray: 2e3,
          strokeDashoffset: 2e3
        }), animate(1e3, style({
          strokeDashoffset: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-line]",
      template: `
    <svg:g *ngIf="!isSSR">
      <svg:path
        [@animationState]="'active'"
        class="line"
        [attr.d]="initialPath"
        [attr.fill]="fill"
        [attr.stroke]="stroke"
        stroke-width="1.5px"
      />
    </svg:g>
    <svg:g *ngIf="isSSR">
      <svg:path class="line" [attr.d]="initialPath" [attr.fill]="fill" [attr.stroke]="stroke" stroke-width="1.5px" />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        strokeDasharray: 2e3,
        strokeDashoffset: 2e3
      }), animate(1e3, style({
        strokeDashoffset: 0
      }))])])]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    path: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    animations: [{
      type: Input
    }]
  });
})();
var LineSeriesComponent = class _LineSeriesComponent {
  constructor() {
    this.animations = true;
    this.barOrientation = BarOrientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradients();
    const data = this.sortData(this.data.series);
    const lineGen = this.getLineGenerator();
    this.path = lineGen(data) || "";
    const areaGen = this.getAreaGenerator();
    this.areaPath = areaGen(data) || "";
    if (this.hasRange) {
      const range2 = this.getRangeGenerator();
      this.outerPath = range2(data) || "";
    }
    if (this.hasGradient) {
      this.stroke = this.gradientUrl;
      const values = this.data.series.map((d) => d.value);
      const max4 = Math.max(...values);
      const min4 = Math.min(...values);
      if (max4 === min4) {
        this.stroke = this.colors.getColor(max4);
      }
    } else {
      this.stroke = this.colors.getColor(this.data.name);
    }
  }
  getLineGenerator() {
    return line_default().x((d) => {
      const label = d.name;
      let value2;
      if (this.scaleType === ScaleType.Time) {
        value2 = this.xScale(label);
      } else if (this.scaleType === ScaleType.Linear) {
        value2 = this.xScale(Number(label));
      } else {
        value2 = this.xScale(label);
      }
      return value2;
    }).y((d) => this.yScale(d.value)).curve(this.curve);
  }
  getRangeGenerator() {
    return area_default().x((d) => {
      const label = d.name;
      let value2;
      if (this.scaleType === ScaleType.Time) {
        value2 = this.xScale(label);
      } else if (this.scaleType === ScaleType.Linear) {
        value2 = this.xScale(Number(label));
      } else {
        value2 = this.xScale(label);
      }
      return value2;
    }).y0((d) => this.yScale(typeof d.min === "number" ? d.min : d.value)).y1((d) => this.yScale(typeof d.max === "number" ? d.max : d.value)).curve(this.curve);
  }
  getAreaGenerator() {
    const xProperty = (d) => {
      const label = d.name;
      return this.xScale(label);
    };
    return area_default().x(xProperty).y0(() => this.yScale.range()[0]).y1((d) => this.yScale(d.value)).curve(this.curve);
  }
  sortData(data) {
    if (this.scaleType === ScaleType.Linear) {
      data = sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      data = sortByTime(data, "name");
    } else {
      data = sortByDomain(data, "name", "asc", this.xScale.domain());
    }
    return data;
  }
  updateGradients() {
    if (this.colors.scaleType === ScaleType.Linear) {
      this.hasGradient = true;
      this.gradientId = "grad" + id().toString();
      this.gradientUrl = `url(#${this.gradientId})`;
      const values = this.data.series.map((d) => d.value);
      const max4 = Math.max(...values);
      const min4 = Math.min(...values);
      this.gradientStops = this.colors.getLinearGradientStops(max4, min4);
      this.areaGradientStops = this.colors.getLinearGradientStops(max4);
    } else {
      this.hasGradient = false;
      this.gradientStops = void 0;
      this.areaGradientStops = void 0;
    }
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
  static {
    this.\u0275fac = function LineSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LineSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LineSeriesComponent,
      selectors: [["g", "ngx-charts-line-series", ""]],
      inputs: {
        data: "data",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        scaleType: "scaleType",
        curve: "curve",
        activeEntries: "activeEntries",
        rangeFillOpacity: "rangeFillOpacity",
        hasRange: "hasRange",
        animations: "animations"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c37,
      decls: 6,
      vars: 22,
      consts: [["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]],
      template: function LineSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g")(1, "defs");
          \u0275\u0275template(2, LineSeriesComponent__svg_g_2_Template, 1, 3, "g", 0);
          \u0275\u0275elementEnd();
          \u0275\u0275element(3, "g", 1)(4, "g", 2);
          \u0275\u0275template(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("ngIf", ctx.hasGradient);
          \u0275\u0275advance();
          \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
          \u0275\u0275property("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
          \u0275\u0275property("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.hasRange);
        }
      },
      dependencies: [NgIf, AreaComponent, SvgLinearGradientComponent, LineComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-line-series]",
      template: `
    <svg:g>
      <defs>
        <svg:g
          ngx-charts-svg-linear-gradient
          *ngIf="hasGradient"
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:g
        ngx-charts-area
        class="line-highlight"
        [data]="data"
        [path]="areaPath"
        [fill]="hasGradient ? gradientUrl : colors.getColor(data.name)"
        [opacity]="0.25"
        [startOpacity]="0"
        [gradient]="true"
        [stops]="areaGradientStops"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
        [animations]="animations"
      />
      <svg:g
        ngx-charts-line
        class="line-series"
        [data]="data"
        [path]="path"
        [stroke]="stroke"
        [animations]="animations"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
      />
      <svg:g
        ngx-charts-area
        *ngIf="hasRange"
        class="line-series-range"
        [data]="data"
        [path]="outerPath"
        [fill]="hasGradient ? gradientUrl : colors.getColor(data.name)"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
        [opacity]="rangeFillOpacity"
        [animations]="animations"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    hasRange: [{
      type: Input
    }],
    animations: [{
      type: Input
    }]
  });
})();
var LineChartComponent = class _LineChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.showRefLines = false;
    this.showRefLabels = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min4;
    let max4;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min4 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max4 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min4), new Date(max4)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min4, max4];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
        if (d.min !== void 0) {
          this.hasRange = true;
          if (domain.indexOf(d.min) < 0) {
            domain.push(d.min);
          }
        }
        if (d.max !== void 0) {
          this.hasRange = true;
          if (domain.indexOf(d.max) < 0) {
            domain.push(d.max);
          }
        }
      }
    }
    const values = [...domain];
    if (!this.autoScale) {
      values.push(0);
    }
    const min4 = this.yScaleMin ? this.yScaleMin : Math.min(...values);
    const max4 = this.yScaleMax ? this.yScaleMax : Math.max(...values);
    return [min4, max4];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time().range([0, width]).domain(domain);
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear().range([0, width]).domain(domain);
      if (this.roundDomains) {
        scale = scale.nice();
      }
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().range([0, width]).padding(0.1).domain(domain);
    }
    return scale;
  }
  getYScale(domain, height) {
    const scale = linear().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data) {
    this.select.emit(data);
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    this.deactivateAll();
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275LineChartComponent_BaseFactory;
      return function LineChartComponent_Factory(__ngFactoryType__) {
        return (\u0275LineChartComponent_BaseFactory || (\u0275LineChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_LineChartComponent)))(__ngFactoryType__ || _LineChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LineChartComponent,
      selectors: [["ngx-charts-line-chart"]],
      contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
          \u0275\u0275contentQuery(dirIndex, _c23, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
        }
      },
      hostBindings: function LineChartComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() {
            return ctx.hideCircles();
          });
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        autoScale: "autoScale",
        timeline: "timeline",
        gradient: "gradient",
        showGridLines: "showGridLines",
        curve: "curve",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        rangeFillOpacity: "rangeFillOpacity",
        trimXAxisTicks: "trimXAxisTicks",
        trimYAxisTicks: "trimYAxisTicks",
        rotateXAxisTicks: "rotateXAxisTicks",
        maxXAxisTickLength: "maxXAxisTickLength",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        xAxisTicks: "xAxisTicks",
        yAxisTicks: "yAxisTicks",
        roundDomains: "roundDomains",
        tooltipDisabled: "tooltipDisabled",
        showRefLines: "showRefLines",
        referenceLines: "referenceLines",
        showRefLabels: "showRefLabels",
        xScaleMin: "xScaleMin",
        xScaleMax: "xScaleMax",
        yScaleMin: "yScaleMin",
        yScaleMax: "yScaleMax",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 12,
      vars: 20,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "scaleType", "legend"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]],
      template: function LineChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "defs")(2, "clipPath");
          \u0275\u0275element(3, "rect");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "g", 1);
          \u0275\u0275template(5, LineChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, LineChartComponent__svg_g_6_Template, 1, 13, "g", 3);
          \u0275\u0275elementStart(7, "g");
          \u0275\u0275template(8, LineChartComponent__svg_g_8_Template, 2, 2, "g", 4)(9, LineChartComponent__svg_g_9_Template, 2, 2, "g", 4)(10, LineChartComponent__svg_g_10_Template, 3, 9, "g", 5);
          \u0275\u0275elementEnd()();
          \u0275\u0275template(11, LineChartComponent__svg_g_11_Template, 2, 13, "g", 6);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("id", ctx.clipPathId);
          \u0275\u0275advance();
          \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275attribute("clip-path", ctx.clipPath);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
        }
      },
      dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, LineSeriesComponent],
      styles: [_c25],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-line-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="line-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [referenceLines]="referenceLines"
          [showRefLines]="showRefLines"
          [showRefLabels]="showRefLabels"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngIf="!isSSR">
            <svg:g *ngFor="let series of results; trackBy: trackBy" [@animationState]="'active'">
              <svg:g
                ngx-charts-line-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [activeEntries]="activeEntries"
                [scaleType]="scaleType"
                [curve]="curve"
                [rangeFillOpacity]="rangeFillOpacity"
                [hasRange]="hasRange"
                [animations]="animations"
              />
            </svg:g>
          </svg:g>
          <svg:g *ngIf="isSSR">
            <svg:g *ngFor="let series of results; trackBy: trackBy">
              <svg:g
                ngx-charts-line-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [activeEntries]="activeEntries"
                [scaleType]="scaleType"
                [curve]="curve"
                [rangeFillOpacity]="rangeFillOpacity"
                [hasRange]="hasRange"
                [animations]="animations"
              />
            </svg:g>
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [activeEntries]="activeEntries"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [scaleType]="scaleType"
        [legend]="legend"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-line-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [curve]="curve"
            [hasRange]="hasRange"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var LineChartModule = class _LineChartModule {
  static {
    this.\u0275fac = function LineChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LineChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _LineChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [LineComponent, LineChartComponent, LineSeriesComponent],
      exports: [LineComponent, LineChartComponent, LineSeriesComponent]
    }]
  }], null, null);
})();
var PieLabelComponent = class _PieLabelComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.animations = true;
    this.labelTrim = true;
    this.labelTrimSize = 10;
    this.trimLabel = trimLabel;
  }
  ngOnChanges(changes) {
    this.setTransforms();
    this.update();
  }
  setTransforms() {
    if (isPlatformServer(this.platformId)) {
      this.styleTransform = `translate3d(${this.textX}px,${this.textY}px, 0)`;
      this.attrTransform = `translate(${this.textX},${this.textY})`;
      this.textTransition = !this.animations ? null : "transform 0.75s";
    } else {
      const isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
      this.styleTransform = isIE ? null : `translate3d(${this.textX}px,${this.textY}px, 0)`;
      this.attrTransform = !isIE ? null : `translate(${this.textX},${this.textY})`;
      this.textTransition = isIE || !this.animations ? null : "transform 0.75s";
    }
  }
  update() {
    let startRadius = this.radius;
    if (this.explodeSlices) {
      startRadius = this.radius * this.value / this.max;
    }
    const innerArc = arc_default().innerRadius(startRadius).outerRadius(startRadius);
    const innerPos = innerArc.centroid(this.data);
    let scale = this.data.pos[1] / innerPos[1];
    if (this.data.pos[1] === 0 || innerPos[1] === 0) {
      scale = 1;
    }
    const outerPos = [scale * innerPos[0], scale * innerPos[1]];
    this.line = `M${innerPos}L${outerPos}L${this.data.pos}`;
  }
  get textX() {
    return this.data.pos[0];
  }
  get textY() {
    return this.data.pos[1];
  }
  textAnchor() {
    return this.midAngle(this.data) < Math.PI ? TextAnchor.Start : TextAnchor.End;
  }
  midAngle(d) {
    return d.startAngle + (d.endAngle - d.startAngle) / 2;
  }
  static {
    this.\u0275fac = function PieLabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PieLabelComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieLabelComponent,
      selectors: [["g", "ngx-charts-pie-label", ""]],
      inputs: {
        data: "data",
        radius: "radius",
        label: "label",
        color: "color",
        max: "max",
        value: "value",
        explodeSlices: "explodeSlices",
        animations: "animations",
        labelTrim: "labelTrim",
        labelTrimSize: "labelTrimSize"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c38,
      decls: 6,
      vars: 17,
      consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]],
      template: function PieLabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "title");
          \u0275\u0275text(1);
          \u0275\u0275elementEnd();
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(2, "g")(3, "text", 0);
          \u0275\u0275text(4);
          \u0275\u0275elementEnd()();
          \u0275\u0275element(5, "path", 1);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275textInterpolate(ctx.label);
          \u0275\u0275advance();
          \u0275\u0275styleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
          \u0275\u0275attribute("transform", ctx.attrTransform);
          \u0275\u0275advance();
          \u0275\u0275styleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
          \u0275\u0275classProp("animation", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
          \u0275\u0275advance();
          \u0275\u0275classProp("animation", ctx.animations);
          \u0275\u0275attribute("d", ctx.line)("stroke", ctx.color);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-label]",
      template: `
    <title>{{ label }}</title>
    <svg:g [attr.transform]="attrTransform" [style.transform]="styleTransform" [style.transition]="textTransition">
      <svg:text
        class="pie-label"
        [class.animation]="animations"
        dy=".35em"
        [style.textAnchor]="textAnchor()"
        [style.shapeRendering]="'crispEdges'"
      >
        {{ labelTrim ? trimLabel(label, labelTrimSize) : label }}
      </svg:text>
    </svg:g>
    <svg:path
      [attr.d]="line"
      [attr.stroke]="color"
      fill="none"
      class="pie-label-line line"
      [class.animation]="animations"
    ></svg:path>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    radius: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    labelTrim: [{
      type: Input
    }],
    labelTrimSize: [{
      type: Input
    }]
  });
})();
var PolarSeriesComponent = class _PolarSeriesComponent {
  constructor() {
    this.tooltipDisabled = false;
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.circleRadius = 3;
    this.barOrientation = BarOrientation;
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradients();
    const line = this.getLineGenerator();
    const data = this.sortData(this.data.series);
    const seriesName = this.data.name;
    const linearScaleType = this.colors.scaleType === ScaleType.Linear;
    const min4 = this.yScale.domain()[0];
    this.seriesColor = this.colors.getColor(linearScaleType ? min4 : seriesName);
    this.path = line(data) || "";
    this.circles = data.map((d) => {
      const a = this.getAngle(d);
      const r = this.getRadius(d);
      const value2 = d.value;
      const color2 = this.colors.getColor(linearScaleType ? Math.abs(value2) : seriesName);
      const cData = Object.assign({}, d, {
        series: seriesName,
        value: value2,
        name: d.name
      });
      return {
        data: cData,
        cx: r * Math.sin(a),
        cy: -r * Math.cos(a),
        value: value2,
        color: color2,
        label: d.name
      };
    });
    this.active = this.isActive(this.data);
    this.inactive = this.isInactive(this.data);
    this.tooltipText = this.tooltipText || ((c) => this.defaultTooltipText(c));
  }
  getAngle(d) {
    const label = d.name;
    if (this.scaleType === ScaleType.Time) {
      return this.xScale(label);
    } else if (this.scaleType === ScaleType.Linear) {
      return this.xScale(Number(label));
    }
    return this.xScale(label);
  }
  getRadius(d) {
    return this.yScale(d.value);
  }
  getLineGenerator() {
    return lineRadial_default().angle((d) => this.getAngle(d)).radius((d) => this.getRadius(d)).curve(this.curve);
  }
  sortData(data) {
    if (this.scaleType === ScaleType.Linear) {
      return sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      return sortByTime(data, "name");
    }
    return sortByDomain(data, "name", "asc", this.xScale.domain());
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
  defaultTooltipText({
    label,
    value: value2
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(this.data.name)} \u2022 ${escapeLabel(label)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}</span>
    `;
  }
  updateGradients() {
    this.hasGradient = this.gradient || this.colors.scaleType === ScaleType.Linear;
    if (!this.hasGradient) {
      return;
    }
    this.gradientId = "grad" + id().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    if (this.colors.scaleType === ScaleType.Linear) {
      const values = this.data.series.map((d) => d.value);
      const max4 = Math.max(...values);
      const min4 = Math.min(...values);
      this.gradientStops = this.colors.getLinearGradientStops(max4, min4);
    } else {
      this.gradientStops = void 0;
    }
  }
  static {
    this.\u0275fac = function PolarSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PolarSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PolarSeriesComponent,
      selectors: [["g", "ngx-charts-polar-series", ""]],
      inputs: {
        name: "name",
        data: "data",
        xScale: "xScale",
        yScale: "yScale",
        colors: "colors",
        scaleType: "scaleType",
        curve: "curve",
        activeEntries: "activeEntries",
        rangeFillOpacity: "rangeFillOpacity",
        tooltipDisabled: "tooltipDisabled",
        tooltipText: "tooltipText",
        gradient: "gradient",
        tooltipTemplate: "tooltipTemplate",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c39,
      decls: 5,
      vars: 11,
      consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
      template: function PolarSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0)(1, "defs");
          \u0275\u0275template(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
          \u0275\u0275elementEnd();
          \u0275\u0275element(3, "g", 2);
          \u0275\u0275template(4, PolarSeriesComponent__svg_g_4_Template, 1, 12, "g", 3);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("ngIf", ctx.hasGradient);
          \u0275\u0275advance();
          \u0275\u0275classProp("active", ctx.active)("inactive", ctx.inactive);
          \u0275\u0275property("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
          \u0275\u0275attribute("fill-opacity", ctx.rangeFillOpacity);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.circles);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, CircleComponent, SvgRadialGradientComponent, LineComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-polar-series]",
      template: `
    <svg:g class="polar-charts-series">
      <defs>
        <svg:g
          ngx-charts-svg-radial-gradient
          *ngIf="hasGradient"
          [color]="seriesColor"
          [name]="gradientId"
          [startOpacity]="0.25"
          [endOpacity]="1"
          [stops]="gradientStops"
        />
      </defs>
      <svg:g
        ngx-charts-line
        class="polar-series-path"
        [path]="path"
        [stroke]="hasGradient ? gradientUrl : seriesColor"
        [class.active]="active"
        [class.inactive]="inactive"
        [attr.fill-opacity]="rangeFillOpacity"
        [fill]="hasGradient ? gradientUrl : seriesColor"
        [animations]="animations"
      />
      <svg:g
        ngx-charts-circle
        *ngFor="let circle of circles"
        class="circle"
        [cx]="circle.cx"
        [cy]="circle.cy"
        [r]="circleRadius"
        [fill]="circle.color"
        [style.opacity]="inactive ? 0.2 : 1"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(circle)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="circle.data"
        (select)="select.emit(circle.data)"
        (activate)="activate.emit({ name: circle.data.series })"
        (deactivate)="deactivate.emit({ name: circle.data.series })"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    name: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var twoPI = 2 * Math.PI;
var PolarChartComponent = class _PolarChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showGridLines = true;
    this.curve = cardinalClosed_default;
    this.activeEntries = [];
    this.rangeFillOpacity = 0.15;
    this.trimYAxisTicks = true;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.showSeriesOnHover = true;
    this.gradient = false;
    this.yAxisMinScale = 0;
    this.labelTrim = true;
    this.labelTrimSize = 10;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.orientation = Orientation;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.setDims();
    this.setScales();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.setTicks();
  }
  setDims() {
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    const halfWidth = Math.floor(this.dims.width / 2);
    const halfHeight = Math.floor(this.dims.height / 2);
    const outerRadius = this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5);
    const yOffset = Math.max(0, halfHeight - outerRadius);
    this.yAxisDims = __spreadProps(__spreadValues({}, this.dims), {
      width: halfWidth
    });
    this.transform = `translate(${this.dims.xOffset}, ${this.margin[0]})`;
    this.transformYAxis = `translate(0, ${yOffset})`;
    this.labelOffset = this.dims.height + 40;
    this.transformPlot = `translate(${halfWidth}, ${halfHeight})`;
  }
  setScales() {
    const xValues = this.getXValues();
    this.scaleType = getScaleType(xValues);
    this.xDomain = this.filteredDomain || this.getXDomain(xValues);
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, twoPI);
    this.yScale = this.getYScale(this.yDomain, this.outerRadius);
    this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
  }
  setTicks() {
    let tickFormat;
    if (this.xAxisTickFormatting) {
      tickFormat = this.xAxisTickFormatting;
    } else if (this.xScale.tickFormat) {
      tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
    } else {
      tickFormat = (d) => {
        if (isDate(d)) {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    const outerRadius = this.outerRadius;
    const s = 1.1;
    this.thetaTicks = this.xDomain.map((d) => {
      const startAngle = this.xScale(d);
      const dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
      const label = tickFormat(d);
      const startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
      const pos = [dd, s * startPos[1]];
      return {
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle: startAngle,
        value: outerRadius,
        label,
        startPos,
        pos
      };
    });
    const minDistance = 10;
    for (let i = 0; i < this.thetaTicks.length - 1; i++) {
      const a = this.thetaTicks[i];
      for (let j = i + 1; j < this.thetaTicks.length; j++) {
        const b = this.thetaTicks[j];
        if (b.pos[0] * a.pos[0] > 0) {
          const o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
          if (o > 0) {
            b.pos[1] += Math.sign(b.pos[0]) * o;
          }
        }
      }
    }
    this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map((d) => this.yScale(d));
  }
  getXValues() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.name)) {
          values.push(d.name);
        }
      }
    }
    return values;
  }
  getXDomain(values = this.getXValues()) {
    if (this.scaleType === ScaleType.Time) {
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      return [min4, max4];
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min4 = Math.min(...values);
      const max4 = Math.max(...values);
      return [min4, max4];
    }
    return values;
  }
  getYValues() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
        if (d.min !== void 0) {
          if (domain.indexOf(d.min) < 0) {
            domain.push(d.min);
          }
        }
        if (d.max !== void 0) {
          if (domain.indexOf(d.max) < 0) {
            domain.push(d.max);
          }
        }
      }
    }
    return domain;
  }
  getYDomain(domain = this.getYValues()) {
    let min4 = Math.min(...domain);
    const max4 = Math.max(this.yAxisMinScale, ...domain);
    min4 = Math.max(0, min4);
    if (!this.autoScale) {
      min4 = Math.min(0, min4);
    }
    return [min4, max4];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    switch (this.scaleType) {
      case ScaleType.Time:
        return time().range([0, width]).domain(domain);
      case ScaleType.Linear: {
        const scale = linear().range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
      }
      default:
        return point().range([0, width - twoPI / domain.length]).padding(0).domain(domain);
    }
  }
  getYScale(domain, height) {
    const scale = linear().range([0, height]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    const domain = this.schemeType === ScaleType.Ordinal ? this.seriesDomain : this.yDomain.reverse();
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    if (this.schemeType === ScaleType.Ordinal) {
      return {
        scaleType: this.schemeType,
        colors: this.colors,
        domain: this.seriesDomain,
        title: this.legendTitle,
        position: this.legendPosition
      };
    }
    return {
      scaleType: this.schemeType,
      colors: this.colors.scale,
      domain: this.yDomain,
      title: void 0,
      position: this.legendPosition
    };
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = this.showSeriesOnHover ? [item, ...this.activeEntries] : this.activeEntries;
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275PolarChartComponent_BaseFactory;
      return function PolarChartComponent_Factory(__ngFactoryType__) {
        return (\u0275PolarChartComponent_BaseFactory || (\u0275PolarChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PolarChartComponent)))(__ngFactoryType__ || _PolarChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PolarChartComponent,
      selectors: [["ngx-charts-polar-chart"]],
      contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        xAxis: "xAxis",
        yAxis: "yAxis",
        showXAxisLabel: "showXAxisLabel",
        showYAxisLabel: "showYAxisLabel",
        xAxisLabel: "xAxisLabel",
        yAxisLabel: "yAxisLabel",
        autoScale: "autoScale",
        showGridLines: "showGridLines",
        curve: "curve",
        activeEntries: "activeEntries",
        schemeType: "schemeType",
        rangeFillOpacity: "rangeFillOpacity",
        trimYAxisTicks: "trimYAxisTicks",
        maxYAxisTickLength: "maxYAxisTickLength",
        xAxisTickFormatting: "xAxisTickFormatting",
        yAxisTickFormatting: "yAxisTickFormatting",
        roundDomains: "roundDomains",
        tooltipDisabled: "tooltipDisabled",
        showSeriesOnHover: "showSeriesOnHover",
        gradient: "gradient",
        yAxisMinScale: "yAxisMinScale",
        labelTrim: "labelTrim",
        labelTrimSize: "labelTrimSize",
        wrapTicks: "wrapTicks"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 10,
      vars: 17,
      consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-polar-series", "", 3, "select", "activate", "deactivate", "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate"]],
      template: function PolarChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1)(2, "g");
          \u0275\u0275element(3, "circle", 2);
          \u0275\u0275template(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3)(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275template(6, PolarChartComponent__svg_g_6_Template, 1, 10, "g", 4)(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5)(8, PolarChartComponent__svg_g_8_Template, 2, 3, "g", 3)(9, PolarChartComponent__svg_g_9_Template, 2, 3, "g", 3);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(14, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transformPlot);
          \u0275\u0275advance();
          \u0275\u0275attribute("r", ctx.outerRadius);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showGridLines);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.yAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.xAxis && ctx.showXAxisLabel);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isSSR);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isSSR);
        }
      },
      dependencies: [NgForOf, NgIf, AxisLabelComponent, YAxisComponent, ChartComponent, PieLabelComponent, PolarSeriesComponent],
      styles: [_c25, ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}\n"],
      encapsulation: 2,
      data: {
        animation: [trigger("animationState", [transition(":leave", [style({
          opacity: 1
        }), animate(500, style({
          opacity: 0
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-polar-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g class="polar-chart chart" [attr.transform]="transform">
        <svg:g [attr.transform]="transformPlot">
          <svg:circle class="polar-chart-background" cx="0" cy="0" [attr.r]="this.outerRadius" />
          <svg:g *ngIf="showGridLines">
            <svg:circle
              *ngFor="let r of radiusTicks"
              class="gridline-path radial-gridline-path"
              cx="0"
              cy="0"
              [attr.r]="r"
            />
          </svg:g>
          <svg:g *ngIf="xAxis">
            <svg:g
              ngx-charts-pie-label
              *ngFor="let tick of thetaTicks"
              [data]="tick"
              [radius]="outerRadius"
              [label]="tick.label"
              [max]="outerRadius"
              [value]="showGridLines ? 1 : outerRadius"
              [explodeSlices]="true"
              [animations]="animations"
              [labelTrim]="labelTrim"
              [labelTrimSize]="labelTrimSize"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g
          ngx-charts-y-axis
          [attr.transform]="transformYAxis"
          *ngIf="yAxis"
          [yScale]="yAxisScale"
          [dims]="yAxisDims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-axis-label
          *ngIf="xAxis && showXAxisLabel"
          [label]="xAxisLabel"
          [offset]="labelOffset"
          [orient]="orientation.Bottom"
          [height]="dims.height"
          [width]="dims.width"
        ></svg:g>
        <svg:g *ngIf="!isSSR" [attr.transform]="transformPlot">
          <svg:g *ngFor="let series of results; trackBy: trackBy" [@animationState]="'active'">
            <svg:g
              ngx-charts-polar-series
              [gradient]="gradient"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [curve]="curve"
              [rangeFillOpacity]="rangeFillOpacity"
              [animations]="animations"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR" [attr.transform]="transformPlot">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-polar-series
              [gradient]="gradient"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [curve]="curve"
              [rangeFillOpacity]="rangeFillOpacity"
              [animations]="animations"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    showSeriesOnHover: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    yAxisMinScale: [{
      type: Input
    }],
    labelTrim: [{
      type: Input
    }],
    labelTrimSize: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var PieArcComponent = class _PieArcComponent {
  constructor(element) {
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.cornerRadius = 0;
    this.explodeSlices = false;
    this.gradient = false;
    this.animate = true;
    this.pointerEvents = true;
    this.isActive = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dblclick = new EventEmitter();
    this.barOrientation = BarOrientation;
    this.initialized = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  getGradient() {
    return this.gradient ? this.gradientFill : this.fill;
  }
  getPointerEvents() {
    return this.pointerEvents ? "auto" : "none";
  }
  update() {
    const calc = this.calculateArc();
    this.startOpacity = 0.5;
    this.radialGradientId = "linearGrad" + id().toString();
    this.gradientFill = `url(#${this.radialGradientId})`;
    if (this.animate) {
      if (this.initialized) {
        this.updateAnimation();
      } else {
        this.loadAnimation();
        this.initialized = true;
      }
    } else {
      this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
    }
  }
  calculateArc() {
    let outerRadius = this.outerRadius;
    if (this.explodeSlices && this.innerRadius === 0) {
      outerRadius = this.outerRadius * this.value / this.max;
    }
    return arc_default().innerRadius(this.innerRadius).outerRadius(outerRadius).cornerRadius(this.cornerRadius);
  }
  loadAnimation() {
    const node = select_default(this.element).selectAll(".arc").data([{
      startAngle: this.startAngle,
      endAngle: this.endAngle
    }]);
    const calc = this.calculateArc();
    node.transition().attrTween("d", function(d) {
      this._current = this._current || d;
      const copyOfD = Object.assign({}, d);
      copyOfD.endAngle = copyOfD.startAngle;
      const interpolater = value_default(copyOfD, copyOfD);
      this._current = interpolater(0);
      return function(t) {
        return calc(interpolater(t));
      };
    }).transition().duration(750).attrTween("d", function(d) {
      this._current = this._current || d;
      const interpolater = value_default(this._current, d);
      this._current = interpolater(0);
      return function(t) {
        return calc(interpolater(t));
      };
    });
  }
  updateAnimation() {
    const node = select_default(this.element).selectAll(".arc").data([{
      startAngle: this.startAngle,
      endAngle: this.endAngle
    }]);
    const calc = this.calculateArc();
    node.transition().duration(750).attrTween("d", function(d) {
      this._current = this._current || d;
      const interpolater = value_default(this._current, d);
      this._current = interpolater(0);
      return function(t) {
        return calc(interpolater(t));
      };
    });
  }
  onClick() {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(() => this.select.emit(this.data), 200);
  }
  onDblClick(event) {
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this._timeout);
    this.dblclick.emit({
      data: this.data,
      nativeEvent: event
    });
  }
  static {
    this.\u0275fac = function PieArcComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PieArcComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieArcComponent,
      selectors: [["g", "ngx-charts-pie-arc", ""]],
      inputs: {
        fill: "fill",
        startAngle: "startAngle",
        endAngle: "endAngle",
        innerRadius: "innerRadius",
        outerRadius: "outerRadius",
        cornerRadius: "cornerRadius",
        value: "value",
        max: "max",
        data: "data",
        explodeSlices: "explodeSlices",
        gradient: "gradient",
        animate: "animate",
        pointerEvents: "pointerEvents",
        isActive: "isActive"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate",
        dblclick: "dblclick"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c40,
      decls: 3,
      vars: 7,
      consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity"]],
      template: function PieArcComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0);
          \u0275\u0275template(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
          \u0275\u0275elementStart(2, "path", 2);
          \u0275\u0275listener("click", function PieArcComponent_Template_path_click_2_listener() {
            return ctx.onClick();
          })("dblclick", function PieArcComponent_Template_path_dblclick_2_listener($event) {
            return ctx.onDblClick($event);
          })("mouseenter", function PieArcComponent_Template_path_mouseenter_2_listener() {
            return ctx.activate.emit(ctx.data);
          })("mouseleave", function PieArcComponent_Template_path_mouseleave_2_listener() {
            return ctx.deactivate.emit(ctx.data);
          });
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.gradient);
          \u0275\u0275advance();
          \u0275\u0275styleProp("pointer-events", ctx.getPointerEvents());
          \u0275\u0275classProp("active", ctx.isActive);
          \u0275\u0275attribute("d", ctx.path)("fill", ctx.getGradient());
        }
      },
      dependencies: [NgIf, SvgRadialGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieArcComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-arc]",
      template: `
    <svg:g class="arc-group">
      <svg:defs *ngIf="gradient">
        <svg:g ngx-charts-svg-radial-gradient [color]="fill" [name]="radialGradientId" [startOpacity]="startOpacity" />
      </svg:defs>
      <svg:path
        [attr.d]="path"
        class="arc"
        [class.active]="isActive"
        [attr.fill]="getGradient()"
        (click)="onClick()"
        (dblclick)="onDblClick($event)"
        (mouseenter)="activate.emit(data)"
        (mouseleave)="deactivate.emit(data)"
        [style.pointer-events]="getPointerEvents()"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    endAngle: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    cornerRadius: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    pointerEvents: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dblclick: [{
      type: Output
    }]
  });
})();
var PieSeriesComponent = class _PieSeriesComponent {
  constructor() {
    this.series = [];
    this.innerRadius = 60;
    this.outerRadius = 80;
    this.trimLabels = true;
    this.maxLabelLength = 10;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dblclick = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    const pieGenerator = pie_default().value((d) => d.value).sort(null);
    const arcData = pieGenerator(this.series);
    this.max = max(arcData, (d) => {
      return d.value;
    });
    this.data = this.calculateLabelPositions(arcData);
    this.tooltipText = this.tooltipText || this.defaultTooltipText;
  }
  midAngle(d) {
    return d.startAngle + (d.endAngle - d.startAngle) / 2;
  }
  outerArc() {
    const factor = 1.5;
    return arc_default().innerRadius(this.outerRadius * factor).outerRadius(this.outerRadius * factor);
  }
  calculateLabelPositions(pieData) {
    const factor = 1.5;
    const minDistance = 10;
    const labelPositions = pieData;
    labelPositions.forEach((d) => {
      d.pos = this.outerArc().centroid(d);
      d.pos[0] = factor * this.outerRadius * (this.midAngle(d) < Math.PI ? 1 : -1);
    });
    for (let i = 0; i < labelPositions.length - 1; i++) {
      const a = labelPositions[i];
      if (!this.labelVisible(a)) {
        continue;
      }
      for (let j = i + 1; j < labelPositions.length; j++) {
        const b = labelPositions[j];
        if (!this.labelVisible(b)) {
          continue;
        }
        if (b.pos[0] * a.pos[0] > 0) {
          const o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
          if (o > 0) {
            b.pos[1] += Math.sign(b.pos[0]) * o;
          }
        }
      }
    }
    return labelPositions;
  }
  labelVisible(myArc) {
    return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
  }
  getTooltipTitle(a) {
    return this.tooltipTemplate ? void 0 : this.tooltipText(a);
  }
  labelText(myArc) {
    if (this.labelFormatting) {
      return this.labelFormatting(myArc.data.name);
    }
    return this.label(myArc);
  }
  label(myArc) {
    return formatLabel(myArc.data.name);
  }
  defaultTooltipText(myArc) {
    const label = this.label(myArc);
    const val = formatLabel(myArc.data.value);
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
  color(myArc) {
    return this.colors.getColor(this.label(myArc));
  }
  trackBy(index, item) {
    return item.data.name;
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name && entry.series === d.series;
    });
    return item !== void 0;
  }
  static {
    this.\u0275fac = function PieSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PieSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieSeriesComponent,
      selectors: [["g", "ngx-charts-pie-series", ""]],
      inputs: {
        colors: "colors",
        series: "series",
        dims: "dims",
        innerRadius: "innerRadius",
        outerRadius: "outerRadius",
        explodeSlices: "explodeSlices",
        showLabels: "showLabels",
        gradient: "gradient",
        activeEntries: "activeEntries",
        labelFormatting: "labelFormatting",
        trimLabels: "trimLabels",
        maxLabelLength: "maxLabelLength",
        tooltipText: "tooltipText",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate",
        dblclick: "dblclick"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c41,
      decls: 1,
      vars: 2,
      consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "dblclick", "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]],
      template: function PieSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, PieLabelComponent, PieArcComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-series]",
      template: `
    <svg:g *ngFor="let arc of data; trackBy: trackBy">
      <svg:g
        ngx-charts-pie-label
        *ngIf="labelVisible(arc)"
        [data]="arc"
        [radius]="outerRadius"
        [color]="color(arc)"
        [label]="labelText(arc)"
        [labelTrim]="trimLabels"
        [labelTrimSize]="maxLabelLength"
        [max]="max"
        [value]="arc.value"
        [explodeSlices]="explodeSlices"
        [animations]="animations"
      ></svg:g>
      <svg:g
        ngx-charts-pie-arc
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [gradient]="gradient"
        [data]="arc.data"
        [max]="max"
        [explodeSlices]="explodeSlices"
        [isActive]="isActive(arc.data)"
        [animate]="animations"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        (dblclick)="dblclick.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="getTooltipTitle(arc)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="arc.data"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    colors: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    showLabels: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    trimLabels: [{
      type: Input
    }],
    maxLabelLength: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dblclick: [{
      type: Output
    }]
  });
})();
var AdvancedPieChartComponent = class _AdvancedPieChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.label = "Total";
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [20, 20, 20, 20];
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width * 4 / 12,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.setColors();
    const xOffset = this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.legendWidth = this.width - this.dims.width - this.margin[1];
    this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
    this.innerRadius = this.outerRadius * 0.75;
    this.transform = `translate(${xOffset} , ${yOffset})`;
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275AdvancedPieChartComponent_BaseFactory;
      return function AdvancedPieChartComponent_Factory(__ngFactoryType__) {
        return (\u0275AdvancedPieChartComponent_BaseFactory || (\u0275AdvancedPieChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AdvancedPieChartComponent)))(__ngFactoryType__ || _AdvancedPieChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _AdvancedPieChartComponent,
      selectors: [["ngx-charts-advanced-pie-chart"]],
      contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        gradient: "gradient",
        activeEntries: "activeEntries",
        tooltipDisabled: "tooltipDisabled",
        tooltipText: "tooltipText",
        label: "label",
        valueFormatting: "valueFormatting",
        nameFormatting: "nameFormatting",
        percentageFormatting: "percentageFormatting"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 7,
      vars: 37,
      consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "select", "activate", "deactivate", "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations"], [1, "advanced-pie-legend-wrapper"], [3, "select", "activate", "deactivate", "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting"]],
      template: function AdvancedPieChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "ngx-charts-chart", 1);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(3, "g", 2)(4, "g", 3);
          \u0275\u0275listener("select", function AdvancedPieChartComponent_Template_g_select_4_listener($event) {
            return ctx.onClick($event);
          })("activate", function AdvancedPieChartComponent_Template_g_activate_4_listener($event) {
            return ctx.onActivate($event);
          })("deactivate", function AdvancedPieChartComponent_Template_g_deactivate_4_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275elementEnd()()()();
          \u0275\u0275namespaceHTML();
          \u0275\u0275elementStart(5, "div", 4)(6, "ngx-charts-advanced-legend", 5);
          \u0275\u0275listener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) {
            return ctx.onClick($event);
          })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) {
            return ctx.onActivate($event, true);
          })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) {
            return ctx.onDeactivate($event, true);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.width, "px")("height", ctx.height, "px");
          \u0275\u0275advance();
          \u0275\u0275styleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
          \u0275\u0275advance();
          \u0275\u0275property("view", \u0275\u0275pureFunction2(34, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275styleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
          \u0275\u0275advance();
          \u0275\u0275property("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
        }
      },
      dependencies: [ChartComponent, AdvancedLegendComponent, PieSeriesComponent],
      styles: [_c25, ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdvancedPieChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-advanced-pie-chart",
      template: `
    <div [style.width.px]="width" [style.height.px]="height">
      <div class="advanced-pie chart" [style.width.px]="dims.width" [style.height.px]="dims.height">
        <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
          <svg:g [attr.transform]="transform" class="pie chart">
            <svg:g
              ngx-charts-pie-series
              [colors]="colors"
              [series]="results"
              [innerRadius]="innerRadius"
              [activeEntries]="activeEntries"
              [outerRadius]="outerRadius"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [tooltipText]="tooltipText"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
              [animations]="animations"
            ></svg:g>
          </svg:g>
        </ngx-charts-chart>
      </div>
      <div class="advanced-pie-legend-wrapper" [style.width.px]="width - dims.width" [style.height.px]="height">
        <ngx-charts-advanced-legend
          [data]="results"
          [colors]="colors"
          [width]="width - dims.width - margin[1]"
          [label]="label"
          [animations]="animations"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="nameFormatting"
          [percentageFormatting]="percentageFormatting"
          (select)="onClick($event)"
          (activate)="onActivate($event, true)"
          (deactivate)="onDeactivate($event, true)"
        >
        </ngx-charts-advanced-legend>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}\n"]
    }]
  }], null, {
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    valueFormatting: [{
      type: Input
    }],
    nameFormatting: [{
      type: Input
    }],
    percentageFormatting: [{
      type: Input
    }]
  });
})();
var PieChartComponent = class _PieChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.labels = false;
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.explodeSlices = false;
    this.doughnut = false;
    this.arcWidth = 0.25;
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.trimLabels = true;
    this.maxLabelLength = 10;
    this.dblclick = new EventEmitter();
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  update() {
    super.update();
    if (this.labels && this.hasNoOptionalMarginsSet()) {
      this.margins = [30, 80, 30, 80];
    } else if (!this.labels && this.hasNoOptionalMarginsSet()) {
      this.margins = [20, 20, 20, 20];
    }
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margins,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    const xOffset = this.margins[3] + this.dims.width / 2;
    const yOffset = this.margins[0] + this.dims.height / 2;
    this.translation = `translate(${xOffset}, ${yOffset})`;
    this.outerRadius = Math.min(this.dims.width, this.dims.height);
    if (this.labels) {
      this.outerRadius /= 3;
    } else {
      this.outerRadius /= 2;
    }
    this.innerRadius = 0;
    if (this.doughnut) {
      this.innerRadius = this.outerRadius * (1 - this.arcWidth);
    }
    this.domain = this.getDomain();
    this.data = this.results.sort((a, b) => {
      return this.domain.indexOf(a.name) - this.domain.indexOf(b.name);
    });
    this.setColors();
    this.legendOptions = this.getLegendOptions();
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  getLegendOptions() {
    return {
      scaleType: ScaleType.Ordinal,
      domain: this.domain,
      colors: this.colors,
      title: this.legendTitle,
      position: this.legendPosition
    };
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  hasNoOptionalMarginsSet() {
    return !this.margins || this.margins.length <= 0;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275PieChartComponent_BaseFactory;
      return function PieChartComponent_Factory(__ngFactoryType__) {
        return (\u0275PieChartComponent_BaseFactory || (\u0275PieChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PieChartComponent)))(__ngFactoryType__ || _PieChartComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieChartComponent,
      selectors: [["ngx-charts-pie-chart"]],
      contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        labels: "labels",
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        explodeSlices: "explodeSlices",
        doughnut: "doughnut",
        arcWidth: "arcWidth",
        gradient: "gradient",
        activeEntries: "activeEntries",
        tooltipDisabled: "tooltipDisabled",
        labelFormatting: "labelFormatting",
        trimLabels: "trimLabels",
        maxLabelLength: "maxLabelLength",
        tooltipText: "tooltipText",
        margins: "margins"
      },
      outputs: {
        dblclick: "dblclick",
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 24,
      consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "dblclick", "select", "activate", "deactivate", "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText"]],
      template: function PieChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275listener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event, true);
          })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event, true);
          })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
          \u0275\u0275listener("dblclick", function PieChartComponent_Template_g_dblclick_2_listener($event) {
            return ctx.dblclick.emit($event);
          })("select", function PieChartComponent_Template_g_select_2_listener($event) {
            return ctx.onClick($event);
          })("activate", function PieChartComponent_Template_g_activate_2_listener($event) {
            return ctx.onActivate($event);
          })("deactivate", function PieChartComponent_Template_g_deactivate_2_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(21, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.translation);
          \u0275\u0275advance();
          \u0275\u0275property("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
        }
      },
      dependencies: [ChartComponent, PieSeriesComponent],
      styles: [_c25, _c42],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-pie-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="translation" class="pie-chart chart">
        <svg:g
          ngx-charts-pie-series
          [colors]="colors"
          [series]="data"
          [showLabels]="labels"
          [labelFormatting]="labelFormatting"
          [trimLabels]="trimLabels"
          [maxLabelLength]="maxLabelLength"
          [activeEntries]="activeEntries"
          [innerRadius]="innerRadius"
          [outerRadius]="outerRadius"
          [explodeSlices]="explodeSlices"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (dblclick)="dblclick.emit($event)"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n"]
    }]
  }], null, {
    labels: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    doughnut: [{
      type: Input
    }],
    arcWidth: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    trimLabels: [{
      type: Input
    }],
    maxLabelLength: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    dblclick: [{
      type: Output
    }],
    margins: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
function gridSize(dims, len, minWidth) {
  let rows = 1;
  let cols = len;
  const width = dims.width;
  if (width > minWidth) {
    while (width / cols < minWidth) {
      rows += 1;
      cols = Math.ceil(len / rows);
    }
  }
  return [cols, rows];
}
function gridLayout(dims, data, minWidth, designatedTotal) {
  const xScale = band();
  const yScale = band();
  const width = dims.width;
  const height = dims.height;
  const [columns, rows] = gridSize(dims, data.length, minWidth);
  const xDomain = [];
  const yDomain = [];
  for (let i = 0; i < rows; i++) {
    yDomain.push(i);
  }
  for (let i = 0; i < columns; i++) {
    xDomain.push(i);
  }
  xScale.domain(xDomain);
  yScale.domain(yDomain);
  xScale.rangeRound([0, width], 0.1);
  yScale.rangeRound([0, height], 0.1);
  const res = [];
  const total = designatedTotal ? designatedTotal : getTotal(data);
  const cardWidth = xScale.bandwidth();
  const cardHeight = yScale.bandwidth();
  for (let i = 0; i < data.length; i++) {
    res[i] = {};
    res[i].data = {
      name: data[i] ? data[i].name : "",
      value: data[i] ? data[i].value : void 0,
      extra: data[i] ? data[i].extra : void 0,
      label: data[i] ? data[i].label : ""
    };
    res[i].x = xScale(i % columns);
    res[i].y = yScale(Math.floor(i / columns));
    res[i].width = cardWidth;
    res[i].height = cardHeight;
    res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
    res[i].data.total = total;
  }
  return res;
}
function getTotal(results) {
  return results.map((d) => d ? d.value : 0).reduce((sum2, val) => sum2 + val, 0);
}
var PieGridSeriesComponent = class _PieGridSeriesComponent {
  constructor(element) {
    this.innerRadius = 70;
    this.outerRadius = 80;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.layout = pie_default().value((d) => d.data.value).sort(null);
    this.arcs = this.getArcs();
  }
  getArcs() {
    return this.layout(this.data).map((arc, index) => {
      const label = arc.data.data.name;
      const other = arc.data.data.other;
      if (index === 0) {
        arc.startAngle = 0;
      }
      const color2 = this.colors(label);
      return {
        data: arc.data.data,
        class: "arc arc" + index,
        fill: color2,
        startAngle: other ? 0 : arc.startAngle,
        endAngle: arc.endAngle,
        animate: this.animations && !other,
        pointerEvents: !other
      };
    });
  }
  onClick(data) {
    this.select.emit(this.data[0].data);
  }
  trackBy(index, item) {
    return item.data.name;
  }
  label(arc) {
    return arc.data.name;
  }
  color(arc) {
    return this.colors(this.label(arc));
  }
  static {
    this.\u0275fac = function PieGridSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PieGridSeriesComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieGridSeriesComponent,
      selectors: [["g", "ngx-charts-pie-grid-series", ""]],
      inputs: {
        colors: "colors",
        data: "data",
        innerRadius: "innerRadius",
        outerRadius: "outerRadius",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c43,
      decls: 2,
      vars: 2,
      consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "select", "activate", "deactivate", "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate"]],
      template: function PieGridSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 0);
          \u0275\u0275template(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, PieArcComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieGridSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-grid-series]",
      template: `
    <svg:g class="pie-grid-arcs">
      <svg:g
        ngx-charts-pie-arc
        *ngFor="let arc of arcs; trackBy: trackBy"
        [attr.class]="arc.class"
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [data]="arc.data"
        [gradient]="false"
        [pointerEvents]="arc.pointerEvents"
        [animate]="arc.animate"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    colors: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var PieGridComponent = class _PieGridComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.tooltipDisabled = false;
    this.label = "Total";
    this.minWidth = 150;
    this.activeEntries = [];
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [20, 20, 20, 20];
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
    this.transform = `translate(${this.margin[3]} , ${this.margin[0]})`;
    this.series = this.getSeries();
    this.setColors();
    this.tooltipText = this.tooltipText || this.defaultTooltipText;
  }
  defaultTooltipText({
    data
  }) {
    const label = trimLabel(formatLabel(data.name));
    const val = data.value.toLocaleString();
    return `
      <span class="tooltip-label">${label}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  getSeries() {
    const total = this.designatedTotal ? this.designatedTotal : this.getTotal();
    return this.data.map((d) => {
      const baselineLabelHeight = 20;
      const padding = 10;
      const name = d.data.name;
      const label = formatLabel(name);
      const value2 = d.data.value;
      const radius = min([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
      const innerRadius = radius * 0.9;
      let count3 = 0;
      const colors = () => {
        count3 += 1;
        if (count3 === 1) {
          return "rgba(100,100,100,0.3)";
        } else {
          return this.colorScale.getColor(label);
        }
      };
      const xPos = d.x + (d.width - padding) / 2;
      const yPos = d.y + (d.height - baselineLabelHeight) / 2;
      return {
        transform: `translate(${xPos}, ${yPos})`,
        colors,
        innerRadius,
        outerRadius: radius,
        name,
        label: trimLabel(label),
        total: value2,
        value: value2,
        percent: format(".1%")(d.data.percent),
        data: [d, {
          data: {
            other: true,
            value: total - value2,
            name: d.data.name
          }
        }]
      };
    });
  }
  getTotal() {
    return this.results.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colorScale = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275PieGridComponent_BaseFactory;
      return function PieGridComponent_Factory(__ngFactoryType__) {
        return (\u0275PieGridComponent_BaseFactory || (\u0275PieGridComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PieGridComponent)))(__ngFactoryType__ || _PieGridComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PieGridComponent,
      selectors: [["ngx-charts-pie-grid"]],
      contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        designatedTotal: "designatedTotal",
        tooltipDisabled: "tooltipDisabled",
        tooltipText: "tooltipText",
        label: "label",
        minWidth: "minWidth",
        activeEntries: "activeEntries"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 8,
      consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]],
      template: function PieGridComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(5, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.series);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, CountUpDirective, ChartComponent, PieGridSeriesComponent],
      styles: [_c25, ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieGridComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-pie-grid",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="pie-grid chart">
        <svg:g *ngFor="let series of series" class="pie-grid-item" [attr.transform]="series.transform">
          <svg:g
            ngx-charts-pie-grid-series
            [colors]="series.colors"
            [data]="series.data"
            [innerRadius]="series.innerRadius"
            [outerRadius]="series.outerRadius"
            [animations]="animations"
            (select)="onClick($event)"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipPlacement]="placementTypes.Top"
            [tooltipType]="styleTypes.tooltip"
            [tooltipTitle]="tooltipTemplate ? undefined : tooltipText({ data: series })"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="series.data[0].data"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
          />
          <svg:text
            *ngIf="animations"
            class="label percent-label"
            dy="-0.5em"
            x="0"
            y="5"
            ngx-charts-count-up
            [countTo]="series.percent"
            [countSuffix]="'%'"
            text-anchor="middle"
          ></svg:text>
          <svg:text *ngIf="!animations" class="label percent-label" dy="-0.5em" x="0" y="5" text-anchor="middle">
            {{ series.percent.toLocaleString() }}
          </svg:text>
          <svg:text class="label" dy="0.5em" x="0" y="5" text-anchor="middle">
            {{ series.label }}
          </svg:text>
          <svg:text
            *ngIf="animations"
            class="label"
            dy="1.23em"
            x="0"
            [attr.y]="series.outerRadius"
            text-anchor="middle"
            ngx-charts-count-up
            [countTo]="series.total"
            [countPrefix]="label + ': '"
          ></svg:text>
          <svg:text
            *ngIf="!animations"
            class="label"
            dy="1.23em"
            x="0"
            [attr.y]="series.outerRadius"
            text-anchor="middle"
          >
            {{ label }}: {{ series.total.toLocaleString() }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}\n"]
    }]
  }], null, {
    designatedTotal: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var PieChartModule = class _PieChartModule {
  static {
    this.\u0275fac = function PieChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PieChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _PieChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent],
      exports: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent]
    }]
  }], null, null);
})();
var PolarChartModule = class _PolarChartModule {
  static {
    this.\u0275fac = function PolarChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PolarChartModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _PolarChartModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule, PieChartModule, LineChartModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule, PieChartModule, LineChartModule],
      declarations: [PolarChartComponent, PolarSeriesComponent],
      exports: [PolarChartComponent, PolarSeriesComponent]
    }]
  }], null, null);
})();
function calculateTextWidth(fontFamilyKey, text, defaultWidth = 8) {
  return text.split("").reduce((acc, curr) => {
    const width = fontFamilyKey[curr] || defaultWidth;
    return acc + width;
  }, 0);
}
var VERDANA_FONT_WIDTHS_16_PX = {
  "0": 10,
  "1": 10,
  "2": 10,
  "3": 10,
  "4": 10,
  "5": 10,
  "6": 10,
  "7": 10,
  "8": 10,
  "9": 10,
  A: 11,
  B: 11,
  C: 11,
  D: 12,
  E: 10,
  F: 9,
  G: 12,
  H: 12,
  I: 7,
  J: 7,
  K: 11,
  L: 9,
  M: 13,
  N: 12,
  O: 13,
  P: 10,
  Q: 13,
  R: 11,
  S: 11,
  T: 10,
  U: 12,
  V: 11,
  W: 16,
  X: 11,
  Y: 10,
  Z: 11,
  a: 10,
  b: 10,
  c: 8,
  d: 10,
  e: 10,
  f: 6,
  g: 10,
  h: 10,
  i: 4,
  j: 6,
  k: 9,
  l: 4,
  m: 16,
  n: 10,
  o: 10,
  p: 10,
  q: 10,
  r: 7,
  s: 8,
  t: 6,
  u: 10,
  v: 9,
  w: 13,
  x: 9,
  y: 9,
  z: 8,
  "!": 6,
  "@": 16,
  "#": 13,
  $: 10,
  "%": 17,
  "^": 13,
  "&": 12,
  "*": 10,
  "(": 7,
  ")": 7,
  _: 10,
  "-": 7,
  "+": 13,
  "=": 13,
  ",": 6,
  ".": 6,
  "/": 7,
  "'": 4,
  ":": 7,
  "|": 7,
  "?": 9,
  ";": 7,
  "<": 13,
  ">": 13
};
var CardComponent = class _CardComponent {
  constructor(element, cd, zone, platformId) {
    this.cd = cd;
    this.zone = zone;
    this.platformId = platformId;
    this.animations = true;
    this.select = new EventEmitter();
    this.value = "";
    this.textFontSize = 12;
    this.textTransform = "";
    this.initialized = false;
    this.bandHeight = 10;
    this.textPadding = [10, 20, 5, 20];
    this.labelFontSize = 15;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.scaleTextSSR();
    }
  }
  ngOnDestroy() {
    if (isPlatformBrowser(this.platformId)) {
      cancelAnimationFrame(this.animationReq);
    }
  }
  update() {
    this.zone.run(() => {
      const hasValue = this.data && typeof this.data.value !== "undefined";
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const labelFormatting = this.labelFormatting || ((card) => escapeLabel(trimLabel(card.label, 55)));
      this.transform = `translate(${this.x} , ${this.y})`;
      this.textWidth = Math.max(0, this.width) - this.textPadding[1] - this.textPadding[3];
      this.cardWidth = Math.max(0, this.width);
      this.cardHeight = Math.max(0, this.height);
      this.label = this.label ? this.label : this.data.name;
      const cardData = {
        label: this.label,
        data: this.data,
        value: this.data.value
      };
      this.formattedLabel = labelFormatting(cardData);
      this.transformBand = `translate(0 , ${this.cardHeight - this.bandHeight})`;
      const value2 = hasValue ? valueFormatting(cardData) : "";
      this.value = this.paddedValue(value2);
      this.setPadding();
      this.bandPath = roundedRect(0, 0, this.cardWidth, this.bandHeight, 3, [false, false, true, true]);
      setTimeout(() => {
        if (isPlatformBrowser(this.platformId)) {
          this.scaleText();
        }
        this.value = value2;
        if (hasValue && !this.initialized) {
          setTimeout(() => this.startCount(), 20);
        }
      }, 8);
    });
  }
  paddedValue(value2) {
    if (this.medianSize && this.medianSize > value2.length) {
      value2 += "\u2007".repeat(this.medianSize - value2.length);
    }
    return value2;
  }
  startCount() {
    if (!this.initialized && this.animations) {
      cancelAnimationFrame(this.animationReq);
      const val = this.data.value;
      const decs = decimalChecker(val);
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const callback = ({
        value: value2,
        finished
      }) => {
        this.zone.run(() => {
          value2 = finished ? val : value2;
          this.value = valueFormatting({
            label: this.label,
            data: this.data,
            value: value2
          });
          if (!finished) {
            this.value = this.paddedValue(this.value);
          }
          this.cd.markForCheck();
        });
      };
      this.animationReq = count2(0, val, decs, 1, callback);
      this.initialized = true;
    }
  }
  scaleText() {
    this.zone.run(() => {
      const {
        width,
        height
      } = this.textEl.nativeElement.getBoundingClientRect();
      if (width === 0 || height === 0) {
        return;
      }
      const textPadding = this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
      const availableWidth = this.cardWidth - 2 * textPadding;
      const availableHeight = this.cardHeight / 3;
      const resizeScale = Math.min(availableWidth / width, availableHeight / height);
      this.textFontSize = Math.floor(this.textFontSize * resizeScale);
      this.labelFontSize = Math.min(this.textFontSize, 15);
      this.setPadding();
      this.cd.markForCheck();
    });
  }
  scaleTextSSR() {
    const width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, this.value, 10);
    const height = 18;
    const textPadding = this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
    const availableWidth = this.cardWidth - 2 * textPadding;
    const availableHeight = this.cardHeight / 3;
    const resizeScale = Math.min(availableWidth / width, availableHeight / height);
    this.textFontSize = Math.floor(this.textFontSize * resizeScale);
    this.labelFontSize = Math.min(this.textFontSize, 15);
    this.setPadding();
  }
  setPadding() {
    this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
    const padding = this.cardHeight / 2;
    this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
    this.textPadding[2] = padding - this.labelFontSize;
  }
  onClick() {
    this.select.emit(this.data);
  }
  static {
    this.\u0275fac = function CardComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CardComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(PLATFORM_ID));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CardComponent,
      selectors: [["g", "ngx-charts-card", ""]],
      viewQuery: function CardComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c45, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textEl = _t.first);
        }
      },
      inputs: {
        color: "color",
        bandColor: "bandColor",
        textColor: "textColor",
        x: "x",
        y: "y",
        width: "width",
        height: "height",
        label: "label",
        data: "data",
        medianSize: "medianSize",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c46,
      decls: 10,
      vars: 25,
      consts: [["textEl", ""], [1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["stroke", "none", 1, "card-band"]],
      template: function CardComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g", 1);
          \u0275\u0275listener("click", function CardComponent_Template_g_click_0_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onClick());
          });
          \u0275\u0275element(1, "rect", 2);
          \u0275\u0275template(2, CardComponent__svg_path_2_Template, 1, 3, "path", 3);
          \u0275\u0275elementStart(3, "title");
          \u0275\u0275text(4);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(5, "foreignObject", 4);
          \u0275\u0275namespaceHTML();
          \u0275\u0275element(6, "p", 5);
          \u0275\u0275elementEnd();
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(7, "text", 6, 0);
          \u0275\u0275text(9);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275styleProp("fill", ctx.color);
          \u0275\u0275attribute("width", ctx.cardWidth)("height", ctx.cardHeight);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate(ctx.label);
          \u0275\u0275advance();
          \u0275\u0275attribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
          \u0275\u0275advance();
          \u0275\u0275styleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
          \u0275\u0275property("innerHTML", ctx.formattedLabel, \u0275\u0275sanitizeHtml);
          \u0275\u0275advance();
          \u0275\u0275styleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
          \u0275\u0275attribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate1(" ", ctx.value, " ");
        }
      },
      dependencies: [NgIf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-card]",
      template: `
    <svg:g [attr.transform]="transform" class="cell" (click)="onClick()">
      <svg:rect class="card" [style.fill]="color" [attr.width]="cardWidth" [attr.height]="cardHeight" rx="3" ry="3" />
      <svg:path
        *ngIf="bandColor && bandColor !== color"
        class="card-band"
        [attr.fill]="bandColor"
        [attr.transform]="transformBand"
        stroke="none"
        [attr.d]="bandPath"
      />
      <title>{{ label }}</title>
      <svg:foreignObject
        class="trimmed-label"
        x="5"
        [attr.x]="textPadding[3]"
        [attr.y]="cardHeight - textPadding[2]"
        [attr.width]="textWidth"
        [attr.height]="labelFontSize + textPadding[2]"
        alignment-baseline="hanging"
      >
        <xhtml:p
          [style.color]="textColor"
          [style.fontSize.px]="labelFontSize"
          [style.lineHeight.px]="labelFontSize"
          [innerHTML]="formattedLabel"
        >
        </xhtml:p>
      </svg:foreignObject>
      <svg:text
        #textEl
        class="value-text"
        [attr.x]="textPadding[3]"
        [attr.y]="textPadding[0]"
        [style.fill]="textColor"
        text-anchor="start"
        alignment-baseline="hanging"
        [style.font-size.pt]="textFontSize"
      >
        {{ value }}
      </svg:text>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    color: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    medianSize: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    textEl: [{
      type: ViewChild,
      args: ["textEl", {
        static: false
      }]
    }]
  });
})();
function invertColor(value2) {
  const color2 = rgb(value2);
  const {
    r,
    g,
    b,
    opacity
  } = color2;
  if (opacity === 0) {
    return color2.toString();
  }
  const yiq = (r * 299 + g * 587 + b * 114) / 1e3;
  const depth = yiq >= 128 ? -0.8 : 0.8;
  return shadeRGBColor(color2, depth);
}
function shadeRGBColor({
  r,
  g,
  b
}, percent) {
  const t = percent < 0 ? 0 : 255;
  const p = percent < 0 ? percent * -1 : percent;
  r = Math.round((t - r) * p) + r;
  g = Math.round((t - g) * p) + g;
  b = Math.round((t - b) * p) + b;
  return `rgb(${r}, ${g}, ${b})`;
}
var CardSeriesComponent = class _CardSeriesComponent {
  constructor() {
    this.innerPadding = 15;
    this.emptyColor = "rgba(0, 0, 0, 0)";
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    if (this.data.length > 2) {
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const sortedLengths = this.data.map((d) => {
        const hasValue = d && d.data && typeof d.data.value !== "undefined" && d.data.value !== null;
        return hasValue ? valueFormatting({
          data: d.data,
          label: d ? d.data.name : "",
          value: d && d.data ? d.data.value : ""
        }).length : 0;
      }).sort((a, b) => b - a);
      const idx = Math.ceil(this.data.length / 2);
      this.medianSize = sortedLengths[idx];
    }
    const cards = this.getCards();
    this.cards = cards.filter((d) => d.data.value !== null);
    this.emptySlots = cards.filter((d) => d.data.value === null);
  }
  getCards() {
    const yPadding = typeof this.innerPadding === "number" ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
    const xPadding = typeof this.innerPadding === "number" ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
    return this.data.map((d, index) => {
      let label = d.data.name;
      if (label && label.constructor.name === "Date") {
        label = label.toLocaleDateString();
      } else {
        label = label ? label.toLocaleString() : label;
      }
      const value2 = d.data.value;
      const valueColor = label ? this.colors.getColor(label) : this.emptyColor;
      const color2 = this.cardColor || valueColor || "#000";
      return {
        x: d.x,
        y: d.y,
        width: d.width - xPadding,
        height: d.height - yPadding,
        color: color2,
        bandColor: this.bandColor || valueColor,
        textColor: this.textColor || invertColor(color2),
        label,
        data: d.data,
        tooltipText: `${label}: ${value2}`
      };
    });
  }
  trackBy(index, card) {
    return card.label;
  }
  onClick(data) {
    this.select.emit(data);
  }
  static {
    this.\u0275fac = function CardSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CardSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CardSeriesComponent,
      selectors: [["g", "ngx-charts-card-series", ""]],
      inputs: {
        data: "data",
        dims: "dims",
        colors: "colors",
        innerPadding: "innerPadding",
        cardColor: "cardColor",
        bandColor: "bandColor",
        emptyColor: "emptyColor",
        textColor: "textColor",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c47,
      decls: 2,
      vars: 4,
      consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "select", "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations"]],
      template: function CardSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0)(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, CardComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-card-series]",
      template: `
    <svg:rect
      *ngFor="let c of emptySlots; trackBy: trackBy"
      class="card-empty"
      [attr.x]="c.x"
      [attr.y]="c.y"
      [style.fill]="emptyColor"
      [attr.width]="c.width"
      [attr.height]="c.height"
      rx="3"
      ry="3"
    />
    <svg:g
      ngx-charts-card
      *ngFor="let c of cards; trackBy: trackBy"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [color]="c.color"
      [bandColor]="c.bandColor"
      [textColor]="c.textColor"
      [data]="c.data"
      [label]="c.label"
      [medianSize]="medianSize"
      [valueFormatting]="valueFormatting"
      [labelFormatting]="labelFormatting"
      [animations]="animations"
      (select)="onClick($event)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    cardColor: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    emptyColor: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var NumberCardComponent = class _NumberCardComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.emptyColor = "rgba(0, 0, 0, 0)";
    this.innerPadding = 15;
    this.margin = [10, 10, 10, 10];
  }
  get clickable() {
    return !!this.select.observers.length;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.setColors();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    const size = gridSize(this.dims, this.results.length, 150);
    const N = size[0] * size[1];
    const data = this.results.slice();
    while (data.length < N) {
      data.push({
        value: null
      });
    }
    this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275NumberCardComponent_BaseFactory;
      return function NumberCardComponent_Factory(__ngFactoryType__) {
        return (\u0275NumberCardComponent_BaseFactory || (\u0275NumberCardComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NumberCardComponent)))(__ngFactoryType__ || _NumberCardComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _NumberCardComponent,
      selectors: [["ngx-charts-number-card"]],
      inputs: {
        cardColor: "cardColor",
        bandColor: "bandColor",
        emptyColor: "emptyColor",
        innerPadding: "innerPadding",
        textColor: "textColor",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        designatedTotal: "designatedTotal"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "select", "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations"]],
      template: function NumberCardComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
          \u0275\u0275listener("select", function NumberCardComponent_Template_g_select_2_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275classProp("clickable", ctx.clickable);
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
        }
      },
      dependencies: [ChartComponent, CardSeriesComponent],
      styles: [_c25, "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberCardComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-number-card",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="number-card chart" [class.clickable]="clickable">
        <svg:g
          ngx-charts-card-series
          [colors]="colors"
          [cardColor]="cardColor"
          [bandColor]="bandColor"
          [textColor]="textColor"
          [emptyColor]="emptyColor"
          [data]="data"
          [dims]="dims"
          [innerPadding]="innerPadding"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="labelFormatting"
          [animations]="animations"
          (select)="onClick($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}\n"]
    }]
  }], null, {
    cardColor: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    emptyColor: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    designatedTotal: [{
      type: Input
    }]
  });
})();
var NumberCardModule = class _NumberCardModule {
  static {
    this.\u0275fac = function NumberCardModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NumberCardModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _NumberCardModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberCardModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [CardComponent, CardSeriesComponent, NumberCardComponent],
      exports: [CardComponent, CardSeriesComponent, NumberCardComponent]
    }]
  }], null, null);
})();
var TreeMapCellComponent = class _TreeMapCellComponent {
  constructor(element) {
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.initialized = false;
    this.orientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges() {
    this.update();
    this.valueFormatting = this.valueFormatting || ((value2) => value2.toLocaleString());
    const labelFormatting = this.labelFormatting || ((cell) => escapeLabel(trimLabel(cell.label, 55)));
    const cellData = {
      data: this.data,
      label: this.label,
      value: this.value
    };
    this.formattedValue = this.valueFormatting(cellData.value);
    this.formattedLabel = labelFormatting(cellData);
    this.gradientId = "grad" + id().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    this.gradientStops = this.getGradientStops();
  }
  update() {
    if (this.initialized) {
      this.animateToCurrentForm();
    } else {
      if (this.animations) {
        this.loadAnimation();
      }
      this.initialized = true;
    }
  }
  loadAnimation() {
    const node = select_default(this.element).select(".cell");
    node.attr("opacity", 0).attr("x", this.x).attr("y", this.y);
    this.animateToCurrentForm();
  }
  getTextColor() {
    return invertColor(this.fill);
  }
  animateToCurrentForm() {
    const node = select_default(this.element).select(".cell");
    if (this.animations) {
      node.transition().duration(750).attr("opacity", 1).attr("x", this.x).attr("y", this.y).attr("width", this.width).attr("height", this.height);
    } else {
      node.attr("opacity", 1).attr("x", this.x).attr("y", this.y).attr("width", this.width).attr("height", this.height);
    }
  }
  onClick() {
    this.select.emit(this.data);
  }
  getGradientStops() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: 0.3
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  static {
    this.\u0275fac = function TreeMapCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TreeMapCellComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TreeMapCellComponent,
      selectors: [["g", "ngx-charts-tree-map-cell", ""]],
      inputs: {
        data: "data",
        fill: "fill",
        x: "x",
        y: "y",
        width: "width",
        height: "height",
        label: "label",
        value: "value",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        gradient: "gradient",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c48,
      decls: 4,
      vars: 7,
      consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]],
      template: function TreeMapCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g");
          \u0275\u0275template(1, TreeMapCellComponent__svg_defs_1_Template, 2, 3, "defs", 0);
          \u0275\u0275elementStart(2, "rect", 1);
          \u0275\u0275listener("click", function TreeMapCellComponent_Template_rect_click_2_listener() {
            return ctx.onClick();
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.gradient);
          \u0275\u0275advance();
          \u0275\u0275attribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.width >= 70 && ctx.height >= 35);
        }
      },
      dependencies: [NgIf, CountUpDirective, SvgLinearGradientComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapCellComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tree-map-cell]",
      template: `
    <svg:g>
      <defs *ngIf="gradient">
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="orientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:rect
        [attr.fill]="gradient ? gradientUrl : fill"
        [attr.width]="width"
        [attr.height]="height"
        [attr.x]="x"
        [attr.y]="y"
        class="cell"
        (click)="onClick()"
      />
      <svg:foreignObject
        *ngIf="width >= 70 && height >= 35"
        [attr.x]="x"
        [attr.y]="y"
        [attr.width]="width"
        [attr.height]="height"
        class="treemap-label"
        [style.pointer-events]="'none'"
      >
        <xhtml:p [style.color]="getTextColor()" [style.height]="height + 'px'" [style.width]="width + 'px'">
          <xhtml:span class="treemap-label" [innerHTML]="formattedLabel"> </xhtml:span>
          <xhtml:br />
          <xhtml:span
            *ngIf="animations"
            class="treemap-val"
            ngx-charts-count-up
            [countTo]="value"
            [valueFormatting]="valueFormatting"
          >
          </xhtml:span>
          <xhtml:span *ngIf="!animations" class="treemap-val">
            {{ formattedValue }}
          </xhtml:span>
        </xhtml:p>
      </svg:foreignObject>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    data: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var TreeMapCellSeriesComponent = class _TreeMapCellSeriesComponent {
  constructor() {
    this.gradient = false;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.styleTypes = StyleTypes;
    this.placementTypes = PlacementTypes;
  }
  ngOnChanges(changes) {
    this.cells = this.getCells();
  }
  getCells() {
    return this.data.children.filter((d) => {
      return d.depth === 1;
    }).map((d, index) => {
      const label = d.id;
      return {
        data: d.data,
        x: d.x0,
        y: d.y0,
        width: d.x1 - d.x0,
        height: d.y1 - d.y0,
        fill: this.colors.getColor(label),
        label,
        value: d.value
      };
    });
  }
  getTooltipText({
    label,
    value: value2
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}</span>
    `;
  }
  onClick(data) {
    this.select.emit(data);
  }
  trackBy(index, item) {
    return item.label;
  }
  static {
    this.\u0275fac = function TreeMapCellSeriesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TreeMapCellSeriesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TreeMapCellSeriesComponent,
      selectors: [["g", "ngx-charts-tree-map-cell-series", ""]],
      inputs: {
        data: "data",
        dims: "dims",
        colors: "colors",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        gradient: "gradient",
        tooltipDisabled: "tooltipDisabled",
        tooltipTemplate: "tooltipTemplate",
        animations: "animations"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c49,
      decls: 1,
      vars: 2,
      consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "select", "data", "x", "y", "width", "height", "fill", "label", "value", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
      template: function TreeMapCellSeriesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
        }
      },
      dependencies: [NgForOf, TooltipDirective, TreeMapCellComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapCellSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tree-map-cell-series]",
      template: `
    <svg:g
      ngx-charts-tree-map-cell
      *ngFor="let c of cells; trackBy: trackBy"
      [data]="c.data"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [fill]="c.fill"
      [label]="c.label"
      [value]="c.value"
      [valueFormatting]="valueFormatting"
      [labelFormatting]="labelFormatting"
      [gradient]="gradient"
      [animations]="animations"
      (select)="onClick($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(c)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="c.data"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var TreeMapComponent = class _TreeMapComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.tooltipDisabled = false;
    this.gradient = false;
    this.select = new EventEmitter();
    this.margin = [10, 10, 10, 10];
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.domain = this.getDomain();
    this.treemap = treemap_default().size([this.dims.width, this.dims.height]);
    const rootNode = {
      name: "root",
      value: 0,
      isRoot: true
    };
    const root2 = stratify_default().id((d) => {
      let label = d.name;
      if (label.constructor.name === "Date") {
        label = label.toLocaleDateString();
      } else {
        label = label.toLocaleString();
      }
      return label;
    }).parentId((d) => d.isRoot ? null : "root")([rootNode, ...this.results]).sum((d) => d.value);
    this.data = this.treemap(root2);
    this.setColors();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getDomain() {
    return this.results.map((d) => d.name);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275TreeMapComponent_BaseFactory;
      return function TreeMapComponent_Factory(__ngFactoryType__) {
        return (\u0275TreeMapComponent_BaseFactory || (\u0275TreeMapComponent_BaseFactory = \u0275\u0275getInheritedFactory(_TreeMapComponent)))(__ngFactoryType__ || _TreeMapComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TreeMapComponent,
      selectors: [["ngx-charts-tree-map"]],
      contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        results: "results",
        tooltipDisabled: "tooltipDisabled",
        valueFormatting: "valueFormatting",
        labelFormatting: "labelFormatting",
        gradient: "gradient"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 16,
      consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "select", "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations"]],
      template: function TreeMapComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
          \u0275\u0275listener("select", function TreeMapComponent_Template_g_select_2_listener($event) {
            return ctx.onClick($event);
          });
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(13, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
        }
      },
      dependencies: [ChartComponent, TreeMapCellSeriesComponent],
      styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-tree-map",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="tree-map chart">
        <svg:g
          ngx-charts-tree-map-cell-series
          [colors]="colors"
          [data]="data"
          [dims]="dims"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="labelFormatting"
          [gradient]="gradient"
          [animations]="animations"
          (select)="onClick($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}\n"]
    }]
  }], null, {
    results: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var TreeMapModule = class _TreeMapModule {
  static {
    this.\u0275fac = function TreeMapModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TreeMapModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _TreeMapModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent],
      exports: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent]
    }]
  }], null, null);
})();
var ElementType;
(function(ElementType2) {
  ElementType2["Value"] = "value";
  ElementType2["Units"] = "units";
})(ElementType || (ElementType = {}));
var LinearGaugeComponent = class _LinearGaugeComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.min = 0;
    this.max = 100;
    this.value = 0;
    this.margin = [10, 20, 10, 20];
    this.valueResizeScale = 1;
    this.unitsResizeScale = 1;
    this.valueTextTransform = "";
    this.valueTranslate = "";
    this.unitsTextTransform = "";
    this.unitsTranslate = "";
    this.barOrientation = BarOrientation;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    setTimeout(() => {
      this.scaleText(ElementType.Value);
      this.scaleText(ElementType.Units);
    });
  }
  update() {
    super.update();
    this.hasPreviousValue = this.previousValue !== void 0;
    this.max = Math.max(this.max, this.value);
    this.min = Math.min(this.min, this.value);
    if (this.hasPreviousValue) {
      this.max = Math.max(this.max, this.previousValue);
      this.min = Math.min(this.min, this.previousValue);
    }
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.valueDomain = this.getValueDomain();
    this.valueScale = this.getValueScale();
    this.displayValue = this.getDisplayValue();
    this.setColors();
    const xOffset = this.margin[3] + this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.transform = `translate(${xOffset}, ${yOffset})`;
    this.transformLine = `translate(${this.margin[3] + this.valueScale(this.previousValue)}, ${yOffset})`;
    this.valueTranslate = `translate(0, -15)`;
    this.unitsTranslate = `translate(0, 15)`;
    if (isPlatformServer(this.platformId)) {
      this.scaleTextSSR("value");
      this.scaleTextSSR("units");
    } else {
      setTimeout(() => this.scaleText(ElementType.Value), 50);
      setTimeout(() => this.scaleText(ElementType.Units), 50);
    }
  }
  getValueDomain() {
    return [this.min, this.max];
  }
  getValueScale() {
    return linear().range([0, this.dims.width]).domain(this.valueDomain);
  }
  getDisplayValue() {
    if (this.valueFormatting) {
      return this.valueFormatting(this.value);
    }
    return this.value.toLocaleString();
  }
  scaleText(element, repeat = true) {
    let el;
    let resizeScale;
    if (element === ElementType.Value) {
      el = this.valueTextEl;
      resizeScale = this.valueResizeScale;
    } else {
      el = this.unitsTextEl;
      resizeScale = this.unitsResizeScale;
    }
    const {
      width,
      height
    } = el.nativeElement.getBoundingClientRect();
    if (width === 0 || height === 0) return;
    const oldScale = resizeScale;
    const availableWidth = this.dims.width;
    const availableHeight = Math.max(this.dims.height / 2 - 15, 0);
    const resizeScaleWidth = Math.floor(availableWidth / (width / resizeScale) * 100) / 100;
    const resizeScaleHeight = Math.floor(availableHeight / (height / resizeScale) * 100) / 100;
    resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
    if (resizeScale !== oldScale) {
      if (element === ElementType.Value) {
        this.valueResizeScale = resizeScale;
        this.valueTextTransform = `scale(${resizeScale}, ${resizeScale})`;
      } else {
        this.unitsResizeScale = resizeScale;
        this.unitsTextTransform = `scale(${resizeScale}, ${resizeScale})`;
      }
      this.cd.markForCheck();
      if (repeat && isPlatformBrowser(this.platformId)) {
        setTimeout(() => {
          this.scaleText(element, false);
        }, 50);
      }
    }
  }
  scaleTextSSR(element) {
    let resizeScale = 1;
    const value2 = element === "value" ? this.displayValue : this.units;
    const width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, value2, 10);
    const height = 25;
    const availableWidth = this.dims.width;
    const availableHeight = Math.max(this.dims.height / 2 - 15, 0);
    const resizeScaleWidth = Math.floor(availableWidth / (width / resizeScale) * 100) / 100;
    const resizeScaleHeight = Math.floor(availableHeight / (height / resizeScale) * 100) / 100;
    resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
    if (element === "value") {
      this.valueResizeScale = resizeScale;
      this.valueTextTransform = `scale(${resizeScale}, ${resizeScale})`;
    } else {
      this.unitsResizeScale = resizeScale;
      this.unitsTextTransform = `scale(${resizeScale}, ${resizeScale})`;
    }
    this.cd.markForCheck();
  }
  onClick() {
    this.select.emit({
      name: "Value",
      value: this.value
    });
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, [this.value], this.customColors);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275LinearGaugeComponent_BaseFactory;
      return function LinearGaugeComponent_Factory(__ngFactoryType__) {
        return (\u0275LinearGaugeComponent_BaseFactory || (\u0275LinearGaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_LinearGaugeComponent)))(__ngFactoryType__ || _LinearGaugeComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LinearGaugeComponent,
      selectors: [["ngx-charts-linear-gauge"]],
      viewQuery: function LinearGaugeComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c50, 5);
          \u0275\u0275viewQuery(_c51, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.valueTextEl = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.unitsTextEl = _t.first);
        }
      },
      inputs: {
        min: "min",
        max: "max",
        value: "value",
        units: "units",
        previousValue: "previousValue",
        valueFormatting: "valueFormatting"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 15,
      vars: 38,
      consts: [["valueTextEl", ""], ["unitsTextEl", ""], [3, "click", "view", "showLegend", "animations"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["alignment-baseline", "before-edge", 1, "units"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]],
      template: function LinearGaugeComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "ngx-charts-chart", 2);
          \u0275\u0275listener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onClick());
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 3);
          \u0275\u0275element(2, "g", 4)(3, "g", 5);
          \u0275\u0275template(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 6)(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 7);
          \u0275\u0275elementStart(6, "g")(7, "g")(8, "text", 8, 0);
          \u0275\u0275text(10);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(11, "g")(12, "text", 9, 1);
          \u0275\u0275text(14);
          \u0275\u0275elementEnd()()()()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(33, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275property("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", \u0275\u0275pureFunction0(36, _c52))("orientation", ctx.barOrientation.Horizontal)("roundEdges", true)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275property("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", \u0275\u0275pureFunction0(37, _c52))("orientation", ctx.barOrientation.Horizontal)("roundEdges", true)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.hasPreviousValue);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.hasPreviousValue);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.valueTranslate);
          \u0275\u0275advance();
          \u0275\u0275styleProp("text-anchor", "middle");
          \u0275\u0275attribute("transform", ctx.valueTextTransform);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate1(" ", ctx.displayValue, " ");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.unitsTranslate);
          \u0275\u0275advance();
          \u0275\u0275styleProp("text-anchor", "middle");
          \u0275\u0275attribute("transform", ctx.unitsTextTransform);
          \u0275\u0275advance(2);
          \u0275\u0275textInterpolate1(" ", ctx.units, " ");
        }
      },
      dependencies: [NgIf, ChartComponent, BarComponent],
      styles: [_c25, ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:#0000000d}.linear-gauge .units{fill:#666}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinearGaugeComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-linear-gauge",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations" (click)="onClick()">
      <svg:g class="linear-gauge chart">
        <svg:g
          ngx-charts-bar
          class="background-bar"
          [width]="dims.width"
          [height]="3"
          [x]="margin[3]"
          [y]="dims.height / 2 + margin[0] - 2"
          [data]="{}"
          [orientation]="barOrientation.Horizontal"
          [roundEdges]="true"
          [animations]="animations"
        ></svg:g>
        <svg:g
          ngx-charts-bar
          [width]="valueScale(value)"
          [height]="3"
          [x]="margin[3]"
          [y]="dims.height / 2 + margin[0] - 2"
          [fill]="colors.getColor(units)"
          [data]="{}"
          [orientation]="barOrientation.Horizontal"
          [roundEdges]="true"
          [animations]="animations"
        ></svg:g>

        <svg:line
          *ngIf="hasPreviousValue"
          [attr.transform]="transformLine"
          x1="0"
          y1="5"
          x2="0"
          y2="15"
          [attr.stroke]="colors.getColor(units)"
        />

        <svg:line
          *ngIf="hasPreviousValue"
          [attr.transform]="transformLine"
          x1="0"
          y1="-5"
          x2="0"
          y2="-15"
          [attr.stroke]="colors.getColor(units)"
        />

        <svg:g [attr.transform]="transform">
          <svg:g [attr.transform]="valueTranslate">
            <svg:text
              #valueTextEl
              class="value"
              [style.textAnchor]="'middle'"
              [attr.transform]="valueTextTransform"
              alignment-baseline="after-edge"
            >
              {{ displayValue }}
            </svg:text>
          </svg:g>

          <svg:g [attr.transform]="unitsTranslate">
            <svg:text
              #unitsTextEl
              class="units"
              [style.textAnchor]="'middle'"
              [attr.transform]="unitsTextTransform"
              alignment-baseline="before-edge"
            >
              {{ units }}
            </svg:text>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:#0000000d}.linear-gauge .units{fill:#666}\n"]
    }]
  }], null, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    units: [{
      type: Input
    }],
    previousValue: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    valueTextEl: [{
      type: ViewChild,
      args: ["valueTextEl"]
    }],
    unitsTextEl: [{
      type: ViewChild,
      args: ["unitsTextEl"]
    }]
  });
})();
var GaugeArcComponent = class _GaugeArcComponent {
  constructor() {
    this.isActive = false;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  tooltipText(arc) {
    const label = formatLabel(arc.data.name);
    let val;
    if (this.valueFormatting) {
      val = this.valueFormatting(arc.data.value);
    } else {
      val = formatLabel(arc.data.value);
    }
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
  static {
    this.\u0275fac = function GaugeArcComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GaugeArcComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _GaugeArcComponent,
      selectors: [["g", "ngx-charts-gauge-arc", ""]],
      inputs: {
        backgroundArc: "backgroundArc",
        valueArc: "valueArc",
        cornerRadius: "cornerRadius",
        colors: "colors",
        isActive: "isActive",
        tooltipDisabled: "tooltipDisabled",
        valueFormatting: "valueFormatting",
        tooltipTemplate: "tooltipTemplate",
        animations: "animations"
      },
      outputs: {
        select: "select",
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      attrs: _c53,
      decls: 2,
      vars: 23,
      consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
      template: function GaugeArcComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275element(0, "g", 0);
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275listener("select", function GaugeArcComponent_Template_g_select_1_listener($event) {
            return ctx.select.emit($event);
          })("activate", function GaugeArcComponent_Template_g_activate_1_listener($event) {
            return ctx.activate.emit($event);
          })("deactivate", function GaugeArcComponent_Template_g_deactivate_1_listener($event) {
            return ctx.deactivate.emit($event);
          });
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
          \u0275\u0275advance();
          \u0275\u0275property("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.placementTypes.Top)("tooltipType", ctx.styleTypes.tooltip)("tooltipTitle", ctx.tooltipTemplate ? void 0 : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
        }
      },
      dependencies: [TooltipDirective, PieArcComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeArcComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-gauge-arc]",
      template: `
    <svg:g
      ngx-charts-pie-arc
      class="background-arc"
      [startAngle]="0"
      [endAngle]="backgroundArc.endAngle"
      [innerRadius]="backgroundArc.innerRadius"
      [outerRadius]="backgroundArc.outerRadius"
      [cornerRadius]="cornerRadius"
      [data]="backgroundArc.data"
      [animate]="false"
      [pointerEvents]="false"
    ></svg:g>
    <svg:g
      ngx-charts-pie-arc
      [startAngle]="0"
      [endAngle]="valueArc.endAngle"
      [innerRadius]="valueArc.innerRadius"
      [outerRadius]="valueArc.outerRadius"
      [cornerRadius]="cornerRadius"
      [fill]="colors.getColor(valueArc.data.name)"
      [data]="valueArc.data"
      [animate]="animations"
      [isActive]="isActive"
      (select)="select.emit($event)"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(valueArc)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="valueArc.data"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    backgroundArc: [{
      type: Input
    }],
    valueArc: [{
      type: Input
    }],
    cornerRadius: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var GaugeAxisComponent = class _GaugeAxisComponent {
  constructor() {
    this.rotate = "";
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.rotationAngle = -90 + this.startAngle;
    this.rotate = `rotate(${this.rotationAngle})`;
    this.ticks = this.getTicks();
  }
  getTicks() {
    const bigTickSegment = this.angleSpan / this.bigSegments;
    const smallTickSegment = bigTickSegment / this.smallSegments;
    const tickLength = 20;
    const ticks = {
      big: [],
      small: []
    };
    const startDistance = this.radius + 10;
    const textDist = startDistance + tickLength + 10;
    for (let i = 0; i <= this.bigSegments; i++) {
      const angleDeg = i * bigTickSegment;
      const angle = angleDeg * Math.PI / 180;
      const textAnchor = this.getTextAnchor(angleDeg);
      let skip = false;
      if (i === 0 && this.angleSpan === 360) {
        skip = true;
      }
      if (!skip) {
        let text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
        if (this.tickFormatting) {
          text = this.tickFormatting(text);
        }
        ticks.big.push({
          line: this.getTickPath(startDistance, tickLength, angle),
          textAnchor,
          text,
          textTransform: `
            translate(${textDist * Math.cos(angle)}, ${textDist * Math.sin(angle)}) rotate(${-this.rotationAngle})
          `
        });
      }
      if (i === this.bigSegments) {
        continue;
      }
      for (let j = 1; j <= this.smallSegments; j++) {
        const smallAngleDeg = angleDeg + j * smallTickSegment;
        const smallAngle = smallAngleDeg * Math.PI / 180;
        ticks.small.push({
          line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
        });
      }
    }
    return ticks;
  }
  getTextAnchor(angle) {
    angle = (this.startAngle + angle) % 360;
    let textAnchor = TextAnchor.Middle;
    if (angle > 45 && angle <= 135) {
      textAnchor = TextAnchor.Start;
    } else if (angle > 225 && angle <= 315) {
      textAnchor = TextAnchor.End;
    }
    return textAnchor;
  }
  getTickPath(startDistance, tickLength, angle) {
    const y1 = startDistance * Math.sin(angle);
    const y2 = (startDistance + tickLength) * Math.sin(angle);
    const x1 = startDistance * Math.cos(angle);
    const x2 = (startDistance + tickLength) * Math.cos(angle);
    const points = [{
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    }];
    const lineGenerator = line_default().x((d) => d.x).y((d) => d.y);
    return lineGenerator(points);
  }
  static {
    this.\u0275fac = function GaugeAxisComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GaugeAxisComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _GaugeAxisComponent,
      selectors: [["g", "ngx-charts-gauge-axis", ""]],
      inputs: {
        bigSegments: "bigSegments",
        smallSegments: "smallSegments",
        min: "min",
        max: "max",
        angleSpan: "angleSpan",
        startAngle: "startAngle",
        radius: "radius",
        valueScale: "valueScale",
        tickFormatting: "tickFormatting"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      attrs: _c54,
      decls: 4,
      vars: 4,
      consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]],
      template: function GaugeAxisComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(0, "g");
          \u0275\u0275template(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0)(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0)(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275attribute("transform", ctx.rotate);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks.big);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks.big);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks.small);
        }
      },
      dependencies: [NgForOf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-gauge-axis]",
      template: `
    <svg:g [attr.transform]="rotate">
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:text
          [style.textAnchor]="tick.textAnchor"
          [attr.transform]="tick.textTransform"
          alignment-baseline="central"
        >
          {{ tick.text }}
        </svg:text>
      </svg:g>
      <svg:g *ngFor="let tick of ticks.small" class="gauge-tick gauge-tick-small">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    bigSegments: [{
      type: Input
    }],
    smallSegments: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    angleSpan: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    radius: [{
      type: Input
    }],
    valueScale: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }]
  });
})();
var GaugeComponent = class _GaugeComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.min = 0;
    this.max = 100;
    this.bigSegments = 10;
    this.smallSegments = 5;
    this.showAxis = true;
    this.startAngle = -120;
    this.angleSpan = 240;
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.showText = true;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.resizeScale = 1;
    this.rotation = "";
    this.textTransform = "scale(1, 1)";
    this.cornerRadius = 10;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    setTimeout(() => this.scaleText());
  }
  update() {
    super.update();
    if (!this.showAxis) {
      if (!this.margin) {
        this.margin = [10, 20, 10, 20];
      }
    } else {
      if (!this.margin) {
        this.margin = [60, 100, 60, 100];
      }
    }
    if (this.startAngle < 0) {
      this.startAngle = this.startAngle % 360 + 360;
    }
    this.angleSpan = Math.min(this.angleSpan, 360);
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.domain = this.getDomain();
    this.valueDomain = this.getValueDomain();
    this.valueScale = this.getValueScale();
    this.displayValue = this.getDisplayValue();
    this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
    this.arcs = this.getArcs();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    const xOffset = this.margin[3] + this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.transform = `translate(${xOffset}, ${yOffset})`;
    this.rotation = `rotate(${this.startAngle})`;
    setTimeout(() => this.scaleText(), 50);
  }
  getArcs() {
    const arcs = [];
    const availableRadius = this.outerRadius * 0.7;
    const radiusPerArc = Math.min(availableRadius / this.results.length, 10);
    const arcWidth = radiusPerArc * 0.7;
    this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
    this.cornerRadius = Math.floor(arcWidth / 2);
    let i = 0;
    for (const d of this.results) {
      const outerRadius = this.outerRadius - i * radiusPerArc;
      const innerRadius = outerRadius - arcWidth;
      const backgroundArc = {
        endAngle: this.angleSpan * Math.PI / 180,
        innerRadius,
        outerRadius,
        data: {
          value: this.max,
          name: d.name
        }
      };
      const valueArc = {
        endAngle: Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI / 180,
        innerRadius,
        outerRadius,
        data: {
          value: d.value,
          name: d.name
        }
      };
      const arc = {
        backgroundArc,
        valueArc
      };
      arcs.push(arc);
      i++;
    }
    return arcs;
  }
  getDomain() {
    return this.results.map((d) => d.name);
  }
  getValueDomain() {
    const values = this.results.map((d) => d.value);
    const dataMin = Math.min(...values);
    const dataMax = Math.max(...values);
    if (this.min !== void 0) {
      this.min = Math.min(this.min, dataMin);
    } else {
      this.min = dataMin;
    }
    if (this.max !== void 0) {
      this.max = Math.max(this.max, dataMax);
    } else {
      this.max = dataMax;
    }
    return [this.min, this.max];
  }
  getValueScale() {
    return linear().range([0, this.angleSpan]).nice().domain(this.valueDomain);
  }
  getDisplayValue() {
    const value2 = this.results.map((d) => d.value).reduce((a, b) => a + b, 0);
    if (this.textValue && 0 !== this.textValue.length) {
      return this.textValue.toLocaleString();
    }
    if (this.valueFormatting) {
      return this.valueFormatting(value2);
    }
    return value2.toLocaleString();
  }
  scaleText(repeat = true) {
    if (!this.showText) {
      return;
    }
    const {
      width
    } = this.textEl.nativeElement.getBoundingClientRect();
    const oldScale = this.resizeScale;
    if (width === 0) {
      this.resizeScale = 1;
    } else {
      const availableSpace = this.textRadius;
      this.resizeScale = Math.floor(availableSpace / (width / this.resizeScale) * 100) / 100;
    }
    if (this.resizeScale !== oldScale) {
      this.textTransform = `scale(${this.resizeScale}, ${this.resizeScale})`;
      this.cd.markForCheck();
      if (repeat) {
        setTimeout(() => this.scaleText(false), 50);
      }
    }
  }
  onClick(data) {
    this.select.emit(data);
  }
  getLegendOptions() {
    return {
      scaleType: ScaleType.Ordinal,
      colors: this.colors,
      domain: this.domain,
      title: this.legendTitle,
      position: this.legendPosition
    };
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name && entry.series === d.series;
    });
    return item !== void 0;
  }
  trackBy(index, item) {
    return item.valueArc.data.name;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275GaugeComponent_BaseFactory;
      return function GaugeComponent_Factory(__ngFactoryType__) {
        return (\u0275GaugeComponent_BaseFactory || (\u0275GaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_GaugeComponent)))(__ngFactoryType__ || _GaugeComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _GaugeComponent,
      selectors: [["ngx-charts-gauge"]],
      contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      viewQuery: function GaugeComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c45, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textEl = _t.first);
        }
      },
      inputs: {
        legend: "legend",
        legendTitle: "legendTitle",
        legendPosition: "legendPosition",
        min: "min",
        max: "max",
        textValue: "textValue",
        units: "units",
        bigSegments: "bigSegments",
        smallSegments: "smallSegments",
        results: "results",
        showAxis: "showAxis",
        startAngle: "startAngle",
        angleSpan: "angleSpan",
        activeEntries: "activeEntries",
        axisTickFormatting: "axisTickFormatting",
        tooltipDisabled: "tooltipDisabled",
        valueFormatting: "valueFormatting",
        showText: "showText",
        margin: "margin"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 13,
      consts: [["textEl", ""], [3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "select", "activate", "deactivate", "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]],
      template: function GaugeComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 1);
          \u0275\u0275listener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
            return ctx.onClick($event);
          })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
            return ctx.onActivate($event);
          })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
            return ctx.onDeactivate($event);
          });
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 2);
          \u0275\u0275template(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 3)(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 4)(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 5);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showAxis);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showText);
        }
      },
      dependencies: [NgForOf, NgIf, ChartComponent, GaugeArcComponent, GaugeAxisComponent],
      styles: [_c25, ".gauge .background-arc path{fill:#0000000d}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-gauge",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g [attr.transform]="transform" class="gauge chart">
        <svg:g *ngFor="let arc of arcs; trackBy: trackBy" [attr.transform]="rotation">
          <svg:g
            ngx-charts-gauge-arc
            [backgroundArc]="arc.backgroundArc"
            [valueArc]="arc.valueArc"
            [cornerRadius]="cornerRadius"
            [colors]="colors"
            [isActive]="isActive(arc.valueArc.data)"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [valueFormatting]="valueFormatting"
            [animations]="animations"
            (select)="onClick($event)"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
          ></svg:g>
        </svg:g>

        <svg:g
          ngx-charts-gauge-axis
          *ngIf="showAxis"
          [bigSegments]="bigSegments"
          [smallSegments]="smallSegments"
          [min]="min"
          [max]="max"
          [radius]="outerRadius"
          [angleSpan]="angleSpan"
          [valueScale]="valueScale"
          [startAngle]="startAngle"
          [tickFormatting]="axisTickFormatting"
        ></svg:g>

        <svg:text
          #textEl
          *ngIf="showText"
          [style.textAnchor]="'middle'"
          [attr.transform]="textTransform"
          alignment-baseline="central"
        >
          <tspan x="0" dy="0">{{ displayValue }}</tspan>
          <tspan x="0" dy="1.2em">{{ units }}</tspan>
        </svg:text>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".gauge .background-arc path{fill:#0000000d}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    textValue: [{
      type: Input
    }],
    units: [{
      type: Input
    }],
    bigSegments: [{
      type: Input
    }],
    smallSegments: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    showAxis: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    angleSpan: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    axisTickFormatting: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    showText: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    textEl: [{
      type: ViewChild,
      args: ["textEl"]
    }]
  });
})();
var PercentGaugeComponent = class _PercentGaugeComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.max = 100;
    this.value = 0;
    this.target = 75;
    this.targetLabel = "Target";
    this.showLabel = true;
    this.defaultMargin = [20, 40, 20, 40];
    this.margin = [20, 40, 20, 40];
    this.circleMaskId = `circleMask${id()}`;
    this.ticks = [];
  }
  update() {
    super.update();
    this.margin = [...this.defaultMargin];
    if (this.showLabel) {
      this.margin[2] = 50;
    }
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.percent = this.getPercentage();
    this.ticHeight = Math.min(this.dims.width, this.dims.height) / 10;
    this.radius = Math.min(this.dims.width, this.dims.height) / 2 - this.ticHeight / 2;
    this.circumference = 2 * Math.PI * this.radius;
    this.dashes = `${this.radius / 60} ${this.circumference / 60 - this.radius / 60}`;
    this.valueFontSize = Math.floor(this.radius / 3);
    this.targetRadius = this.radius / 4;
    this.targetTextTransform = `translate(${-this.targetRadius / 2}, ${-this.targetRadius / 2}), scale(${this.targetRadius / 28})`;
    this.valueDomain = this.getValueDomain();
    this.displayValue = this.getDisplayValue();
    this.setColors();
    this.targetColor = this.colors.getColor(this.target / 100 * this.max);
    const xOffset = this.margin[3] + this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.transform = `translate(${xOffset}, ${yOffset})`;
    this.labelTransform = `translate(0, ${this.height / 2 + this.radius + this.margin[0] + this.ticHeight / 2 - 3})`;
    const angle = this.target / 100 * Math.PI * 2 - Math.PI / 2;
    this.targetTransform = `translate(${this.radius * 0.97 * Math.cos(angle) + this.targetRadius / 2}, ${this.radius * 0.97 * Math.sin(angle) + this.targetRadius / 2})`;
    this.generateticks();
    this.cd.markForCheck();
  }
  generateCirclePoints(radius, numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
      const angle = i / numPoints * 2 * Math.PI;
      const x2 = radius * Math.cos(angle);
      const y2 = radius * Math.sin(angle);
      points.push({
        x: x2,
        y: y2
      });
    }
    return points;
  }
  generateticks() {
    const numPoints = 60;
    const points = this.generateCirclePoints(this.radius, numPoints);
    this.ticks = [];
    this.circleTransform = `rotate(-90,0,0)`;
    for (let j = 0; j < points.length; j++) {
      const {
        x: x2,
        y: y2
      } = points[j];
      let progress = j / numPoints;
      if (progress === 1) {
        progress = 0;
      }
      this.ticks.push({
        height: this.ticHeight,
        width: this.radius / 60,
        fill: this.colors.getColor(progress * this.max),
        transform: `translate(${x2}, ${y2}), rotate(${360 * progress - 90})`
      });
    }
  }
  getValueDomain() {
    return [0, this.max];
  }
  getDisplayValue() {
    if (this.valueFormatting) {
      return this.valueFormatting(this.value);
    }
    return this.percent + "%";
  }
  getPercentage() {
    return Math.round(this.value / this.max * 100);
  }
  onClick() {
    this.select.emit({
      name: "Value",
      value: this.value
    });
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Linear, this.valueDomain, this.customColors);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275PercentGaugeComponent_BaseFactory;
      return function PercentGaugeComponent_Factory(__ngFactoryType__) {
        return (\u0275PercentGaugeComponent_BaseFactory || (\u0275PercentGaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PercentGaugeComponent)))(__ngFactoryType__ || _PercentGaugeComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _PercentGaugeComponent,
      selectors: [["ngx-charts-percent-gauge"]],
      inputs: {
        max: "max",
        value: "value",
        target: "target",
        targetLabel: "targetLabel",
        label: "label",
        valueFormatting: "valueFormatting",
        showLabel: "showLabel"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 20,
      vars: 40,
      consts: [[3, "view", "showLegend", "animations"], [1, "percent-gauge", "chart", 3, "click"], ["cx", "0", "cy", "0", "stroke", "white", "fill", "transparent", "transform", "rotate(-90,0,0)"], ["x", "0", "y", "0", "stroke", "none", 1, "total"], ["cx", "0", "cy", "0", "fill", "none", 1, "dashes-back"], [4, "ngFor", "ngForOf"], [1, "target-circle-bg"], ["class", "target-circle", 3, "stroke-width", 4, "ngIf"], ["transform", "translate(0, -4)", "stroke", "none", "text-anchor", "middle", 1, "target-label"], ["transform", "translate(0, 11)", "stroke", "none", "text-anchor", "middle", 1, "target-value"], [4, "ngIf"], [1, "target-circle"], ["x", "50%", "dominant-baseline", "middle", "text-anchor", "middle", "stroke", "none", 1, "gauge-label"]],
      template: function PercentGaugeComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275listener("click", function PercentGaugeComponent_Template_g_click_1_listener() {
            return ctx.onClick();
          });
          \u0275\u0275elementStart(2, "g")(3, "mask");
          \u0275\u0275element(4, "circle", 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(5, "text", 3);
          \u0275\u0275text(6);
          \u0275\u0275elementEnd();
          \u0275\u0275element(7, "circle", 4);
          \u0275\u0275elementStart(8, "g")(9, "g");
          \u0275\u0275template(10, PercentGaugeComponent__svg_g_10_Template, 2, 6, "g", 5);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(11, "g");
          \u0275\u0275element(12, "circle", 6);
          \u0275\u0275template(13, PercentGaugeComponent__svg_circle_13_Template, 1, 6, "circle", 7);
          \u0275\u0275elementStart(14, "g")(15, "text", 8);
          \u0275\u0275text(16);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(17, "text", 9);
          \u0275\u0275text(18);
          \u0275\u0275elementEnd()()()();
          \u0275\u0275template(19, PercentGaugeComponent__svg_g_19_Template, 3, 2, "g", 10);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(37, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
          \u0275\u0275advance(2);
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275attribute("id", ctx.circleMaskId);
          \u0275\u0275advance();
          \u0275\u0275styleProp("stroke-width", ctx.radius / 5)("stroke-dashoffset", ctx.circumference * (1 - ctx.percent / 100));
          \u0275\u0275attribute("r", ctx.radius)("stroke-dasharray", ctx.circumference);
          \u0275\u0275advance();
          \u0275\u0275styleProp("font-size", ctx.valueFontSize);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.displayValue, " ");
          \u0275\u0275advance();
          \u0275\u0275styleProp("stroke-width", ctx.radius / 5)("stroke-dasharray", ctx.dashes);
          \u0275\u0275attribute("r", ctx.radius);
          \u0275\u0275advance();
          \u0275\u0275attribute("mask", "url(#" + ctx.circleMaskId + ")");
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.circleTransform);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.ticks);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.targetTransform);
          \u0275\u0275advance();
          \u0275\u0275styleProp("stroke-width", ctx.targetRadius / 10);
          \u0275\u0275attribute("r", ctx.targetRadius)("cx", -ctx.targetRadius / 2)("cy", -ctx.targetRadius / 2);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.percent >= ctx.target);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.targetTextTransform);
          \u0275\u0275advance();
          \u0275\u0275styleProp("font-size", 12);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.targetLabel, " ");
          \u0275\u0275advance();
          \u0275\u0275styleProp("font-size", 14);
          \u0275\u0275advance();
          \u0275\u0275textInterpolate1(" ", ctx.target, "% ");
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showLabel);
        }
      },
      dependencies: [NgForOf, NgIf, ChartComponent],
      styles: [_c25, ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#e7e7e7}.percent-gauge .target-circle,.percent-gauge .target-circle-bg{fill:#fff}.percent-gauge .target-circle-bg{stroke:#e7e7e7}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentGaugeComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-percent-gauge",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g class="percent-gauge chart" (click)="onClick()">
        <svg:g [attr.transform]="transform">
          <mask [attr.id]="circleMaskId">
            <circle
              [attr.r]="radius"
              [style.stroke-width]="radius / 5"
              cx="0"
              cy="0"
              stroke="white"
              fill="transparent"
              [attr.stroke-dasharray]="circumference"
              transform="rotate(-90,0,0)"
              [style.stroke-dashoffset]="circumference * (1 - percent / 100)"
            />
          </mask>
          <text x="0" y="0" stroke="none" class="total" [style.font-size]="valueFontSize">
            {{ displayValue }}
          </text>
          <circle
            class="dashes-back"
            [style.stroke-width]="radius / 5"
            [attr.r]="radius"
            cx="0"
            cy="0"
            fill="none"
            [style.stroke-dasharray]="dashes"
          />

          <svg:g [attr.mask]="'url(#' + circleMaskId + ')'">
            <svg:g [attr.transform]="circleTransform">
              <svg:g *ngFor="let tic of ticks" [attr.transform]="tic.transform">
                <rect
                  [attr.y]="-tic.height / 2"
                  [attr.x]="-tic.width"
                  [attr.width]="tic.width"
                  [attr.height]="tic.height"
                  [attr.fill]="tic.fill"
                />
              </svg:g>
            </svg:g>
          </svg:g>

          <svg:g [attr.transform]="targetTransform">
            <circle
              class="target-circle-bg"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <circle
              *ngIf="percent >= target"
              class="target-circle"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.stroke]="targetColor"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <svg:g [attr.transform]="targetTextTransform">
              <text
                transform="translate(0, -4)"
                class="target-label"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="12"
              >
                {{ targetLabel }}
              </text>
              <text
                transform="translate(0, 11)"
                class="target-value"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="14"
              >
                {{ target }}%
              </text>
            </svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="showLabel" [attr.transform]="labelTransform">
          <text class="gauge-label" x="50%" dominant-baseline="middle" text-anchor="middle" stroke="none">
            {{ label }}
          </text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#e7e7e7}.percent-gauge .target-circle,.percent-gauge .target-circle-bg{fill:#fff}.percent-gauge .target-circle-bg{stroke:#e7e7e7}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"]
    }]
  }], null, {
    max: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    targetLabel: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    showLabel: [{
      type: Input
    }]
  });
})();
var GaugeModule = class _GaugeModule {
  static {
    this.\u0275fac = function GaugeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GaugeModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _GaugeModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule, PieChartModule, BarChartModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule, PieChartModule, BarChartModule],
      declarations: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent, PercentGaugeComponent],
      exports: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent, PercentGaugeComponent]
    }]
  }], null, null);
})();
function ngxChartsPolyfills() {
  if (typeof SVGElement !== "undefined" && typeof SVGElement.prototype.contains === "undefined") {
    SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
  }
}
var SankeyComponent = class _SankeyComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.showLabels = true;
    this.tooltipDisabled = false;
    this.activeEntries = [];
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 10, 10, 10];
    this.scaleType = ScaleType.Ordinal;
    this.styleTypes = StyleTypes;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      legendType: this.scaleType
    });
    const linkDefs = this.results;
    const nodeDefs = Array.from(new Set(linkDefs.flatMap((l) => [l.source, l.target])), (name) => ({
      name,
      value: linkDefs.filter((l) => l.source === name).reduce((acc, l) => acc + l.value, 0)
    }));
    const sankeyGenerator = Sankey().nodeId((d) => d.name).nodeAlign(left).nodeWidth(15).nodePadding(10).extent([[1, 5], [this.dims.width - 1, this.dims.height - 5]]);
    const data = sankeyGenerator({
      nodes: nodeDefs.map((d) => Object.assign({}, d)),
      links: linkDefs.map((d) => Object.assign({}, d))
    });
    this.valueDomain = this.getValueDomain(data.nodes);
    this.setColors();
    this.nodeRects = data.nodes.map((node) => {
      const rect = {
        x: node.x0,
        y: node.y0,
        height: node.y1 - node.y0,
        width: node.x1 - node.x0,
        fill: this.colors.getColor(node.name),
        tooltip: this.getNodeTooltipText(node),
        rx: 5,
        data: {
          name: node.name,
          value: node.value
        },
        transform: "",
        label: this.labelFormatting ? this.labelFormatting(node.name) : node.name,
        labelAnchor: TextAnchor.Start
      };
      rect.labelAnchor = this.getTextAnchor(node);
      rect.transform = `translate(${rect.x},${rect.y})`;
      return rect;
    });
    this.linkPaths = data.links.map((link2) => {
      const gradientId = "mask" + id().toString();
      const linkPath = {
        path: sankeyLinkHorizontal_default()(link2),
        strokeWidth: Math.max(1, link2.width),
        tooltip: this.getLinkTooltipText(link2.source, link2.target, link2.value),
        id: gradientId,
        gradientFill: `url(#${gradientId})`,
        source: link2.source,
        target: link2.target,
        startColor: this.colors.getColor(link2.source.name),
        endColor: this.colors.getColor(link2.target.name),
        data: {
          source: link2.source.name,
          target: link2.target.name,
          value: link2.value
        }
      };
      return linkPath;
    });
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getNodeTooltipText(node) {
    return `
      <span class="tooltip-label">${escapeLabel(node.name)}</span>
      <span class="tooltip-val">${node.value.toLocaleString()}</span>
    `;
  }
  getLinkTooltipText(sourceNode, targetNode, value2) {
    return `
      <span class="tooltip-label">${escapeLabel(sourceNode.name)} \u2022 ${escapeLabel(targetNode.name)}</span>
      <span class="tooltip-val">${value2.toLocaleString()} (${(value2 / sourceNode.value).toLocaleString(void 0, {
      style: "percent",
      maximumFractionDigits: 2
    })})</span>
    `;
  }
  getTextAnchor(node) {
    if (node.layer === 0) {
      return TextAnchor.Start;
    } else {
      return TextAnchor.End;
    }
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
  }
  getValueDomain(nodes) {
    return nodes.map((n) => n.name);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275SankeyComponent_BaseFactory;
      return function SankeyComponent_Factory(__ngFactoryType__) {
        return (\u0275SankeyComponent_BaseFactory || (\u0275SankeyComponent_BaseFactory = \u0275\u0275getInheritedFactory(_SankeyComponent)))(__ngFactoryType__ || _SankeyComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SankeyComponent,
      selectors: [["ngx-charts-sankey"]],
      contentQueries: function SankeyComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, _c22, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
        }
      },
      inputs: {
        showLabels: "showLabels",
        gradient: "gradient",
        tooltipDisabled: "tooltipDisabled",
        activeEntries: "activeEntries",
        labelFormatting: "labelFormatting"
      },
      outputs: {
        activate: "activate",
        deactivate: "deactivate"
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 9,
      consts: [[3, "view", "animations"], [1, "sankey", "chart"], ["class", "link", "ngx-tooltip", "", 3, "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", 4, "ngFor", "ngForOf"], ["class", "node", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], ["ngx-tooltip", "", 1, "link", 3, "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["gradientUnits", "userSpaceOnUse"], ["offset", "0%"], ["offset", "100%"], ["stroke-opacity", "0.5", "fill", "none", 3, "click", "mouseenter"], [1, "node"], ["ngx-tooltip", "", 3, "click", "mouseenter", "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["class", "label", "dy", "0.35em", 4, "ngIf"], ["dy", "0.35em", 1, "label"]],
      template: function SankeyComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "g", 1);
          \u0275\u0275template(2, SankeyComponent__svg_g_2_Template, 6, 14, "g", 2)(3, SankeyComponent__svg_g_3_Template, 2, 12, "g", 3)(4, SankeyComponent__svg_g_4_Template, 2, 2, "g", 4);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("view", \u0275\u0275pureFunction2(6, _c24, ctx.width, ctx.height))("animations", ctx.animations);
          \u0275\u0275advance();
          \u0275\u0275attribute("transform", ctx.transform);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.linkPaths);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.nodeRects);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.nodeRects);
        }
      },
      dependencies: [NgForOf, NgIf, TooltipDirective, ChartComponent],
      styles: [_c25],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-sankey",
      template: `
    <ngx-charts-chart [view]="[width, height]" [animations]="animations">
      <svg:g [attr.transform]="transform" class="sankey chart">
        <svg:g
          *ngFor="let link of linkPaths"
          class="link"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipType]="styleTypes.tooltip"
          [tooltipPlacement]="'top'"
          [tooltipTitle]="tooltipTemplate ? undefined : link.tooltip"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="link.data"
        >
          <svg:defs>
            <svg:linearGradient
              [attr.id]="link.id"
              gradientUnits="userSpaceOnUse"
              [attr.x1]="link.source.x1"
              [attr.x2]="link.target.x0"
            >
              <svg:stop offset="0%" [attr.stop-color]="link.startColor"></svg:stop>
              <svg:stop offset="100%" [attr.stop-color]="link.endColor"></svg:stop>
            </svg:linearGradient>
          </svg:defs>
          <svg:path
            [attr.d]="link.path"
            [attr.stroke]="link.gradientFill"
            [attr.stroke-width]="link.strokeWidth"
            stroke-opacity="0.5"
            fill="none"
            (click)="select.emit(link.data)"
            (mouseenter)="activate.emit(link.data)"
          ></svg:path>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform" class="node">
          <svg:rect
            [attr.x]="0"
            [attr.y]="0"
            [attr.width]="rect.width"
            [attr.height]="rect.height"
            [attr.fill]="rect.fill"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipType]="styleTypes.tooltip"
            [tooltipPlacement]="'top'"
            [tooltipTitle]="tooltipTemplate ? undefined : rect.tooltip"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="rect.data"
            (click)="select.emit(rect.data)"
            (mouseenter)="activate.emit(rect.data)"
          ></svg:rect>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform">
          <svg:text
            *ngIf="showLabels && rect.height > 15"
            class="label"
            [attr.x]="rect.width + 5"
            [attr.y]="rect.height / 2"
            [attr.text-anchor]="rect.labelAnchor"
            dy="0.35em"
            [attr.dx]="rect.labelAnchor === 'end' ? -25 : 0"
          >
            {{ rect.label }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    showLabels: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var SankeyModule = class _SankeyModule {
  static {
    this.\u0275fac = function SankeyModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SankeyModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _SankeyModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [SankeyComponent],
      exports: [SankeyComponent]
    }]
  }], null, null);
})();
var NgxChartsModule = class _NgxChartsModule {
  constructor() {
    ngxChartsPolyfills();
  }
  static {
    this.\u0275fac = function NgxChartsModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxChartsModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _NgxChartsModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [ChartCommonModule, AreaChartModule, BarChartModule, BoxChartModule, BubbleChartModule, HeatMapModule, SankeyModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxChartsModule, [{
    type: NgModule,
    args: [{
      exports: [ChartCommonModule, AreaChartModule, BarChartModule, BoxChartModule, BubbleChartModule, HeatMapModule, SankeyModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule]
    }]
  }], () => [], null);
})();

// src/app/main/employee/profile/components/organization-tree/organization-tree.component.ts
var _c04 = ["graphContainer"];
function OrganizationTreeTabComponent_div_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("click", function OrganizationTreeTabComponent_div_0_ng_template_3_Template_g_click_0_listener($event) {
      const node_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onNodeClick($event, node_r4));
    });
    \u0275\u0275element(1, "rect", 7)(2, "circle", 8)(3, "image", 9);
    \u0275\u0275pipe(4, "async");
    \u0275\u0275elementStart(5, "text", 10);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "text", 11);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "text", 12);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "text", 13);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "clipPath", 14);
    \u0275\u0275element(14, "rect");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "clipPath", 15);
    \u0275\u0275element(16, "circle", 16);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const node_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275attribute("width", node_r4.dimension.width)("height", node_r4.dimension.height)("fill", node_r4.color)("stroke", node_r4.stroke)("stroke-width", 3);
    \u0275\u0275advance();
    \u0275\u0275attribute("fill", node_r4.stroke);
    \u0275\u0275advance();
    \u0275\u0275attribute("width", 40)("height", 40)("href", \u0275\u0275pipeBind1(4, 28, node_r4.data.avatar_src))("clip-path", "url(#clipCircle)");
    \u0275\u0275advance(2);
    \u0275\u0275attribute("width", 40)("height", 40);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r4.data.sign, " ");
    \u0275\u0275advance();
    \u0275\u0275attribute("x", node_r4.dimension.width - 10)("fill", node_r4.colorTitle)("title", node_r4.label)("clip-path", "url(#clipText)");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r4.label, " ");
    \u0275\u0275advance();
    \u0275\u0275attribute("x", node_r4.dimension.width - 10)("fill", node_r4.colorEmail)("clip-path", "url(#clipText)");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r4.data.email, " ");
    \u0275\u0275advance();
    \u0275\u0275attribute("x", node_r4.dimension.width - 10)("fill", node_r4.colorJob)("clip-path", "url(#clipText)");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", node_r4.data.job_position, " ");
    \u0275\u0275advance(2);
    \u0275\u0275attribute("width", node_r4.dimension.width)("height", node_r4.dimension.height);
  }
}
function OrganizationTreeTabComponent_div_0_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 17);
  }
  if (rf & 2) {
    const link_r5 = ctx.$implicit;
    \u0275\u0275attribute("d", link_r5.line);
  }
}
function OrganizationTreeTabComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "ngx-graph", 5, 0);
    \u0275\u0275listener("select", function OrganizationTreeTabComponent_div_0_Template_ngx_graph_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeSelect($event));
    });
    \u0275\u0275template(3, OrganizationTreeTabComponent_div_0_ng_template_3_Template, 17, 30, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(5, OrganizationTreeTabComponent_div_0_ng_template_5_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("links", ctx_r1.links)("nodes", ctx_r1.nodes)("curve", ctx_r1.curve)("layout", ctx_r1.layout)("layoutSettings", ctx_r1.layoutSettings)("enableZoom", true)("draggingEnabled", false)("panToNode$", ctx_r1.panToNodeObservable);
  }
}
var OrganizationTreeTabComponent = class _OrganizationTreeTabComponent {
  employeeRepository;
  storageService;
  employeeService;
  eventService;
  graphComponent;
  center$ = new Subject();
  curve = linear_default;
  layout = "dagre";
  layoutSettings = {
    orientation: "TB"
  };
  panToNodeObservable = new Subject();
  nodes = [];
  links = [];
  currentEmployeeId = 1;
  // Example current employee ID
  employeeData = [];
  // Example data
  profileEmployee;
  isBuilded = false;
  constructor(employeeRepository, storageService, employeeService, eventService) {
    this.employeeRepository = employeeRepository;
    this.storageService = storageService;
    this.employeeService = employeeService;
    this.eventService = eventService;
  }
  ngOnInit() {
    this.employeeService.profileEmployeeSubject.subscribe((employee) => {
      if (employee) {
        this.profileEmployee = employee;
        this.nodes = [];
        this.links = [];
        this.employeeData = [];
        this.isBuilded = false;
        this.employeeRepository.getAll().then((employees) => {
          employees.forEach((employee2) => {
            if (!this.employeeData.find((e) => e.id === employee2.id)) {
              let employeeItem = new EmployeeDto(employee2, this.storageService);
              this.employeeData.push(employeeItem);
            }
          });
          if (this.profileEmployee) {
            this.buildTree(this.profileEmployee.id);
            this.isBuilded = true;
            this.eventService.next(EventConstants.ORGANIZATION_TREE_LOADED, { employeeId: this.profileEmployee.id, count: this.employeeData.length });
          }
        }).catch((error) => {
          this.eventService.next(EventConstants.ORGANIZATION_TREE_LOAD_ERROR, { employeeId: employee.id, error });
        });
      }
    });
  }
  buildTreeForNode(employeeId) {
    const employee = this.employeeData.find((emp) => emp.id === employeeId);
    if (!employee)
      return;
    if (employeeId) {
      this.employeeRepository.getEmployeesForManager(employeeId).then((employees) => {
        employees.forEach((employee2) => {
          if (!this.employeeData.find((e) => e.id === employee2.id)) {
            let employeeItem = new EmployeeDto(employee2, this.storageService);
            this.employeeData.push(employeeItem);
          }
        });
        if (employee.reporting_manager_id) {
          this.employeeRepository.getById(employee.reporting_manager_id).then((manager) => {
            if (manager) {
              if (!this.employeeData.find((e) => e.id === manager.id)) {
                let employeeItem = new EmployeeDto(manager, this.storageService);
                this.employeeData.push(employeeItem);
              }
            }
            this.buildTree(employee.id);
          });
        } else {
          this.buildTree(employee.id);
        }
      });
    }
  }
  buildTree(employeeId) {
    this.addNodes(employeeId);
    this.adjustLinks();
    this.panNode();
  }
  addNodes(employeeId) {
    const employee = this.employeeData.find((emp) => emp.id === employeeId);
    if (!employee)
      return;
    if (!this.nodes.some((x2) => x2.id == employee.id)) {
      this.nodes = [
        {
          id: employee.id,
          label: employee.hebrew_display_name ? employee.hebrew_display_name : employee.display_name,
          data: {
            email: employee.email,
            job_position: employee.job_position,
            parentId: employee.reporting_manager_id,
            avatar_src: employee.avatar_src,
            sign: employee.avatar_url || employee.avatar_name ? null : employee.getEmployeeSign()
          },
          dimension: {
            height: 60,
            width: 150
          },
          color: "#312b84",
          stroke: "#312b84",
          colorTitle: "#fff",
          colorEmail: "#fff",
          colorJob: "#fff"
        }
      ];
    }
    let childrens = this.employeeData.filter((emp) => emp.reporting_manager_id === employeeId);
    for (let children of childrens) {
      if (!this.nodes.some((x2) => x2.id == children.id)) {
        this.nodes.push({
          id: children.id,
          label: children.hebrew_display_name ? children.hebrew_display_name : children.display_name,
          data: {
            email: children.email,
            job_position: children.job_position,
            parentId: children.reporting_manager_id,
            avatar_src: children.avatar_src,
            sign: children.avatar_url || children.avatar_name ? null : children.getEmployeeSign()
          },
          dimension: {
            height: 60,
            width: 150
          },
          color: AppConstants.getRoleColor(children.role),
          stroke: "#312b84",
          colorTitle: "#000",
          colorEmail: "#555",
          colorJob: "#777"
        });
        this.addNodes(children.id);
      }
    }
    let parent = this.employeeData.find((emp) => emp.id === employee.reporting_manager_id);
    if (parent) {
      if (!this.nodes.some((x2) => x2.id == parent.id)) {
        this.nodes.push({
          id: parent.id,
          label: parent.hebrew_display_name ? parent.hebrew_display_name : parent.display_name,
          data: {
            email: parent.email,
            job_position: parent.job_position,
            parentId: parent.reporting_manager_id,
            avatar_src: parent.avatar_src,
            sign: parent.avatar_url || parent.avatar_name ? null : parent.getEmployeeSign()
          },
          dimension: {
            height: 60,
            width: 150
          },
          color: AppConstants.getRoleColor(parent.role),
          stroke: "#312b84",
          colorTitle: "#000",
          colorEmail: "#555",
          colorJob: "#777"
        });
        this.addNodes(parent.id);
      }
    }
  }
  adjustLinks() {
    this.links = [];
    this.nodes.forEach((element) => {
      if (element.data.parentId && this.nodes.some((x2) => x2.id == element.data.parentId)) {
        this.links.push({
          target: element.id,
          source: element.data.parentId
        });
      }
    });
  }
  panNode() {
    setTimeout(() => {
      if (this.profileEmployee) {
        this.panToNodeObservable.next(this.profileEmployee.id);
      }
    }, 100);
  }
  getTruncatedLabel(label) {
    const maxLength = 130;
    const tempElement = document.createElement("span");
    tempElement.style.visibility = "hidden";
    tempElement.style.position = "absolute";
    tempElement.style.whiteSpace = "nowrap";
    tempElement.innerText = label;
    document.body.appendChild(tempElement);
    const labelWidth = tempElement.offsetWidth;
    document.body.removeChild(tempElement);
    if (labelWidth > maxLength) {
      return `${label.substring(0, 15)}...`;
    }
    return label;
  }
  onNodeSelect(node) {
    this.eventService.next(EventConstants.ORGANIZATION_TREE_NODE_SELECTED, { nodeId: node.id });
    console.log("Node selected:", node);
  }
  onNodeClick(event, node) {
    if (event.altKey && event.button === 0) {
    }
  }
  generateCustomCurve(link2) {
    if (!link2) {
      return;
    }
    const pathGenerator = linkHorizontal().x((d) => d[0]).y((d) => d[1]);
    return pathGenerator({
      source: [link2.source, link2.source],
      target: [link2.target, link2.target]
    });
  }
  static \u0275fac = function OrganizationTreeTabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OrganizationTreeTabComponent)(\u0275\u0275directiveInject(EmployeeRepository), \u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(EventService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _OrganizationTreeTabComponent, selectors: [["app-organization-tree"]], viewQuery: function OrganizationTreeTabComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c04, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.graphComponent = _t.first);
    }
  }, features: [\u0275\u0275ProvidersFeature([])], decls: 1, vars: 1, consts: [["graphContainer", ""], ["nodeTemplate", ""], ["linkTemplate", ""], ["class", "m-3  chart-container", 4, "ngIf"], [1, "m-3", "chart-container"], [3, "select", "links", "nodes", "curve", "layout", "layoutSettings", "enableZoom", "draggingEnabled", "panToNode$"], [1, "node", 3, "click"], ["rx", "10", "ry", "10"], ["cx", "5", "cy", "5", "r", "23"], ["x", "-15", "y", "-15"], ["x", "19", "y", "13", "fill", "#ffffff", "font-weight", "bold", "font-size", "24", "font-family", "Roboto"], ["y", "20", "font-size", "10", "font-family", "Roboto"], ["y", "35", "font-size", "10", "font-family", "Roboto"], ["y", "50", "font-size", "10", "font-family", "Roboto"], ["id", "clipText"], ["id", "clipCircle"], ["cx", "5", "cy", "5", "r", "20"], ["marker-end", "url(#arrowhead)", "stroke", "#000", "stroke-width", "1", "fill", "none", 1, "link"]], template: function OrganizationTreeTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, OrganizationTreeTabComponent_div_0_Template, 7, 8, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.isBuilded);
    }
  }, dependencies: [NgxGraphModule, GraphComponent, CommonModule, NgIf, AsyncPipe, NgxChartsModule], styles: ["\n\n.chart-container[_ngcontent-%COMP%] {\n  border: 1px solid gray;\n  height: 800px;\n  padding: 0px !important;\n  overflow: hidden;\n}\n.organization-tree-tab[_ngcontent-%COMP%] {\n  margin: 0;\n  padding: 10px;\n}\n.organization-inner-wrapper[_ngcontent-%COMP%] {\n  transform: scale(0.6);\n}\n/*# sourceMappingURL=organization-tree.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(OrganizationTreeTabComponent, { className: "OrganizationTreeTabComponent", filePath: "src/app/main/employee/profile/components/organization-tree/organization-tree.component.ts", lineNumber: 28 });
})();

// src/app/main/employee/profile/components/performance/performance.component.ts
function PerformanceTabComponent_ng_template_7_app_table_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-table", 8);
    \u0275\u0275listener("action", function PerformanceTabComponent_ng_template_7_app_table_0_Template_app_table_action_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onActionClick($event, "active"));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r2.expandedData)("columns", ctx_r2.objectivesColumns);
  }
}
function PerformanceTabComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PerformanceTabComponent_ng_template_7_app_table_0_Template, 1, 2, "app-table", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.expandedData);
  }
}
function PerformanceTabComponent_ng_template_15_app_table_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-table", 8);
    \u0275\u0275listener("action", function PerformanceTabComponent_ng_template_15_app_table_0_Template_app_table_action_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onActionClick($event, "history"));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r2.expandedData)("columns", ctx_r2.objectivesColumns);
  }
}
function PerformanceTabComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PerformanceTabComponent_ng_template_15_app_table_0_Template, 1, 2, "app-table", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.expandedData);
  }
}
var PerformanceTabComponent = class _PerformanceTabComponent {
  supabaseAuthService;
  objectiveFormRepository;
  idService;
  router;
  translate;
  eventService;
  employeeService;
  columns = [
    { field: "created_at", title: "Create date", type: "date", width: "5%" },
    { field: "status", title: "Status", type: "objective-form-status", width: "15%" },
    { field: "type", title: "Type", type: "objective-form-type", sort: "asc", width: "5%" },
    { field: "load_percentage", title: "Load Percentage", width: "5%" },
    { field: "criteria", title: "Criteria", width: "10%" },
    { field: "unit_of_measurement", title: "Unit of Measurement", type: "translated", width: "10%" },
    { field: "weight", title: "Weight", width: "10%" },
    { field: "yearly_goal", title: "Yearly Goal", width: "10%" },
    { field: "yearly_performance", title: "Yearly Performance", width: "10%" },
    { field: "weighted_score", title: "Weighted Score", type: "percentage", width: "10%" },
    { field: "comments", title: "Comments", width: "10%" }
  ];
  columnsActive = [
    { field: "created_at", title: "Create date", sort: "", type: "date", width: "30%" },
    { field: "due_date", title: "Due date", sort: "", type: "date", width: "30%" },
    { field: "status", title: "Status", type: "objective-form-status", width: "30%" },
    {
      width: "10%",
      field: "actions",
      title: "Actions",
      type: "buttons",
      visible: () => {
        return true;
      },
      columnClass: "app-table-sticky-right",
      columnHeaderClass: "app-table-sticky-right",
      buttons: [
        {
          name: "Go to form",
          icon: "create-outline",
          class: "icon-eye"
        }
      ]
    }
  ];
  columnsHistory = [
    { field: "created_at", title: "Create date", sort: "", type: "date", width: "30%" },
    { field: "due_date", title: "Due date", sort: "", type: "date", width: "30%" },
    { field: "status", title: "Status", type: "objective-form-status", width: "30%" },
    {
      width: "10%",
      field: "actions",
      title: "Actions",
      type: "buttons",
      visible: () => {
        return true;
      },
      columnClass: "app-table-sticky-right",
      columnHeaderClass: "app-table-sticky-right",
      buttons: [
        {
          name: "Go to form",
          icon: "create-outline",
          class: "icon-eye"
        }
      ]
    }
  ];
  objectivesColumns = [
    { field: "type", title: "Type", type: "objective-form-type" },
    { field: "load_percentage", title: "Load Percentage" },
    { field: "criteria", title: "Criteria" },
    { field: "unit_of_measurement", title: "Unit of Measurement", type: "translated" },
    { field: "weight", title: "Weight" },
    { field: "yearly_goal", title: "Yearly Goal" },
    { field: "yearly_performance", title: "Yearly Performance" },
    { field: "weighted_score", title: "Weighted Score", type: "percentage" },
    { field: "comments", title: "Comments" }
  ];
  data = new MatTableDataSource();
  expandedData = new MatTableDataSource();
  historyData = new MatTableDataSource();
  appConstants = AppConstants;
  currentEmployee;
  profileEmployee;
  constructor(supabaseAuthService, objectiveFormRepository, idService, router, translate, eventService, employeeService) {
    this.supabaseAuthService = supabaseAuthService;
    this.objectiveFormRepository = objectiveFormRepository;
    this.idService = idService;
    this.router = router;
    this.translate = translate;
    this.eventService = eventService;
    this.employeeService = employeeService;
  }
  ngOnInit() {
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      if (!employee) {
        return;
      }
      this.currentEmployee = employee;
    });
    this.employeeService.profileEmployeeSubject.subscribe((employee) => {
      if (employee) {
        this.profileEmployee = {};
        this.profileEmployee = employee;
        this.initObjectives();
      }
    });
  }
  initObjectives() {
    this.objectiveFormRepository.getActiveObjectivesForEmployee(this.profileEmployee.getEmployeeId()).then((data) => {
      data.forEach((item) => {
        item.objectives = item.objectives.sort((a, b) => (b.type ?? "").localeCompare(a.type ?? ""));
      });
      this.data.data = data;
      this.eventService.next(EventConstants.PERFORMANCE_OBJECTIVES_LOADED, { employeeId: this.profileEmployee.getEmployeeId(), count: data.length });
    }).catch((error) => {
      this.eventService.next(EventConstants.PERFORMANCE_OBJECTIVES_LOAD_ERROR, { employeeId: this.profileEmployee.getEmployeeId(), error });
    });
    this.objectiveFormRepository.getHistoryObjectivesForEmployee(this.profileEmployee.getEmployeeId()).then((data) => {
      data.forEach((item) => {
        item.objectives = item.objectives.sort((a, b) => (b.type ?? "").localeCompare(a.type ?? ""));
      });
      this.historyData.data = data;
      this.eventService.next(EventConstants.PERFORMANCE_HISTORY_OBJECTIVES_LOADED, { employeeId: this.profileEmployee.getEmployeeId(), count: data.length });
    }).catch((error) => {
      this.eventService.next(EventConstants.PERFORMANCE_HISTORY_OBJECTIVES_LOAD_ERROR, { employeeId: this.profileEmployee.getEmployeeId(), error });
    });
  }
  onActionClick(event, table) {
    switch (event.action) {
      case "sort": {
        if (table == "history") {
          this.historyData.data = AppConstants.sortData(event.data, this.historyData.data);
        } else {
          this.data.data = AppConstants.sortData(event.data, this.data.data);
        }
        break;
      }
      case "Go to form": {
        this.idService.setId("objective-form", event.data.id);
        this.router.navigate(["/objective-form"]);
        break;
      }
      case "expand": {
        this.expandedData = event.data.objectives;
        break;
      }
    }
  }
  static \u0275fac = function PerformanceTabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PerformanceTabComponent)(\u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(ObjectiveFormRepository), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(TranslateService), \u0275\u0275directiveInject(EventService), \u0275\u0275directiveInject(EmployeeService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PerformanceTabComponent, selectors: [["app-performance"]], decls: 17, vars: 14, consts: [["expandedRowContentTemplateActive", ""], ["expandedRowContentTemplateHistory", ""], [1, "m-3", "performance-section"], [1, "tab-section-title", "d-flex", "align-items-center", "gap-2", "mb-3"], ["alt", "", 3, "src"], ["tableLayout", "fixed", "tableClasses", "performance-table app-table no-wrap", 3, "action", "dataSource", "columns", "expandableContentTemplate"], [1, "tab-section-title", "d-flex", "align-items-center", "gap-2", "mt-3", "mb-3"], ["tableLayout", "fixed", "tableClasses", "app-table no-wrap", "containerClasses", "card m-3", 3, "dataSource", "columns", "action", 4, "ngIf"], ["tableLayout", "fixed", "tableClasses", "app-table no-wrap", "containerClasses", "card m-3", 3, "action", "dataSource", "columns"]], template: function PerformanceTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "h6");
      \u0275\u0275text(3);
      \u0275\u0275pipe(4, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "img", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "app-table", 5);
      \u0275\u0275listener("action", function PerformanceTabComponent_Template_app_table_action_6_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onActionClick($event, "active"));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(7, PerformanceTabComponent_ng_template_7_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(9, "div", 6)(10, "h6");
      \u0275\u0275text(11);
      \u0275\u0275pipe(12, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275element(13, "img", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(14, "app-table", 5);
      \u0275\u0275listener("action", function PerformanceTabComponent_Template_app_table_action_14_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onActionClick($event, "history"));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(15, PerformanceTabComponent_ng_template_15_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const expandedRowContentTemplateActive_r5 = \u0275\u0275reference(8);
      const expandedRowContentTemplateHistory_r6 = \u0275\u0275reference(16);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 10, "Active Objectives"));
      \u0275\u0275advance(2);
      \u0275\u0275property("src", ctx.appConstants.getAsset("assets/images/raking-icon.svg"), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance();
      \u0275\u0275property("dataSource", ctx.data)("columns", ctx.columnsActive)("expandableContentTemplate", expandedRowContentTemplateActive_r5);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(12, 12, "History Objectives"));
      \u0275\u0275advance(2);
      \u0275\u0275property("src", ctx.appConstants.getAsset("assets/images/raking-icon.svg"), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance();
      \u0275\u0275property("dataSource", ctx.historyData)("columns", ctx.columnsHistory)("expandableContentTemplate", expandedRowContentTemplateHistory_r6);
    }
  }, dependencies: [
    TableComponent,
    CommonModule,
    NgIf,
    TranslatePipe,
    MatIconModule
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PerformanceTabComponent, { className: "PerformanceTabComponent", filePath: "src/app/main/employee/profile/components/performance/performance.component.ts", lineNumber: 30 });
})();

// src/app/main/employee/profile/components/salary/salary.component.ts
function SalaryComponent_li_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li")(1, "label");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "date");
    \u0275\u0275pipe(4, "currency");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", \u0275\u0275pipeBind2(3, 2, item_r1.create_at, "dd/MM/yyyy"), " - ", \u0275\u0275pipeBind2(4, 5, item_r1.salary, "USD"), "");
  }
}
var SalaryComponent = class _SalaryComponent {
  supabaseAuthService;
  spinner;
  employeeService;
  salaryRepository;
  eventService;
  salary = {};
  profileEmployee;
  constructor(supabaseAuthService, spinner, employeeService, salaryRepository, eventService) {
    this.supabaseAuthService = supabaseAuthService;
    this.spinner = spinner;
    this.employeeService = employeeService;
    this.salaryRepository = salaryRepository;
    this.eventService = eventService;
  }
  ngOnInit() {
    this.employeeService.profileEmployeeSubject.subscribe((result) => {
      this.profileEmployee = result;
      this.salary = {};
      this.initData();
    });
  }
  initData() {
    if (this.profileEmployee?.getEmployeeId()) {
      this.salaryRepository.getAllNestedObjectById("employee_id", this.profileEmployee.getEmployeeId()).then((salaries) => {
        if (salaries && salaries.length > 0) {
          const sortedSalaries = salaries.sort((a, b) => new Date(a.create_at).getTime() - new Date(b.create_at).getTime());
          this.salary.starting = sortedSalaries[0]?.salary;
          this.salary.current = sortedSalaries[sortedSalaries.length - 1]?.salary;
          this.salary.updates = sortedSalaries;
          this.eventService.next(EventConstants.SALARY_LOADED, { employeeId: this.profileEmployee?.getEmployeeId(), count: salaries.length });
        }
      }).catch((error) => {
        this.eventService.next(EventConstants.SALARY_LOAD_ERROR, { employeeId: this.profileEmployee?.getEmployeeId(), error });
      });
    }
  }
  getTrigger() {
    return this.supabaseAuthService.getEmployee$();
  }
  static \u0275fac = function SalaryComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SalaryComponent)(\u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(EmployeeSalaryRepository), \u0275\u0275directiveInject(EventService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SalaryComponent, selectors: [["app-salary"]], decls: 18, vars: 18, consts: [[1, "ps-3"], [1, "d-flex", "align-items-center", "gap-2"], [1, "mt-3"], [4, "ngFor", "ngForOf"]], template: function SalaryComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ul", 0)(1, "li", 1)(2, "h6");
      \u0275\u0275text(3);
      \u0275\u0275pipe(4, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275text(5);
      \u0275\u0275pipe(6, "currency");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "li", 1)(8, "h6");
      \u0275\u0275text(9);
      \u0275\u0275pipe(10, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275text(11);
      \u0275\u0275pipe(12, "currency");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(13, "li", 2)(14, "h6");
      \u0275\u0275text(15);
      \u0275\u0275pipe(16, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275template(17, SalaryComponent_li_17_Template, 5, 8, "li", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(4, 6, "Starting salary"), ":");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(6, 8, ctx.salary.starting, "USD"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(10, 11, "Current salary"), ":");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(12, 13, ctx.salary.current, "USD"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(16, 16, "Salary history:"));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.salary.updates);
    }
  }, dependencies: [CommonModule, NgForOf, CurrencyPipe, DatePipe, TranslatePipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SalaryComponent, { className: "SalaryComponent", filePath: "src/app/main/employee/profile/components/salary/salary.component.ts", lineNumber: 23 });
})();

// src/app/main/employee/profile/profile.component.ts
var _c05 = ["orgTree"];
function ProfileComponent_div_2_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "app-label", 59);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const settings_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("settings", settings_r2)("element", ctx_r2.profileEmployee);
  }
}
function ProfileComponent_div_2_div_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 60);
    \u0275\u0275listener("click", function ProfileComponent_div_2_div_14_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.navigate("/edit-profile"));
    });
    \u0275\u0275elementStart(1, "div")(2, "a", 61);
    \u0275\u0275element(3, "i", 62);
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "translate");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 1, "Edit Info"));
  }
}
function ProfileComponent_div_2_ng_container_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "app-label", 59);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const settings_r5 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("settings", settings_r5)("element", ctx_r2.profileEmployee);
  }
}
function ProfileComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 45)(1, "div", 46);
    \u0275\u0275element(2, "app-circle-employee-img", 47);
    \u0275\u0275elementStart(3, "div", 48)(4, "div", 49)(5, "h5", 50);
    \u0275\u0275text(6);
    \u0275\u0275element(7, "i", 51);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "span", 52);
    \u0275\u0275element(9, "i", 53);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div");
    \u0275\u0275template(12, ProfileComponent_div_2_ng_container_12_Template, 2, 2, "ng-container", 54);
    \u0275\u0275elementStart(13, "div", 55);
    \u0275\u0275template(14, ProfileComponent_div_2_div_14_Template, 6, 3, "div", 56);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(15, "div", 57)(16, "div", 58)(17, "h6");
    \u0275\u0275text(18);
    \u0275\u0275pipe(19, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(20, ProfileComponent_div_2_ng_container_20_Template, 2, 2, "ng-container", 54);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("employee", ctx_r2.profileEmployee);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx_r2.profileEmployee.getEmployeeName());
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("", ctx_r2.profileEmployee.job_position, " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r2.labelSettings);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r2.currentEmployee.isAdmin() || ctx_r2.currentEmployee.id == (ctx_r2.profileEmployee == null ? null : ctx_r2.profileEmployee.getEmployeeId()));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(19, 7, "Personal Information"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r2.personalInfoSettings);
  }
}
function ProfileComponent_div_76_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1)(1, "div", 30)(2, "span", 63);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "div", 30)(5, "span", 63);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 30)(9, "span", 63);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 30)(13, "span", 63);
    \u0275\u0275text(14);
    \u0275\u0275pipe(15, "translate");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const child_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(child_r6.name);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(7, 5, child_r6.gender ? child_r6.gender : ""), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind2(11, 7, child_r6.birth_date, "dd/MM/yyyy"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate2("", ctx_r2.calculateAge(child_r6.birth_date), " ", \u0275\u0275pipeBind1(15, 10, "years"), "");
  }
}
function ProfileComponent_app_education_84_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-education");
  }
}
function ProfileComponent_app_documents_92_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-documents");
  }
}
function ProfileComponent_app_salary_100_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-salary");
  }
}
var ProfileComponent = class _ProfileComponent {
  supabaseAuthService;
  router;
  storageService;
  employeeRepository;
  employeeService;
  cdr;
  idService;
  spinner;
  eventService;
  loaderService;
  orgTree;
  profileEmployee;
  // Define your employee type here
  dropdownOpen = false;
  isDropdownOpen = false;
  tabs = [
    {
      visible: true,
      label: "About",
      route: `/profile`,
      condition: (permissions) => {
        return true;
      }
    },
    // { visible: true, active: false, label: 'Work Type & Shift', route: '/profile/work-type', condition: true },
    // { visible: false, active: false, label: 'Attendance', route: '/profile/attendance', condition: this.attendanceInstalled },
    // { visible: false, active: false, label: 'Leave', route: '/profile/leave', condition: this.leaveInstalled && this.hasLeavePermissions },
    // { visible: false, active: false, label: 'Payroll', route: '/payroll', condition: this.payrollInstalled },
    // { visible: false, active: false, label: 'Allowance & Deduction', route: '/profile/allowance', condition: this.payrollInstalled },
    // { visible: false, active: false, label: 'Penalty Account', route: '/profile/penalty', condition: this.attendanceInstalled },
    // { visible: false, active: false, label: 'Assets', route: '/profile/assets', condition: this.assetInstalled },
    {
      visible: true,
      label: "Performance",
      route: "/profile/performance",
      condition: (permissions) => {
        return permissions.performanceInstalled;
      }
    },
    {
      visible: true,
      label: "Feedback",
      route: "/profile/feedback",
      condition: (permissions) => {
        return permissions.performanceInstalled;
      }
    },
    {
      visible: true,
      label: "Organization Tree",
      route: "/profile/organization-tree",
      condition: (permissions) => {
        return true;
      }
    }
    // { visible: false, active: false, label: 'Bonus Points', route: '/profile/bonus-points', condition: this.bonusPointsInstalled },
    // { visible: false, active: false, label: 'Scheduled Interview', route: '/profile/interviews', condition: this.interviewInstalled },
    // { visible: false, active: false, label: 'Resignation', route: '/profile/resignation', condition: this.resignationInstalled },
  ];
  currentEmployee;
  labelSettings = [
    { type: "profile-label", icon: "ti ti-id-badge", title: "Employee number", field: "ad_id" },
    { type: "profile-label", icon: "ti ti-mail-check", title: "Email", field: "email" },
    { type: "profile-label", icon: "ti ti-id", title: "Company", field: "company" },
    { type: "profile-label", icon: "ti ti-id", title: "Division", field: "division" },
    { type: "profile-label", icon: "ti ti-star", title: "Department", field: "department" },
    { type: "profile-label", icon: "ti ti-calendar-check", title: "Joining Date", field: "joining_date" },
    { type: "profile-label", icon: "ti ti-calendar-check", title: "Manager", field: "reporting_manager.display_name" }
  ];
  personalInfoSettings = [
    { type: "profile-label", icon: "ti ti-phone", title: "Phone", field: "phone" },
    { type: "profile-label", icon: "ti ti-gender-male", title: "Gender", field: "gender" },
    { type: "profile-label", icon: "ti ti-map-pin-check", title: "City", field: "city" },
    { type: "profile-label", icon: "ti ti-map-pin-check", title: "Address", field: "address" },
    { type: "profile-label", title: "ID", icon: "ti ti-fingerprint", field: "card_id" },
    { type: "profile-label", title: "Hebrew display name", icon: "ti ti-link", field: "hebrew_display_name" },
    { type: "date-label", title: "Date of Birth", icon: "ti ti-calendar", field: "date_of_birthday" },
    { type: "profile-label", title: "Marital Status", icon: "ti ti-link", field: "marital_status" },
    { type: "profile-label", title: "Partner display name", icon: "ti ti-link", field: "partner_display_name" }
  ];
  constructor(supabaseAuthService, router, storageService, employeeRepository, employeeService, cdr, idService, spinner, eventService, loaderService) {
    this.supabaseAuthService = supabaseAuthService;
    this.router = router;
    this.storageService = storageService;
    this.employeeRepository = employeeRepository;
    this.employeeService = employeeService;
    this.cdr = cdr;
    this.idService = idService;
    this.spinner = spinner;
    this.eventService = eventService;
    this.loaderService = loaderService;
  }
  onOrgTreeClick() {
    if (this.orgTree) {
      this.orgTree.panNode();
    }
  }
  ngOnInit() {
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      if (!employee) {
        return;
      }
      this.currentEmployee = employee;
    });
    this.idService.getId("profile").subscribe((id2) => {
      if (id2) {
        this.employeeService.setProfileEmployee(null);
        this.initEmployee(id2);
      } else {
        this.initEmployee(this.currentEmployee.id);
      }
    });
  }
  initEmployee(employeeId) {
    if (employeeId) {
      this.spinner.show();
      this.loaderService.show();
      this.employeeRepository.getByIdForProfile(employeeId).then((profileEmployee) => {
        if (profileEmployee.reporting_manager_id) {
          this.employeeRepository.getById(profileEmployee.reporting_manager_id).then((manager) => {
            if (profileEmployee && manager) {
              profileEmployee.reporting_manager = manager;
            }
            this.profileEmployee = new EmployeeDto(profileEmployee, this.storageService);
            this.employeeService.setProfileEmployee(this.profileEmployee);
            this.spinner.hide();
            this.loaderService.hide();
            this.eventService.next(EventConstants.PROFILE_EMPLOYEE_LOADED, { employeeId });
            this.eventService.next(EventConstants.PROFILE_MANAGER_LOADED, { employeeId: profileEmployee.reporting_manager_id });
          }).catch((error) => {
            this.spinner.hide();
            this.loaderService.hide();
            this.eventService.next(EventConstants.PROFILE_MANAGER_LOAD_ERROR, { employeeId: profileEmployee.reporting_manager_id, error });
          });
        } else {
          this.spinner.hide();
          this.loaderService.hide();
          this.profileEmployee = new EmployeeDto(profileEmployee, this.storageService);
          this.employeeService.setProfileEmployee(this.profileEmployee);
          this.eventService.next(EventConstants.PROFILE_EMPLOYEE_LOADED, { employeeId });
        }
      }).catch((error) => {
        this.spinner.hide();
        this.loaderService.hide();
        this.eventService.next(EventConstants.PROFILE_EMPLOYEE_LOAD_ERROR, { employeeId, error });
      });
    }
  }
  toggleDropdown() {
    this.isDropdownOpen = !this.isDropdownOpen;
  }
  navigate(route) {
    if (this.profileEmployee) {
      this.idService.setId("profile-edit", this.profileEmployee.id);
      this.router.navigate([route]);
    }
  }
  calculateAge(birthDate) {
    if (!birthDate) {
      return "";
    }
    const today = /* @__PURE__ */ new Date();
    const birthDateObj = new Date(birthDate);
    let age = today.getFullYear() - birthDateObj.getFullYear();
    const month = today.getMonth();
    const day = today.getDate();
    if (month < birthDateObj.getMonth() || month === birthDateObj.getMonth() && day < birthDateObj.getDate()) {
      age--;
    }
    return age;
  }
  static \u0275fac = function ProfileComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ProfileComponent)(\u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(EmployeeRepository), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(EventService), \u0275\u0275directiveInject(LoaderService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProfileComponent, selectors: [["app-profile"]], viewQuery: function ProfileComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c05, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.orgTree = _t.first);
    }
  }, features: [\u0275\u0275ProvidersFeature([
    EnlargeImageDirective
  ])], decls: 126, vars: 62, consts: [["orgTree", ""], [1, "row"], [1, "col-xl-4"], ["class", "card card-bg-1", 4, "ngIf"], [1, "col-xl-8"], [1, "bg-white", "rounded"], ["role", "tablist", 1, "nav", "nav-tabs", "nav-tabs-bottom", "nav-justified", "nowrap", "mb-3"], ["role", "presentation", 1, "nav-item"], ["href", "#profile-children-info", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "active", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-users", "me-1"], ["href", "#profile-documents", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-file", "me-1"], ["href", "#profile-education", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], ["href", "#profile-salary", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-cash", "me-1"], ["href", "#profile-performance", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-bar-chart", "me-1"], ["href", "#profile-feedback", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-comment", "me-1"], ["role", "presentation", 1, "nav-item", 3, "click"], ["href", "#profile-org-tree", "data-bs-toggle", "tab", "aria-selected", "true", "role", "tab", 1, "nav-link", "fw-medium", "d-flex", "align-items-center", "justify-content-center"], [1, "ti", "ti-tree", "me-1"], [1, "tab-content"], ["id", "profile-about", "role", "tabpanel", 1, "tab-pane"], [1, "card", "border-0"], [1, "card-header"], ["id", "profile-about", 1, "card-body"], [1, "accordion-body", "mt-2"], ["id", "profile-children-info", "role", "tabpanel", 1, "tab-pane", "show", "active"], ["id", "childrens-information", 1, "card-body"], [1, "col-md-2"], [1, "d-inline-flex", "align-items-center"], ["class", "row", 4, "ngFor", "ngForOf"], ["id", "profile-education", "role", "tabpanel", 1, "tab-pane"], ["id", "contract-information", 1, "card-body"], [4, "ngIf"], ["id", "profile-documents", "role", "tabpanel", 1, "tab-pane"], ["id", "profile-salary", "role", "tabpanel", 1, "tab-pane"], ["id", "profile-salary", 1, "card-body"], ["id", "profile-performance", "role", "tabpanel", 1, "tab-pane"], ["id", "performance-information", 1, "card-body"], ["id", "profile-feedback", "role", "tabpanel", 1, "tab-pane"], ["id", "feedback-information", 1, "card-body"], ["id", "profile-org-tree", "role", "tabpanel", 1, "tab-pane"], ["id", "org-tree-information", 1, "card-body"], [1, "card", "card-bg-1"], [1, "card-body"], [3, "employee"], [1, "text-center", "px-3", "pb-3", "border-bottom"], [1, "mb-3"], [1, "d-flex", "align-items-center", "justify-content-center", "mb-1"], [1, "ti", "ti-discount-check-filled", "text-success", "ms-1"], [1, "badge", "badge-soft-dark", "fw-medium", "me-2"], [1, "ti", "ti-point-filled", "me-1"], [4, "ngFor", "ngForOf"], [1, "row", "gx-2", "mt-3"], ["class", "col-12", 3, "click", 4, "ngIf"], [1, "p-3", "border-bottom"], [1, "d-flex", "align-items-center", "justify-content-between", "mb-2"], [3, "settings", "element"], [1, "col-12", 3, "click"], [1, "btn", "btn-dark", "w-100"], [1, "ti", "ti-edit", "me-1"], [1, "d-flex", "align-items-center", "fw-medium", "mt-1"]], template: function ProfileComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 1)(1, "div", 2);
      \u0275\u0275template(2, ProfileComponent_div_2_Template, 21, 9, "div", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 4)(4, "div")(5, "div", 5)(6, "ul", 6)(7, "li", 7)(8, "a", 8);
      \u0275\u0275element(9, "i", 9);
      \u0275\u0275text(10);
      \u0275\u0275pipe(11, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(12, "li", 7)(13, "a", 10);
      \u0275\u0275element(14, "i", 11);
      \u0275\u0275text(15);
      \u0275\u0275pipe(16, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(17, "li", 7)(18, "a", 12);
      \u0275\u0275element(19, "i", 11);
      \u0275\u0275text(20);
      \u0275\u0275pipe(21, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(22, "li", 7)(23, "a", 13);
      \u0275\u0275element(24, "i", 14);
      \u0275\u0275text(25);
      \u0275\u0275pipe(26, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(27, "li", 7)(28, "a", 15);
      \u0275\u0275element(29, "i", 16);
      \u0275\u0275text(30);
      \u0275\u0275pipe(31, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(32, "li", 7)(33, "a", 17);
      \u0275\u0275element(34, "i", 18);
      \u0275\u0275text(35);
      \u0275\u0275pipe(36, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(37, "li", 19);
      \u0275\u0275listener("click", function ProfileComponent_Template_li_click_37_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onOrgTreeClick());
      });
      \u0275\u0275elementStart(38, "a", 20);
      \u0275\u0275element(39, "i", 21);
      \u0275\u0275text(40);
      \u0275\u0275pipe(41, "translate");
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(42, "div", 22)(43, "div", 23)(44, "div", 24)(45, "div", 25)(46, "h5");
      \u0275\u0275text(47);
      \u0275\u0275pipe(48, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(49, "div", 26)(50, "div", 27);
      \u0275\u0275text(51, " As an award winning designer, I deliver exceptional quality work and bring value to your brand! With 10 years of experience and 350+ projects completed worldwide with satisfied customers, I developed the 360\xB0 brand approach, which helped me to create numerous brands that are relevant, meaningful and loved. ");
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(52, "div", 28)(53, "div", 24)(54, "div", 25)(55, "h5");
      \u0275\u0275text(56);
      \u0275\u0275pipe(57, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(58, "div", 29)(59, "div", 1)(60, "div", 30)(61, "h6", 31);
      \u0275\u0275text(62);
      \u0275\u0275pipe(63, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(64, "div", 30)(65, "h6", 31);
      \u0275\u0275text(66);
      \u0275\u0275pipe(67, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(68, "div", 30)(69, "h6", 31);
      \u0275\u0275text(70);
      \u0275\u0275pipe(71, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(72, "div", 30)(73, "h6", 31);
      \u0275\u0275text(74);
      \u0275\u0275pipe(75, "translate");
      \u0275\u0275elementEnd()()();
      \u0275\u0275template(76, ProfileComponent_div_76_Template, 16, 12, "div", 32);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(77, "div", 33)(78, "div", 24)(79, "div", 25)(80, "h5");
      \u0275\u0275text(81);
      \u0275\u0275pipe(82, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(83, "div", 34);
      \u0275\u0275template(84, ProfileComponent_app_education_84_Template, 1, 0, "app-education", 35);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(85, "div", 36)(86, "div", 24)(87, "div", 25)(88, "h5");
      \u0275\u0275text(89);
      \u0275\u0275pipe(90, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(91, "div", 34);
      \u0275\u0275template(92, ProfileComponent_app_documents_92_Template, 1, 0, "app-documents", 35);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(93, "div", 37)(94, "div", 24)(95, "div", 25)(96, "h5");
      \u0275\u0275text(97);
      \u0275\u0275pipe(98, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(99, "div", 38);
      \u0275\u0275template(100, ProfileComponent_app_salary_100_Template, 1, 0, "app-salary", 35);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(101, "div", 39)(102, "div", 24)(103, "div", 25)(104, "h5");
      \u0275\u0275text(105);
      \u0275\u0275pipe(106, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(107, "div", 40);
      \u0275\u0275element(108, "app-performance");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(109, "div", 41)(110, "div", 24)(111, "div", 25)(112, "h5");
      \u0275\u0275text(113);
      \u0275\u0275pipe(114, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(115, "div", 42);
      \u0275\u0275element(116, "app-feedback");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(117, "div", 43)(118, "div", 24)(119, "div", 25)(120, "h5");
      \u0275\u0275text(121);
      \u0275\u0275pipe(122, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(123, "div", 44);
      \u0275\u0275element(124, "app-organization-tree", null, 0);
      \u0275\u0275elementEnd()()()()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.profileEmployee && ctx.profileEmployee.id);
      \u0275\u0275advance(8);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(11, 24, "Children Info"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(16, 26, "Documents"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(21, 28, "Education"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(26, 30, "Salary"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(31, 32, "Performance"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(36, 34, "Feedback"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(41, 36, "Org Tree"), " ");
      \u0275\u0275advance(7);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(48, 38, "About Employee"));
      \u0275\u0275advance(9);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(57, 40, "Children Information"));
      \u0275\u0275advance(6);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(63, 42, "Name"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(67, 44, "Gender"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(71, 46, "Birth date"), " ");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(75, 48, "Age"), " ");
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.profileEmployee == null ? null : ctx.profileEmployee.childrens);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(82, 50, "Education"));
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.profileEmployee);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(90, 52, "Employment documents and conditions"));
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.profileEmployee);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(98, 54, "Salary"));
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.profileEmployee);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(106, 56, "Performance"));
      \u0275\u0275advance(8);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(114, 58, "Feedback"));
      \u0275\u0275advance(8);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(122, 60, "Organization tree"));
    }
  }, dependencies: [
    CommonModule,
    NgForOf,
    NgIf,
    DatePipe,
    TranslatePipe,
    MatIconModule,
    SalaryComponent,
    LabelComponent,
    DocumentsComponent,
    PerformanceTabComponent,
    FeedbackTabComponent,
    OrganizationTreeTabComponent,
    CircleEmployeeImgComponent,
    EducationComponent
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProfileComponent, { className: "ProfileComponent", filePath: "src/app/main/employee/profile/profile.component.ts", lineNumber: 48 });
})();
export {
  ProfileComponent
};
//# sourceMappingURL=chunk-WZYWGSST.js.map
