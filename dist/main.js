import {
  SMSAuthService
} from "./chunk-U4XX5UOH.js";
import {
  AppSettingsService,
  FeatureSettingsService
} from "./chunk-N7SNON5D.js";
import "./chunk-PAPOGBTA.js";
import "./chunk-RYUCLK6V.js";
import {
  FeatureRendererService
} from "./chunk-YJCCIIYS.js";
import {
  FeatureRegistry
} from "./chunk-SLFN5ZXT.js";
import {
  PagesRepository
} from "./chunk-ZQOC7KHR.js";
import "./chunk-G7IEYWLY.js";
import "./chunk-WVSW2X76.js";
import "./chunk-25KMDAIC.js";
import {
  SideBarService
} from "./chunk-SUBMYCX5.js";
import {
  StylesSettingsService
} from "./chunk-3KR3UNHC.js";
import {
  NgxGraphModule
} from "./chunk-IQBBWRS3.js";
import {
  FeedbackFormsRepository
} from "./chunk-KG3BOM3F.js";
import {
  BrowserCacheLocation,
  EmployeeService,
  InteractionRequiredAuthError,
  InteractionType,
  LogLevel,
  MSAL_GUARD_CONFIG,
  MSAL_INSTANCE,
  MSAL_INTERCEPTOR_CONFIG,
  MsalBroadcastService,
  MsalGuard,
  MsalInterceptor,
  MsalRedirectComponent,
  MsalService,
  PublicClientApplication
} from "./chunk-E3RI4QCV.js";
import "./chunk-BV2EUPGA.js";
import "./chunk-EQM2SLMA.js";
import "./chunk-6X5DL6OJ.js";
import {
  ObjectiveFormRepository
} from "./chunk-S5OCFGQY.js";
import "./chunk-NJHAENO7.js";
import {
  require_moment
} from "./chunk-X45EM66I.js";
import "./chunk-BWIOX5TR.js";
import "./chunk-JYDETW4E.js";
import {
  AppInputComponent
} from "./chunk-M2EJXGZP.js";
import {
  DateAdapter,
  MAT_DATE_FORMATS,
  MAT_DATE_LOCALE,
  SharedResizeObserver
} from "./chunk-CRLS72DG.js";
import "./chunk-4MP457FT.js";
import {
  SupabaseAuthService
} from "./chunk-726REOYR.js";
import "./chunk-ZKADD55Q.js";
import {
  ContentObserver,
  Directionality,
  MatButton,
  MatButtonModule,
  MatCommonModule,
  Platform,
  StorageService,
  coerceElement
} from "./chunk-JDSXESFV.js";
import "./chunk-PTMC7Z3G.js";
import "./chunk-NPYWTI7B.js";
import "./chunk-YB7VYXZC.js";
import "./chunk-BSJGXNL2.js";
import "./chunk-SNL7CR3M.js";
import "./chunk-POF6P2IF.js";
import "./chunk-BCSCWTDQ.js";
import "./chunk-XEW2RVSV.js";
import "./chunk-2R2VMYXT.js";
import "./chunk-34SSTWFD.js";
import "./chunk-PVOL3XIB.js";
import "./chunk-PPDZQ3XB.js";
import "./chunk-O2426PIE.js";
import "./chunk-CN2NLH3R.js";
import "./chunk-6VMHCKIO.js";
import "./chunk-Z4NK5ERE.js";
import "./chunk-CLKJFHPN.js";
import "./chunk-3IAPPBJB.js";
import "./chunk-4JBIDYYM.js";
import "./chunk-RNINX5QP.js";
import "./chunk-A4AE5KKX.js";
import "./chunk-FET6I6E4.js";
import {
  EventService
} from "./chunk-PYCXHYST.js";
import {
  EmployeeRepository
} from "./chunk-TLWCP54H.js";
import "./chunk-NKEEF4XY.js";
import {
  AppConstants
} from "./chunk-LHQOL4PU.js";
import {
  IdService
} from "./chunk-YW5JDNY2.js";
import {
  ActivatedRoute,
  DomRendererFactory2,
  HTTP_INTERCEPTORS,
  HttpClient,
  LoaderService,
  NavigationEnd,
  NgxSpinnerModule,
  NgxSpinnerService,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterOutlet,
  TranslateLoader,
  TranslateModule,
  TranslatePipe,
  TranslateService,
  bootstrapApplication,
  environment,
  provideHttpClient,
  provideRouter,
  withHashLocation,
  withInterceptorsFromDi
} from "./chunk-HDIRTHWB.js";
import {
  ANIMATION_MODULE_TYPE,
  ApplicationRef,
  AsyncPipe,
  BehaviorSubject,
  ChangeDetectionScheduler,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Component,
  DOCUMENT,
  DestroyRef,
  Directive,
  EMPTY,
  ElementRef,
  EventEmitter,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  NgClass,
  NgForOf,
  NgIf,
  NgModule,
  NgSwitch,
  NgSwitchCase,
  NgTemplateOutlet,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Renderer2,
  RendererFactory2,
  RuntimeError,
  Subject,
  ViewContainerRef,
  ViewEncapsulation,
  afterRenderEffect,
  animationFrameScheduler,
  assertInInjectionContext,
  assertNotInReactiveContext,
  booleanAttribute,
  catchError,
  combineLatest,
  computed,
  contentChild,
  createComponent,
  delay,
  distinctUntilChanged,
  effect,
  filter,
  finalize,
  from,
  fromEvent,
  importProvidersFrom,
  inject,
  input,
  interval,
  isPlatformBrowser,
  linkedSignal,
  makeEnvironmentProviders,
  map,
  merge,
  numberAttribute,
  of,
  output,
  performanceMarkFeature,
  provideAppInitializer,
  provideZoneChangeDetection,
  setClassMetadata,
  shareReplay,
  signal,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttleTime,
  untracked,
  viewChild,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuerySignal,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵqueryAdvance,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery,
  ɵɵviewQuerySignal
} from "./chunk-ERGQW4H6.js";
import "./chunk-KQ2G4OE2.js";
import "./chunk-N6SQHGEH.js";
import "./chunk-RTA6YFKO.js";
import {
  __async,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-XVQ6O2EZ.js";

// node_modules/@angular/material-moment-adapter/fesm2022/material-moment-adapter.mjs
var _rollupMoment = __toESM(require_moment(), 1);
var import_moment = __toESM(require_moment(), 1);
var moment = import_moment.default || _rollupMoment;
var MAT_MOMENT_DATE_ADAPTER_OPTIONS = new InjectionToken("MAT_MOMENT_DATE_ADAPTER_OPTIONS", {
  providedIn: "root",
  factory: MAT_MOMENT_DATE_ADAPTER_OPTIONS_FACTORY
});
function MAT_MOMENT_DATE_ADAPTER_OPTIONS_FACTORY() {
  return {
    useUtc: false
  };
}
function range(length, valueFunction) {
  const valuesArray = Array(length);
  for (let i = 0; i < length; i++) {
    valuesArray[i] = valueFunction(i);
  }
  return valuesArray;
}
var MomentDateAdapter = class _MomentDateAdapter extends DateAdapter {
  _options = inject(MAT_MOMENT_DATE_ADAPTER_OPTIONS, {
    optional: true
  });
  // Note: all of the methods that accept a `Moment` input parameter immediately call `this.clone`
  // on it. This is to ensure that we're working with a `Moment` that has the correct locale setting
  // while avoiding mutating the original object passed to us. Just calling `.locale(...)` on the
  // input would mutate the object.
  _localeData;
  constructor() {
    super();
    const dateLocale = inject(MAT_DATE_LOCALE, {
      optional: true
    });
    this.setLocale(dateLocale || moment.locale());
  }
  setLocale(locale) {
    super.setLocale(locale);
    let momentLocaleData = moment.localeData(locale);
    this._localeData = {
      firstDayOfWeek: momentLocaleData.firstDayOfWeek(),
      longMonths: momentLocaleData.months(),
      shortMonths: momentLocaleData.monthsShort(),
      dates: range(31, (i) => this.createDate(2017, 0, i + 1).format("D")),
      longDaysOfWeek: momentLocaleData.weekdays(),
      shortDaysOfWeek: momentLocaleData.weekdaysShort(),
      narrowDaysOfWeek: momentLocaleData.weekdaysMin()
    };
  }
  getYear(date) {
    return this.clone(date).year();
  }
  getMonth(date) {
    return this.clone(date).month();
  }
  getDate(date) {
    return this.clone(date).date();
  }
  getDayOfWeek(date) {
    return this.clone(date).day();
  }
  getMonthNames(style) {
    return style == "long" ? this._localeData.longMonths : this._localeData.shortMonths;
  }
  getDateNames() {
    return this._localeData.dates;
  }
  getDayOfWeekNames(style) {
    if (style == "long") {
      return this._localeData.longDaysOfWeek;
    }
    if (style == "short") {
      return this._localeData.shortDaysOfWeek;
    }
    return this._localeData.narrowDaysOfWeek;
  }
  getYearName(date) {
    return this.clone(date).format("YYYY");
  }
  getFirstDayOfWeek() {
    return this._localeData.firstDayOfWeek;
  }
  getNumDaysInMonth(date) {
    return this.clone(date).daysInMonth();
  }
  clone(date) {
    return date.clone().locale(this.locale);
  }
  createDate(year, month, date) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (month < 0 || month > 11) {
        throw Error(`Invalid month index "${month}". Month index has to be between 0 and 11.`);
      }
      if (date < 1) {
        throw Error(`Invalid date "${date}". Date has to be greater than 0.`);
      }
    }
    const result = this._createMoment({
      year,
      month,
      date
    }).locale(this.locale);
    if (!result.isValid() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Invalid date "${date}" for month with index "${month}".`);
    }
    return result;
  }
  today() {
    return this._createMoment().locale(this.locale);
  }
  parse(value, parseFormat) {
    if (value && typeof value == "string") {
      return this._createMoment(value, parseFormat, this.locale);
    }
    return value ? this._createMoment(value).locale(this.locale) : null;
  }
  format(date, displayFormat) {
    date = this.clone(date);
    if (!this.isValid(date) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("MomentDateAdapter: Cannot format invalid date.");
    }
    return date.format(displayFormat);
  }
  addCalendarYears(date, years) {
    return this.clone(date).add({
      years
    });
  }
  addCalendarMonths(date, months) {
    return this.clone(date).add({
      months
    });
  }
  addCalendarDays(date, days) {
    return this.clone(date).add({
      days
    });
  }
  toIso8601(date) {
    return this.clone(date).format();
  }
  /**
   * Returns the given value if given a valid Moment or null. Deserializes valid ISO 8601 strings
   * (https://www.ietf.org/rfc/rfc3339.txt) and valid Date objects into valid Moments and empty
   * string into null. Returns an invalid date for all other values.
   */
  deserialize(value) {
    let date;
    if (value instanceof Date) {
      date = this._createMoment(value).locale(this.locale);
    } else if (this.isDateInstance(value)) {
      return this.clone(value);
    }
    if (typeof value === "string") {
      if (!value) {
        return null;
      }
      date = this._createMoment(value, moment.ISO_8601).locale(this.locale);
    }
    if (date && this.isValid(date)) {
      return this._createMoment(date).locale(this.locale);
    }
    return super.deserialize(value);
  }
  isDateInstance(obj) {
    return moment.isMoment(obj);
  }
  isValid(date) {
    return this.clone(date).isValid();
  }
  invalid() {
    return moment.invalid();
  }
  setTime(target, hours, minutes, seconds) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (hours < 0 || hours > 23) {
        throw Error(`Invalid hours "${hours}". Hours value must be between 0 and 23.`);
      }
      if (minutes < 0 || minutes > 59) {
        throw Error(`Invalid minutes "${minutes}". Minutes value must be between 0 and 59.`);
      }
      if (seconds < 0 || seconds > 59) {
        throw Error(`Invalid seconds "${seconds}". Seconds value must be between 0 and 59.`);
      }
    }
    return this.clone(target).set({
      hours,
      minutes,
      seconds,
      milliseconds: 0
    });
  }
  getHours(date) {
    return date.hours();
  }
  getMinutes(date) {
    return date.minutes();
  }
  getSeconds(date) {
    return date.seconds();
  }
  parseTime(value, parseFormat) {
    return this.parse(value, parseFormat);
  }
  addSeconds(date, amount) {
    return this.clone(date).add({
      seconds: amount
    });
  }
  /** Creates a Moment instance while respecting the current UTC settings. */
  _createMoment(date, format, locale) {
    const {
      strict,
      useUtc
    } = this._options || {};
    return useUtc ? moment.utc(date, format, locale, strict) : moment(date, format, locale, strict);
  }
  static \u0275fac = function MomentDateAdapter_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MomentDateAdapter)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _MomentDateAdapter,
    factory: _MomentDateAdapter.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MomentDateAdapter, [{
    type: Injectable
  }], () => [], null);
})();
var MAT_MOMENT_DATE_FORMATS = {
  parse: {
    dateInput: "l",
    timeInput: "LT"
  },
  display: {
    dateInput: "l",
    timeInput: "LT",
    monthYearLabel: "MMM YYYY",
    dateA11yLabel: "LL",
    monthYearA11yLabel: "MMMM YYYY",
    timeOptionLabel: "LT"
  }
};
var MomentDateModule = class _MomentDateModule {
  static \u0275fac = function MomentDateModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MomentDateModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MomentDateModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [{
      provide: DateAdapter,
      useClass: MomentDateAdapter,
      deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS]
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MomentDateModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: DateAdapter,
        useClass: MomentDateAdapter,
        deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS]
      }]
    }]
  }], null, null);
})();
var MatMomentDateModule = class _MatMomentDateModule {
  static \u0275fac = function MatMomentDateModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMomentDateModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatMomentDateModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [provideMomentDateAdapter()]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMomentDateModule, [{
    type: NgModule,
    args: [{
      providers: [provideMomentDateAdapter()]
    }]
  }], null, null);
})();
function provideMomentDateAdapter(formats = MAT_MOMENT_DATE_FORMATS, options) {
  const providers = [{
    provide: DateAdapter,
    useClass: MomentDateAdapter,
    deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS]
  }, {
    provide: MAT_DATE_FORMATS,
    useValue: formats
  }];
  if (options) {
    providers.push({
      provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS,
      useValue: options
    });
  }
  return providers;
}

// node_modules/@angular/platform-browser/fesm2022/animations/async.mjs
var ANIMATION_PREFIX = "@";
var AsyncAnimationRendererFactory = class _AsyncAnimationRendererFactory {
  doc;
  delegate;
  zone;
  animationType;
  moduleImpl;
  _rendererFactoryPromise = null;
  scheduler = null;
  injector = inject(Injector);
  loadingSchedulerFn = inject(\u0275ASYNC_ANIMATION_LOADING_SCHEDULER_FN, {
    optional: true
  });
  _engine;
  /**
   *
   * @param moduleImpl allows to provide a mock implmentation (or will load the animation module)
   */
  constructor(doc, delegate, zone, animationType, moduleImpl) {
    this.doc = doc;
    this.delegate = delegate;
    this.zone = zone;
    this.animationType = animationType;
    this.moduleImpl = moduleImpl;
  }
  /** @nodoc */
  ngOnDestroy() {
    this._engine?.flush();
  }
  /**
   * @internal
   */
  loadImpl() {
    const loadFn = () => this.moduleImpl ?? import("./chunk-7RDBL6FK.js").then((m) => m);
    let moduleImplPromise;
    if (this.loadingSchedulerFn) {
      moduleImplPromise = this.loadingSchedulerFn(loadFn);
    } else {
      moduleImplPromise = loadFn();
    }
    return moduleImplPromise.catch((e) => {
      throw new RuntimeError(5300, (typeof ngDevMode === "undefined" || ngDevMode) && "Async loading for animations package was enabled, but loading failed. Angular falls back to using regular rendering. No animations will be displayed and their styles won't be applied.");
    }).then(({
      \u0275createEngine,
      \u0275AnimationRendererFactory
    }) => {
      this._engine = \u0275createEngine(this.animationType, this.doc);
      const rendererFactory = new \u0275AnimationRendererFactory(this.delegate, this._engine, this.zone);
      this.delegate = rendererFactory;
      return rendererFactory;
    });
  }
  /**
   * This method is delegating the renderer creation to the factories.
   * It uses default factory while the animation factory isn't loaded
   * and will rely on the animation factory once it is loaded.
   *
   * Calling this method will trigger as side effect the loading of the animation module
   * if the renderered component uses animations.
   */
  createRenderer(hostElement, rendererType) {
    const renderer = this.delegate.createRenderer(hostElement, rendererType);
    if (renderer.\u0275type === 0) {
      return renderer;
    }
    if (typeof renderer.throwOnSyntheticProps === "boolean") {
      renderer.throwOnSyntheticProps = false;
    }
    const dynamicRenderer = new DynamicDelegationRenderer(renderer);
    if (rendererType?.data?.["animation"] && !this._rendererFactoryPromise) {
      this._rendererFactoryPromise = this.loadImpl();
    }
    this._rendererFactoryPromise?.then((animationRendererFactory) => {
      const animationRenderer = animationRendererFactory.createRenderer(hostElement, rendererType);
      dynamicRenderer.use(animationRenderer);
      this.scheduler ??= this.injector.get(ChangeDetectionScheduler, null, {
        optional: true
      });
      this.scheduler?.notify(
        10
        /* NotificationSource.AsyncAnimationsLoaded */
      );
    }).catch((e) => {
      dynamicRenderer.use(renderer);
    });
    return dynamicRenderer;
  }
  begin() {
    this.delegate.begin?.();
  }
  end() {
    this.delegate.end?.();
  }
  whenRenderingDone() {
    return this.delegate.whenRenderingDone?.() ?? Promise.resolve();
  }
  /**
   * Used during HMR to clear any cached data about a component.
   * @param componentId ID of the component that is being replaced.
   */
  componentReplaced(componentId) {
    this._engine?.flush();
    this.delegate.componentReplaced?.(componentId);
  }
  static \u0275fac = function AsyncAnimationRendererFactory_Factory(__ngFactoryType__) {
    \u0275\u0275invalidFactory();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _AsyncAnimationRendererFactory,
    factory: _AsyncAnimationRendererFactory.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncAnimationRendererFactory, [{
    type: Injectable
  }], () => [{
    type: Document
  }, {
    type: RendererFactory2
  }, {
    type: NgZone
  }, {
    type: void 0
  }, {
    type: Promise
  }], null);
})();
var DynamicDelegationRenderer = class {
  delegate;
  // List of callbacks that need to be replayed on the animation renderer once its loaded
  replay = [];
  \u0275type = 1;
  constructor(delegate) {
    this.delegate = delegate;
  }
  use(impl) {
    this.delegate = impl;
    if (this.replay !== null) {
      for (const fn of this.replay) {
        fn(impl);
      }
      this.replay = null;
    }
  }
  get data() {
    return this.delegate.data;
  }
  destroy() {
    this.replay = null;
    this.delegate.destroy();
  }
  createElement(name, namespace) {
    return this.delegate.createElement(name, namespace);
  }
  createComment(value) {
    return this.delegate.createComment(value);
  }
  createText(value) {
    return this.delegate.createText(value);
  }
  get destroyNode() {
    return this.delegate.destroyNode;
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
  }
  insertBefore(parent, newChild, refChild, isMove) {
    this.delegate.insertBefore(parent, newChild, refChild, isMove);
  }
  removeChild(parent, oldChild, isHostElement) {
    this.delegate.removeChild(parent, oldChild, isHostElement);
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value, namespace) {
    this.delegate.setAttribute(el, name, value, namespace);
  }
  removeAttribute(el, name, namespace) {
    this.delegate.removeAttribute(el, name, namespace);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style, value, flags) {
    this.delegate.setStyle(el, style, value, flags);
  }
  removeStyle(el, style, flags) {
    this.delegate.removeStyle(el, style, flags);
  }
  setProperty(el, name, value) {
    if (this.shouldReplay(name)) {
      this.replay.push((renderer) => renderer.setProperty(el, name, value));
    }
    this.delegate.setProperty(el, name, value);
  }
  setValue(node, value) {
    this.delegate.setValue(node, value);
  }
  listen(target, eventName, callback, options) {
    if (this.shouldReplay(eventName)) {
      this.replay.push((renderer) => renderer.listen(target, eventName, callback, options));
    }
    return this.delegate.listen(target, eventName, callback, options);
  }
  shouldReplay(propOrEventName) {
    return this.replay !== null && propOrEventName.startsWith(ANIMATION_PREFIX);
  }
};
var \u0275ASYNC_ANIMATION_LOADING_SCHEDULER_FN = new InjectionToken(ngDevMode ? "async_animation_loading_scheduler_fn" : "");
function provideAnimationsAsync(type = "animations") {
  performanceMarkFeature("NgAsyncAnimations");
  if (false) {
    type = "noop";
  }
  return makeEnvironmentProviders([{
    provide: RendererFactory2,
    useFactory: (doc, renderer, zone) => {
      return new AsyncAnimationRendererFactory(doc, renderer, zone, type);
    },
    deps: [DOCUMENT, DomRendererFactory2, NgZone]
  }, {
    provide: ANIMATION_MODULE_TYPE,
    useValue: type === "noop" ? "NoopAnimations" : "BrowserAnimations"
  }]);
}

// node_modules/@ngx-translate/http-loader/fesm2022/ngx-translate-http-loader.mjs
var TranslateHttpLoader = class _TranslateHttpLoader {
  http;
  prefix;
  suffix;
  constructor(http, prefix = "/assets/i18n/", suffix = ".json") {
    this.http = http;
    this.prefix = prefix;
    this.suffix = suffix;
  }
  /**
   * Gets the translations from the server
   */
  getTranslation(lang) {
    return this.http.get(`${this.prefix}${lang}${this.suffix}`);
  }
  static \u0275fac = function TranslateHttpLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslateHttpLoader)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(String), \u0275\u0275inject(String));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateHttpLoader,
    factory: _TranslateHttpLoader.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateHttpLoader, [{
    type: Injectable
  }], () => [{
    type: HttpClient
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [String]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [String]
    }]
  }], null);
})();

// node_modules/ngx-webstorage/fesm2022/ngx-webstorage.mjs
var StorageStrategies;
(function(StorageStrategies2) {
  StorageStrategies2["Local"] = "local_strategy";
  StorageStrategies2["Session"] = "session_strategy";
  StorageStrategies2["InMemory"] = "in_memory_strategy";
})(StorageStrategies || (StorageStrategies = {}));
var CompatHelper = class {
  static isStorageAvailable(storage) {
    let available = true;
    try {
      if (typeof storage === "object") {
        storage.setItem("test-storage", "foobar");
        storage.removeItem("test-storage");
      } else available = false;
    } catch (e) {
      available = false;
    }
    return available;
  }
};
function noop() {
}
var DefaultPrefix = "ngx-webstorage";
var DefaultSeparator = "|";
var DefaultIsCaseSensitive = false;
var StorageKeyManager = class _StorageKeyManager {
  static {
    this.prefix = DefaultPrefix;
  }
  static {
    this.separator = DefaultSeparator;
  }
  static {
    this.isCaseSensitive = DefaultIsCaseSensitive;
  }
  static normalize(raw) {
    raw = _StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();
    return `${_StorageKeyManager.prefix}${_StorageKeyManager.separator}${raw}`;
  }
  static isNormalizedKey(key) {
    return key.indexOf(_StorageKeyManager.prefix + _StorageKeyManager.separator) === 0;
  }
  static setPrefix(prefix) {
    _StorageKeyManager.prefix = prefix;
  }
  static setSeparator(separator) {
    _StorageKeyManager.separator = separator;
  }
  static setCaseSensitive(enable) {
    _StorageKeyManager.isCaseSensitive = enable;
  }
  static consumeConfiguration(config) {
    if ("prefix" in config) this.setPrefix(config.prefix);
    if ("separator" in config) this.setSeparator(config.separator);
    if ("caseSensitive" in config) this.setCaseSensitive(config.caseSensitive);
  }
};
var SyncStorage = class {
  constructor(strategy) {
    this.strategy = strategy;
  }
  retrieve(key) {
    let value;
    this.strategy.get(StorageKeyManager.normalize(key)).subscribe((result) => value = typeof result === "undefined" ? null : result);
    return value;
  }
  store(key, value) {
    this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);
    return value;
  }
  clear(key) {
    if (key !== void 0) this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);
    else this.strategy.clear().subscribe(noop);
  }
  getStrategyName() {
    return this.strategy.name;
  }
  observe(key) {
    key = StorageKeyManager.normalize(key);
    return this.strategy.keyChanges.pipe(filter((changed) => changed === null || changed === key), switchMap(() => this.strategy.get(key)), distinctUntilChanged(), shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }
};
var StrategyCacheService = class _StrategyCacheService {
  constructor() {
    this.caches = {};
  }
  get(strategyName, key) {
    return this.getCacheStore(strategyName)[key];
  }
  set(strategyName, key, value) {
    this.getCacheStore(strategyName)[key] = value;
  }
  del(strategyName, key) {
    delete this.getCacheStore(strategyName)[key];
  }
  clear(strategyName) {
    this.caches[strategyName] = {};
  }
  getCacheStore(strategyName) {
    if (strategyName in this.caches) return this.caches[strategyName];
    return this.caches[strategyName] = {};
  }
  static {
    this.\u0275fac = function StrategyCacheService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _StrategyCacheService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _StrategyCacheService,
      factory: _StrategyCacheService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StrategyCacheService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var LOCAL_STORAGE = new InjectionToken("window_local_storage");
function getLocalStorage() {
  return typeof window !== "undefined" ? window.localStorage : null;
}
var LocalStorageProvider = {
  provide: LOCAL_STORAGE,
  useFactory: getLocalStorage
};
var SESSION_STORAGE = new InjectionToken("window_session_storage");
function getSessionStorage() {
  return typeof window !== "undefined" ? window.sessionStorage : null;
}
var SessionStorageProvider = {
  provide: SESSION_STORAGE,
  useFactory: getSessionStorage
};
var BaseSyncStorageStrategy = class {
  constructor(storage, cache) {
    this.storage = storage;
    this.cache = cache;
    this.keyChanges = new Subject();
  }
  get isAvailable() {
    if (this._isAvailable === void 0) this._isAvailable = CompatHelper.isStorageAvailable(this.storage);
    return this._isAvailable;
  }
  get(key) {
    let data = this.cache.get(this.name, key);
    if (data !== void 0) return of(data);
    try {
      const item = this.storage.getItem(key);
      if (item !== null) {
        data = JSON.parse(item);
        this.cache.set(this.name, key, data);
      }
    } catch (err) {
      console.warn(err);
    }
    return of(data);
  }
  set(key, value) {
    const data = JSON.stringify(value);
    this.storage.setItem(key, data);
    this.cache.set(this.name, key, value);
    this.keyChanges.next(key);
    return of(value);
  }
  del(key) {
    this.storage.removeItem(key);
    this.cache.del(this.name, key);
    this.keyChanges.next(key);
    return of(null);
  }
  clear() {
    this.storage.clear();
    this.cache.clear(this.name);
    this.keyChanges.next(null);
    return of(null);
  }
};
var LocalStorageStrategy = class _LocalStorageStrategy extends BaseSyncStorageStrategy {
  static {
    this.strategyName = StorageStrategies.Local;
  }
  constructor(storage, cache, platformId, zone) {
    super(storage, cache);
    this.storage = storage;
    this.cache = cache;
    this.platformId = platformId;
    this.zone = zone;
    this.name = _LocalStorageStrategy.strategyName;
    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();
  }
  listenExternalChanges() {
    window.addEventListener("storage", (event) => this.zone.run(() => {
      if (event.storageArea !== this.storage) return;
      const key = event.key;
      if (key !== null) this.cache.del(this.name, event.key);
      else this.cache.clear(this.name);
      this.keyChanges.next(key);
    }));
  }
  static {
    this.\u0275fac = function LocalStorageStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LocalStorageStrategy)(\u0275\u0275inject(LOCAL_STORAGE), \u0275\u0275inject(StrategyCacheService), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _LocalStorageStrategy,
      factory: _LocalStorageStrategy.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalStorageStrategy, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCAL_STORAGE]
    }]
  }, {
    type: StrategyCacheService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NgZone
  }], null);
})();
var SessionStorageStrategy = class _SessionStorageStrategy extends BaseSyncStorageStrategy {
  static {
    this.strategyName = StorageStrategies.Session;
  }
  constructor(storage, cache, platformId, zone) {
    super(storage, cache);
    this.storage = storage;
    this.cache = cache;
    this.platformId = platformId;
    this.zone = zone;
    this.name = _SessionStorageStrategy.strategyName;
    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();
  }
  listenExternalChanges() {
    window.addEventListener("storage", (event) => this.zone.run(() => {
      if (event.storageArea !== this.storage) return;
      const key = event.key;
      if (event.key !== null) this.cache.del(this.name, event.key);
      else this.cache.clear(this.name);
      this.keyChanges.next(key);
    }));
  }
  static {
    this.\u0275fac = function SessionStorageStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SessionStorageStrategy)(\u0275\u0275inject(SESSION_STORAGE), \u0275\u0275inject(StrategyCacheService), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _SessionStorageStrategy,
      factory: _SessionStorageStrategy.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SessionStorageStrategy, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [SESSION_STORAGE]
    }]
  }, {
    type: StrategyCacheService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NgZone
  }], null);
})();
var InMemoryStorageStrategy = class _InMemoryStorageStrategy {
  static {
    this.strategyName = StorageStrategies.InMemory;
  }
  constructor(cache) {
    this.cache = cache;
    this.keyChanges = new Subject();
    this.isAvailable = true;
    this.name = _InMemoryStorageStrategy.strategyName;
  }
  get(key) {
    return of(this.cache.get(this.name, key));
  }
  set(key, value) {
    this.cache.set(this.name, key, value);
    this.keyChanges.next(key);
    return of(value);
  }
  del(key) {
    this.cache.del(this.name, key);
    this.keyChanges.next(key);
    return of(null);
  }
  clear() {
    this.cache.clear(this.name);
    this.keyChanges.next(null);
    return of(null);
  }
  static {
    this.\u0275fac = function InMemoryStorageStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _InMemoryStorageStrategy)(\u0275\u0275inject(StrategyCacheService));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _InMemoryStorageStrategy,
      factory: _InMemoryStorageStrategy.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InMemoryStorageStrategy, [{
    type: Injectable
  }], () => [{
    type: StrategyCacheService,
    decorators: [{
      type: Inject,
      args: [StrategyCacheService]
    }]
  }], null);
})();
var STORAGE_STRATEGIES = new InjectionToken("STORAGE_STRATEGIES");
var Strategies = [{
  provide: STORAGE_STRATEGIES,
  useClass: InMemoryStorageStrategy,
  multi: true
}, {
  provide: STORAGE_STRATEGIES,
  useClass: LocalStorageStrategy,
  multi: true
}, {
  provide: STORAGE_STRATEGIES,
  useClass: SessionStorageStrategy,
  multi: true
}];
var [InMemoryStorageStrategyProvider, LocalStorageStrategyProvider, SessionStorageStrategyProvider] = Strategies;
var InvalidStrategyError = "invalid_strategy";
var StrategyIndex = class _StrategyIndex {
  static {
    this.index = {};
  }
  constructor(strategies) {
    this.strategies = strategies;
    this.registration$ = new Subject();
    if (!strategies) strategies = [];
    this.strategies = strategies.reverse().map((strategy, index, arr) => strategy.name).map((name, index, arr) => arr.indexOf(name) === index ? index : null).filter((index) => index !== null).map((index) => strategies[index]);
  }
  static get(name) {
    if (!this.isStrategyRegistered(name)) throw Error(InvalidStrategyError);
    let strategy = this.index[name];
    if (!strategy.isAvailable) {
      strategy = this.index[StorageStrategies.InMemory];
    }
    return strategy;
  }
  static set(name, strategy) {
    this.index[name] = strategy;
  }
  static clear(name) {
    if (name !== void 0) delete this.index[name];
    else this.index = {};
  }
  static isStrategyRegistered(name) {
    return name in this.index;
  }
  static hasRegistredStrategies() {
    return Object.keys(this.index).length > 0;
  }
  getStrategy(name) {
    return _StrategyIndex.get(name);
  }
  indexStrategies() {
    this.strategies.forEach((strategy) => this.register(strategy.name, strategy));
  }
  indexStrategy(name, overrideIfExists = false) {
    if (_StrategyIndex.isStrategyRegistered(name) && !overrideIfExists) return _StrategyIndex.get(name);
    const strategy = this.strategies.find((strategy2) => strategy2.name === name);
    if (!strategy) throw new Error(InvalidStrategyError);
    this.register(name, strategy, overrideIfExists);
    return strategy;
  }
  register(name, strategy, overrideIfExists = false) {
    if (!_StrategyIndex.isStrategyRegistered(name) || overrideIfExists) {
      _StrategyIndex.set(name, strategy);
      this.registration$.next(name);
    }
  }
  static {
    this.\u0275fac = function StrategyIndex_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _StrategyIndex)(\u0275\u0275inject(STORAGE_STRATEGIES, 8));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _StrategyIndex,
      factory: _StrategyIndex.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StrategyIndex, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [STORAGE_STRATEGIES]
    }]
  }], null);
})();
var LocalStorageService = class extends SyncStorage {
};
function buildService$1(index) {
  const strategy = index.indexStrategy(StorageStrategies.Local);
  return new SyncStorage(strategy);
}
var LocalStorageServiceProvider = {
  provide: LocalStorageService,
  useFactory: buildService$1,
  deps: [StrategyIndex]
};
var SessionStorageService = class extends SyncStorage {
};
function buildService(index) {
  const strategy = index.indexStrategy(StorageStrategies.Session);
  return new SyncStorage(strategy);
}
var SessionStorageServiceProvider = {
  provide: SessionStorageService,
  useFactory: buildService,
  deps: [StrategyIndex]
};
var LIB_CONFIG = new InjectionToken("ngx_webstorage_config");
var InternalNgxWebstorageFeatureKind;
(function(InternalNgxWebstorageFeatureKind2) {
  InternalNgxWebstorageFeatureKind2[InternalNgxWebstorageFeatureKind2["Config"] = 1] = "Config";
  InternalNgxWebstorageFeatureKind2[InternalNgxWebstorageFeatureKind2["LocalStorage"] = 2] = "LocalStorage";
  InternalNgxWebstorageFeatureKind2[InternalNgxWebstorageFeatureKind2["SessionStorage"] = 3] = "SessionStorage";
})(InternalNgxWebstorageFeatureKind || (InternalNgxWebstorageFeatureKind = {}));
function appInit() {
  const config = inject(LIB_CONFIG);
  const index = inject(StrategyIndex);
  return () => {
    StorageKeyManager.consumeConfiguration(config);
    index.indexStrategies();
  };
}
function provideNgxWebstorage(...features) {
  const {
    configProvider,
    featureProviders
  } = parseFeatures(features);
  return makeEnvironmentProviders([configProvider, InMemoryStorageStrategyProvider, provideAppInitializer(() => {
    const initializerFn = appInit();
    return initializerFn();
  }), ...featureProviders]);
}
function parseFeatures(features) {
  let configProvider;
  const featureProviders = [];
  const parsedFeatures = /* @__PURE__ */ new Set();
  for (const feature of features) {
    if (parsedFeatures.has(feature.kind)) throw new Error(`Feature ${feature.kind} is already provided.`);
    if (feature.kind === InternalNgxWebstorageFeatureKind.Config) {
      configProvider = feature.providers[0];
    } else featureProviders.push(...feature.providers);
    parsedFeatures.add(feature.kind);
  }
  return {
    configProvider: configProvider ?? {
      provide: LIB_CONFIG,
      useValue: {
        prefix: DefaultPrefix,
        separator: DefaultSeparator,
        caseSensitive: DefaultIsCaseSensitive
      }
    },
    featureProviders
  };
}
function makeNgxWebstorageFeature(kind, providers) {
  return {
    kind,
    providers
  };
}
function withNgxWebstorageConfig(config) {
  return makeNgxWebstorageFeature(InternalNgxWebstorageFeatureKind.Config, [{
    provide: LIB_CONFIG,
    useValue: config
  }]);
}
function withLocalStorage() {
  return makeNgxWebstorageFeature(InternalNgxWebstorageFeatureKind.LocalStorage, [LocalStorageProvider, LocalStorageServiceProvider, LocalStorageStrategyProvider]);
}
function withSessionStorage() {
  return makeNgxWebstorageFeature(InternalNgxWebstorageFeatureKind.SessionStorage, [SessionStorageProvider, SessionStorageServiceProvider, SessionStorageStrategyProvider]);
}

// src/app/shared/templates/error-page/error-page.component.ts
function ErrorPageComponent_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 4);
    \u0275\u0275listener("click", function ErrorPageComponent_button_9_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.goHome());
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "translate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 1, "Return to Home"));
  }
}
var ErrorPageComponent = class _ErrorPageComponent {
  route;
  router;
  errorTitle = "Oops! Something went wrong";
  errorMessage = "An unexpected error occurred. Please try again later.";
  isGoHomeShowed = false;
  appConstants = AppConstants;
  constructor(route, router) {
    this.route = route;
    this.router = router;
    this.route.queryParams.subscribe((params) => {
      if (params["title"])
        this.errorTitle = params["title"];
      if (params["message"])
        this.errorMessage = params["message"];
      if (params["isGoHomeShowed"])
        this.isGoHomeShowed = params["isGoHomeShowed"];
    });
  }
  goHome() {
    this.router.navigate(["/"]);
  }
  static \u0275fac = function ErrorPageComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ErrorPageComponent)(\u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(Router));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ErrorPageComponent, selectors: [["app-error-page"]], decls: 10, vars: 8, consts: [[1, "error-container"], [1, "error-card"], ["alt", "Error", 1, "error-image", 3, "src"], ["class", "btn", 3, "click", 4, "ngIf"], [1, "btn", 3, "click"]], template: function ErrorPageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275element(2, "img", 2);
      \u0275\u0275elementStart(3, "h1");
      \u0275\u0275text(4);
      \u0275\u0275pipe(5, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "p");
      \u0275\u0275text(7);
      \u0275\u0275pipe(8, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, ErrorPageComponent_button_9_Template, 3, 3, "button", 3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("src", ctx.appConstants.getAsset("assets/images/error.svg"), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 4, ctx.errorTitle));
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(8, 6, ctx.errorMessage));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isGoHomeShowed);
    }
  }, dependencies: [CommonModule, NgIf, TranslatePipe], styles: ["\n\n.error-container[_ngcontent-%COMP%] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  background: #f8f9fa;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%] {\n  text-align: center;\n  background: white;\n  padding: 2rem;\n  border-radius: 12px;\n  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);\n  max-width: 400px;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%]   .error-image[_ngcontent-%COMP%] {\n  width: 80%;\n  margin-bottom: 20px;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%] {\n  font-size: 24px;\n  color: #d9534f;\n  margin-bottom: 10px;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  font-size: 16px;\n  color: #6c757d;\n  margin-bottom: 20px;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%] {\n  background: #d9534f;\n  color: white;\n  padding: 10px 20px;\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  font-size: 16px;\n  transition: 0.3s;\n}\n.error-container[_ngcontent-%COMP%]   .error-card[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]:hover {\n  background: #c9302c;\n}\n/*# sourceMappingURL=error-page.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ErrorPageComponent, { className: "ErrorPageComponent", filePath: "src/app/shared/templates/error-page/error-page.component.ts", lineNumber: 17 });
})();

// src/app/shared/app-services/breadcrumb.service.ts
var BreadcrumbService = class _BreadcrumbService {
  router;
  translate;
  breadcrumbsSubject = new BehaviorSubject([]);
  breadcrumbs$ = this.breadcrumbsSubject.asObservable();
  constructor(router, translate) {
    this.router = router;
    this.translate = translate;
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd)).subscribe(() => {
      const root = this.router.routerState.snapshot.root;
      const newBreadcrumb = this.getBreadcrumb(root);
      const stateBreadcrumb = this.router.getCurrentNavigation()?.extras.state?.["breadcrumb"];
      if (stateBreadcrumb) {
        let currentBreadcrumbs = this.breadcrumbsSubject.getValue();
        const newBreadcrumbItem = {
          label: stateBreadcrumb,
          url: this.router.url
        };
        currentBreadcrumbs = [...currentBreadcrumbs, newBreadcrumbItem];
        this.breadcrumbsSubject.next(currentBreadcrumbs);
      } else if (newBreadcrumb) {
        let currentBreadcrumbs = this.breadcrumbsSubject.getValue();
        const existingIndex = currentBreadcrumbs.findIndex((breadcrumb) => breadcrumb.label === newBreadcrumb.label);
        if (existingIndex !== -1) {
          currentBreadcrumbs.splice(existingIndex + 1, currentBreadcrumbs.length - 1 - existingIndex + 1);
        } else {
          currentBreadcrumbs = [...currentBreadcrumbs, newBreadcrumb];
        }
        this.breadcrumbsSubject.next(currentBreadcrumbs);
      }
    });
  }
  getBreadcrumb(route, url = "") {
    if (route.routeConfig && route.routeConfig.data) {
      const routeURL = route.pathFromRoot.map((v) => v.url.map((segment) => segment.path).join("/")).join("/");
      return {
        label: route.routeConfig.data["breadcrumb"],
        url: `${routeURL}`
      };
    }
    for (const child of route.children) {
      const childBreadcrumb = this.getBreadcrumb(child, url);
      if (childBreadcrumb) {
        return childBreadcrumb;
      }
    }
    return null;
  }
  getCurrentBreadcrumbLabel$() {
    return this.breadcrumbs$.pipe(map((breadcrumbs) => breadcrumbs.length > 0 ? this.translate.instant(breadcrumbs[breadcrumbs.length - 1].label) : ""));
  }
  updateCurrentBreadcrumb(label, url) {
    const currentBreadcrumbs = this.breadcrumbsSubject.getValue();
    if (currentBreadcrumbs.length > 0) {
      const filteredBreadcrumbs = currentBreadcrumbs.filter((b) => b.label !== "Power BI");
      filteredBreadcrumbs[filteredBreadcrumbs.length - 1] = {
        label,
        url: url || filteredBreadcrumbs[filteredBreadcrumbs.length - 1].url
      };
      this.breadcrumbsSubject.next([...filteredBreadcrumbs]);
    }
  }
  static \u0275fac = function BreadcrumbService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadcrumbService)(\u0275\u0275inject(Router), \u0275\u0275inject(TranslateService));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _BreadcrumbService, factory: _BreadcrumbService.\u0275fac, providedIn: "root" });
};

// src/app/shared/templates/page/page.component.ts
var _c0 = ["featureContainer"];
var PageComponent = class _PageComponent {
  route;
  router;
  pagesRepository;
  featureRenderer;
  breadcrumbService;
  featureContainer;
  page = null;
  pageFeatures = [];
  componentRefs = [];
  constructor(route, router, pagesRepository, featureRenderer, breadcrumbService) {
    this.route = route;
    this.router = router;
    this.pagesRepository = pagesRepository;
    this.featureRenderer = featureRenderer;
    this.breadcrumbService = breadcrumbService;
  }
  ngOnInit() {
    const id = this.route.snapshot.params["id"];
    if (id) {
      this.loadPageWithFeatures(Number(id));
    }
  }
  ngAfterViewInit() {
    return __async(this, null, function* () {
      if (this.pageFeatures.length > 0) {
        yield this.renderFeatures();
      }
    });
  }
  loadPageWithFeatures(pageId) {
    return __async(this, null, function* () {
      const result = yield this.pagesRepository.getByIdWithFeatures(pageId);
      if (result) {
        this.page = result.page;
        this.pageFeatures = result.features;
        if (this.page && this.page.name) {
          this.breadcrumbService.updateCurrentBreadcrumb(this.page.name, `/page/${this.page.id}`);
        }
        if (this.featureContainer) {
          yield this.renderFeatures();
        }
      }
    });
  }
  renderFeatures() {
    return __async(this, null, function* () {
      console.log("Rendering features, container:", this.featureContainer);
      if (!this.featureContainer) {
        console.error("Feature container is not initialized");
        return;
      }
      this.componentRefs.forEach((ref) => ref.destroy());
      this.componentRefs = [];
      this.featureContainer.clear();
      for (const feature of this.pageFeatures) {
        if (!feature.componentName)
          continue;
        const componentType = FeatureRegistry.getComponent(feature.componentName);
        if (!componentType) {
          console.error(`Component ${feature.componentName} not found in FeatureRegistry`);
          continue;
        }
        const componentRef = this.featureContainer.createComponent(componentType);
        const element = componentRef.location.nativeElement;
        element.style.overflow = "auto";
        element.style.left = `${feature.position_x}px`;
        element.style.top = `${feature.position_y}px`;
        element.style.width = `${feature.width}px`;
        element.style.height = `${feature.height}px`;
        element.classList.add("feature-component");
        if (feature.parameters) {
          componentRef.instance.parameters = feature.parameters;
        }
        this.componentRefs.push(componentRef);
      }
    });
  }
  ngOnDestroy() {
    this.componentRefs.forEach((ref) => ref.destroy());
  }
  static \u0275fac = function PageComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PageComponent)(\u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(PagesRepository), \u0275\u0275directiveInject(FeatureRendererService), \u0275\u0275directiveInject(BreadcrumbService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PageComponent, selectors: [["app-page"]], viewQuery: function PageComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c0, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.featureContainer = _t.first);
    }
  }, decls: 4, vars: 0, consts: [["featureContainer", ""], [1, "page-container"], [1, "features-absolute"]], template: function PageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 1)(1, "div", 2);
      \u0275\u0275element(2, "div", null, 0);
      \u0275\u0275elementEnd()();
    }
  }, dependencies: [CommonModule], styles: ["\n\n.page-container[_ngcontent-%COMP%] {\n  padding: 20px;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.page-container[_ngcontent-%COMP%]   .page-header[_ngcontent-%COMP%] {\n  margin-bottom: 20px;\n}\n.page-container[_ngcontent-%COMP%]   .page-header[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%] {\n  margin: 0;\n  font-size: 24px;\n  font-weight: 500;\n}\n.page-container[_ngcontent-%COMP%]   .page-header[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 10px 0 0;\n  color: #666;\n}\n.page-container[_ngcontent-%COMP%]   .features-absolute[_ngcontent-%COMP%] {\n  position: relative;\n  padding: 1rem;\n}\n.page-container[_ngcontent-%COMP%]   .features-absolute[_ngcontent-%COMP%]     .feature-component {\n  position: absolute;\n}\n.grid-container[_ngcontent-%COMP%] {\n  display: grid;\n  grid-template-columns: repeat(12, 1fr);\n  gap: 20px;\n  width: 100%;\n  height: 100%;\n}\n.feature-container[_ngcontent-%COMP%] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  min-height: 200px;\n}\n.feature-iframe[_ngcontent-%COMP%] {\n  width: 100%;\n  height: 100%;\n  border: none;\n}\n/*# sourceMappingURL=page.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PageComponent, { className: "PageComponent", filePath: "src/app/shared/templates/page/page.component.ts", lineNumber: 18 });
})();

// src/app/app.routes.ts
var authGuard = (route, state) => {
  const router = inject(Router);
  const smsAuthService = inject(SMSAuthService);
  const supabaseAuthService = inject(SupabaseAuthService);
  const employeeService = inject(EmployeeService);
  return combineLatest([
    smsAuthService.isAuthenticated$(),
    supabaseAuthService.isAuthenticated$()
  ]).pipe(map(([smsAuth, supabaseAuth]) => {
    const expectedRoles = route.data["roles"];
    if (!supabaseAuth) {
      return router.createUrlTree(["/login"]);
    }
    let employee = supabaseAuthService.getCurrentEmployee();
    if (!employee) {
      return router.createUrlTree(["/error"], {
        queryParams: {
          title: "Access Denied",
          message: "User not found in App DB."
        }
      });
    }
    if (employee.is_2fa_enabled && !smsAuth) {
      return router.createUrlTree(["/login"]);
    }
    if (expectedRoles && !(expectedRoles.includes("*") || expectedRoles.includes(employee.role))) {
      return router.createUrlTree(["/home"]);
    }
    return true;
  }), catchError(() => of(router.createUrlTree(["/login"]))));
};
var routes = [
  { path: "", redirectTo: "/home", pathMatch: "full" },
  {
    component: MsalRedirectComponent,
    matcher: (url) => {
      return url.length === 1 && url[0].path.startsWith("code") ? { consumed: url } : null;
    }
  },
  {
    canActivate: [authGuard],
    path: "home",
    pathMatch: "prefix",
    loadComponent: () => import("./chunk-QPMCSYQ5.js").then((c) => c.HomeComponent),
    data: { breadcrumb: "Home", roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "profile",
    pathMatch: "prefix",
    loadComponent: () => import("./chunk-WZYWGSST.js").then((c) => c.ProfileComponent),
    data: { breadcrumb: "Employee Profile", roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "edit-profile",
    loadComponent: () => import("./chunk-KKXXY7T6.js").then((c) => c.ProfileEditComponent),
    data: { breadcrumb: "Edit Employee", roles: "*" }
  },
  // {
  //     canActivate: [authGuard],
  //     path: 'create-employee',
  //     loadComponent: () => import('./employee/profile/profile-edit/profile-edit.component').then(c => c.ProfileEditComponent),
  //     data: { breadcrumb: 'Create Employee', roles: '*' }
  // },
  {
    canActivate: [authGuard],
    path: "employee-view",
    loadComponent: () => import("./chunk-WZ25IDC4.js").then((c) => c.EmployeesComponent),
    data: { breadcrumb: "Employee View", roles: ["manager", "hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "birthday-calendar",
    loadComponent: () => import("./chunk-42DCYW4E.js").then((c) => c.BirthdayCalendarComponent),
    data: { breadcrumb: "Birthday calendar", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "employee-logs",
    loadComponent: () => import("./chunk-HH7A7ZZ3.js").then((c) => c.EmployeeLogsComponent),
    data: { breadcrumb: "Employee logs", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "logs",
    loadComponent: () => import("./chunk-YMUPIA3L.js").then((c) => c.LogsComponent),
    data: { breadcrumb: "All logs", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "objectives-distribution",
    loadComponent: () => import("./chunk-6FHBR77G.js").then((c) => c.ObjectiveDistributionComponent),
    data: { breadcrumb: "Distribution Objectives", roles: ["payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "objectives-management",
    loadComponent: () => import("./chunk-ZOPSGODR.js").then((c) => c.ObjectivesManagementComponent),
    data: { breadcrumb: "Objectives Management", roles: ["manager", "hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "annual-grant-management",
    loadComponent: () => import("./chunk-SXUHN7JL.js").then((c) => c.ObjectiveAnnualGrantComponent),
    data: { breadcrumb: "Annual grant management", roles: ["manager", "hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "objectives-awaited",
    loadComponent: () => import("./chunk-ZOPSGODR.js").then((c) => c.ObjectivesManagementComponent),
    data: { breadcrumb: "Awaited Objectives", isAwaited: true, roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "objective-form",
    loadComponent: () => import("./chunk-X3BXBEVA.js").then((c) => c.ObjectiveFormComponent),
    data: { breadcrumb: "Objective Form", roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "objective-templates",
    loadComponent: () => import("./chunk-MDXY7YZ2.js").then((c) => c.ObjectiveTemplatesComponent),
    data: { breadcrumb: "Objective templates", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "feedback-management",
    loadComponent: () => import("./chunk-5TB3VMQO.js").then((c) => c.FeedbackManagementComponent),
    data: { breadcrumb: "Feedback Management", roles: ["manager", "hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "feedback-awaited",
    loadComponent: () => import("./chunk-5TB3VMQO.js").then((c) => c.FeedbackManagementComponent),
    data: { breadcrumb: "Awaited feedbacks", isAwaited: true, roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "feedback-form",
    loadComponent: () => import("./chunk-MPWFQLWG.js").then((c) => c.FeedbackFormWrapperComponent),
    data: { breadcrumb: "Feedback Form", roles: ["*"] }
  },
  {
    canActivate: [authGuard],
    path: "feedback-templates",
    loadComponent: () => import("./chunk-6SZW2C5N.js").then((c) => c.FeedbackTemplatesComponent),
    data: { breadcrumb: "Feedback Templates", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    path: "feedback-distribution",
    loadComponent: () => import("./chunk-7CSQRCO5.js").then((c) => c.FeedbackDistributionComponent),
    data: { breadcrumb: "Feedback Management", roles: ["hr", "payroll", "global-admin"] }
  },
  {
    canActivate: [authGuard],
    loadComponent: () => import("./chunk-TQP6TCI4.js").then((c) => c.RedirectionsHandlerComponent),
    path: "redirections-handler",
    data: { roles: "*" }
  },
  {
    loadComponent: () => import("./chunk-FE56VQCW.js").then((c) => c.LoginComponent),
    path: "login",
    data: { breadcrumb: "Login", roles: "*" }
  },
  {
    canActivate: [authGuard],
    path: "admin",
    children: [
      {
        canActivate: [authGuard],
        path: "app-settings",
        children: [
          {
            path: "styles",
            loadComponent: () => import("./chunk-7FRF34LW.js").then((c) => c.StylesSettingsComponent),
            data: { breadcrumb: "Styles Settings", roles: ["global-admin"] }
          },
          {
            path: "language",
            loadComponent: () => import("./chunk-FHK4OUNG.js").then((c) => c.LanguageSettingsComponent),
            data: { breadcrumb: "Language Settings", roles: ["global-admin"] }
          },
          {
            path: "sidebar",
            loadComponent: () => import("./chunk-MAW45KDV.js").then((c) => c.SidebarManagementComponent),
            data: { breadcrumb: "Sidebar Settings", roles: ["global-admin"] }
          },
          {
            path: "notification-settings",
            loadComponent: () => import("./chunk-O77F7JUR.js").then((c) => c.NotificationSettingsComponent),
            data: { breadcrumb: "Notification Settings", roles: ["global-admin"] }
          }
        ]
      },
      {
        canActivate: [authGuard],
        path: "features-settings",
        loadComponent: () => import("./chunk-TUIWFH6K.js").then((c) => c.FeaturesSettingsComponent),
        data: { breadcrumb: "Features Settings", roles: ["global-admin"] }
      },
      {
        path: "page-settings",
        children: [
          {
            path: "management",
            loadComponent: () => import("./chunk-OPCVI7AH.js").then((m) => m.PagesManagementComponent)
          },
          {
            path: "editor/:id",
            loadComponent: () => import("./chunk-OVL6KZOY.js").then((m) => m.PageEditorComponent)
          }
        ]
      }
    ]
  },
  {
    path: "error",
    component: ErrorPageComponent
  },
  {
    path: "page/:id",
    component: PageComponent
  }
];

// src/app/shared/configs/msal-config.ts
var isIE = window.navigator.userAgent.indexOf("MSIE ") > -1 || window.navigator.userAgent.indexOf("Trident/") > -1;
function loggerCallback(logLevel, message) {
  console.log(message);
}
function MSALInstanceFactory() {
  return new PublicClientApplication({
    auth: {
      clientId: environment.CLIENT_ID,
      authority: "https://login.microsoftonline.com/" + environment.TENANT_ID,
      redirectUri: environment.REDIRECT_URL,
      navigateToLoginRequestUrl: false
    },
    cache: {
      cacheLocation: BrowserCacheLocation.LocalStorage,
      storeAuthStateInCookie: isIE
    },
    system: {
      loggerOptions: {
        loggerCallback,
        logLevel: LogLevel.Info,
        piiLoggingEnabled: false
      }
    }
  });
}
function MSALInterceptorConfigFactory() {
  return {
    interactionType: InteractionType.Redirect,
    protectedResourceMap: /* @__PURE__ */ new Map([
      ["https://graph.microsoft.com/v1.0/me", ["user.read"]],
      ["https://api.myapplication.com/users/*", ["user.read"]]
    ])
  };
}
function MSALGuardConfigFactory() {
  return {
    interactionType: InteractionType.Redirect,
    authRequest: {
      scopes: ["user.read"]
    }
  };
}

// src/app/shared/interceptors/supabase.interceptor.ts
var SupabaseInterceptor = class _SupabaseInterceptor {
  intercept(req, next) {
    const modifiedReq = req.clone({
      setHeaders: {
        "x-client-info": ""
        // Replace with actual logic
      }
    });
    return next.handle(modifiedReq);
  }
  static \u0275fac = function SupabaseInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SupabaseInterceptor)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SupabaseInterceptor, factory: _SupabaseInterceptor.\u0275fac });
};

// src/app/app.config.ts
var httpLoaderFactory = (http) => new TranslateHttpLoader(http, environment.FILES_PATH + "translations/", ".json");
if (environment.production) {
  window.console.log = () => {
  };
  window.console.error = () => {
  };
  window.console.warn = () => {
  };
}
var appConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: !environment.production }),
    provideNgxWebstorage(withNgxWebstorageConfig({ separator: ":", caseSensitive: true }), withLocalStorage(), withSessionStorage()),
    provideRouter(routes, withHashLocation()),
    provideAnimationsAsync(),
    provideHttpClient(withInterceptorsFromDi()),
    provideMomentDateAdapter(void 0, { useUtc: true }),
    importProvidersFrom([
      NgxGraphModule,
      TranslateModule.forRoot({
        loader: {
          provide: TranslateLoader,
          useFactory: httpLoaderFactory,
          deps: [HttpClient]
        }
      })
    ]),
    {
      provide: MSAL_INSTANCE,
      useFactory: MSALInstanceFactory
    },
    {
      provide: MSAL_GUARD_CONFIG,
      useFactory: MSALGuardConfigFactory
    },
    {
      provide: MSAL_INTERCEPTOR_CONFIG,
      useFactory: MSALInterceptorConfigFactory
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: MsalInterceptor,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: SupabaseInterceptor,
      multi: true
    },
    // {
    //   provide: APP_INITIALIZER,
    //   useFactory: initCSP,
    //   deps: [CspService],
    //   multi: true
    // },
    MsalGuard,
    MsalService,
    MsalBroadcastService,
    provideAnimationsAsync()
  ]
};

// src/app/shared/templates/breadcrumb/breadcrumb.component.ts
var _c02 = (a0) => [a0];
function BreadcrumbComponent_div_0_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 8);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(4, _c02, item_r1.url));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(3, 2, item_r1.label), " ");
  }
}
function BreadcrumbComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1)(1, "h2", 2);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275pipe(4, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nav")(6, "ol", 3)(7, "li", 4)(8, "a", 5);
    \u0275\u0275element(9, "i", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(10, BreadcrumbComponent_div_0_ng_container_10_Template, 4, 6, "ng-container", 7);
    \u0275\u0275pipe(11, "async");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 4, \u0275\u0275pipeBind1(3, 2, ctx_r1.breadcrumbService.getCurrentBreadcrumbLabel$()) || ""));
    \u0275\u0275advance(8);
    \u0275\u0275property("ngForOf", \u0275\u0275pipeBind1(11, 6, ctx_r1.breadcrumbService.breadcrumbs$));
  }
}
var BreadcrumbComponent = class _BreadcrumbComponent {
  breadcrumbService;
  router;
  constructor(breadcrumbService, router) {
    this.breadcrumbService = breadcrumbService;
    this.router = router;
  }
  isLoginRoute() {
    return this.router.url === "/login";
  }
  static \u0275fac = function BreadcrumbComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreadcrumbComponent)(\u0275\u0275directiveInject(BreadcrumbService), \u0275\u0275directiveInject(Router));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _BreadcrumbComponent, selectors: [["app-breadcrumb"]], features: [\u0275\u0275ProvidersFeature([])], decls: 2, vars: 3, consts: [["class", "my-auto mb-2", 4, "ngIf"], [1, "my-auto", "mb-2"], [1, "mb-1"], [1, "breadcrumb", "mb-0"], [1, "breadcrumb-item"], ["routerLink", "/"], [1, "ti", "ti-smart-home"], [4, "ngFor", "ngForOf"], ["routerLinkActive", "router-link-active", 1, "breadcrumb-item", 3, "routerLink"]], template: function BreadcrumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, BreadcrumbComponent_div_0_Template, 12, 8, "div", 0);
      \u0275\u0275pipe(1, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 1, ctx.breadcrumbService.getCurrentBreadcrumbLabel$()) != "Home");
    }
  }, dependencies: [
    AsyncPipe,
    RouterLink,
    CommonModule,
    NgForOf,
    NgIf,
    TranslatePipe
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(BreadcrumbComponent, { className: "BreadcrumbComponent", filePath: "src/app/shared/templates/breadcrumb/breadcrumb.component.ts", lineNumber: 20 });
})();

// node_modules/@angular/material/fesm2022/progress-bar.mjs
function MatProgressBar_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 2);
  }
}
var MAT_PROGRESS_BAR_DEFAULT_OPTIONS = new InjectionToken("MAT_PROGRESS_BAR_DEFAULT_OPTIONS");
var MAT_PROGRESS_BAR_LOCATION = new InjectionToken("mat-progress-bar-location", {
  providedIn: "root",
  factory: MAT_PROGRESS_BAR_LOCATION_FACTORY
});
function MAT_PROGRESS_BAR_LOCATION_FACTORY() {
  const _document = inject(DOCUMENT);
  const _location = _document ? _document.location : null;
  return {
    // Note that this needs to be a function, rather than a property, because Angular
    // will only resolve it once, but we want the current path on each call.
    getPathname: () => _location ? _location.pathname + _location.search : ""
  };
}
var MatProgressBar = class _MatProgressBar {
  _elementRef = inject(ElementRef);
  _ngZone = inject(NgZone);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _renderer = inject(Renderer2);
  _cleanupTransitionEnd;
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  constructor() {
    const defaults = inject(MAT_PROGRESS_BAR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._isNoopAnimation = this._animationMode === "NoopAnimations";
    if (defaults) {
      if (defaults.color) {
        this.color = this._defaultColor = defaults.color;
      }
      this.mode = defaults.mode || this.mode;
    }
  }
  /** Flag that indicates whether NoopAnimations mode is set to true. */
  _isNoopAnimation = false;
  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.
  /**
   * Theme color of the progress bar. This API is supported in M2 themes only, it
   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/progress-bar/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  get color() {
    return this._color || this._defaultColor;
  }
  set color(value) {
    this._color = value;
  }
  _color;
  _defaultColor = "primary";
  /** Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow. */
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = clamp(v || 0);
    this._changeDetectorRef.markForCheck();
  }
  _value = 0;
  /** Buffer value of the progress bar. Defaults to zero. */
  get bufferValue() {
    return this._bufferValue || 0;
  }
  set bufferValue(v) {
    this._bufferValue = clamp(v || 0);
    this._changeDetectorRef.markForCheck();
  }
  _bufferValue = 0;
  /**
   * Event emitted when animation of the primary progress bar completes. This event will not
   * be emitted when animations are disabled, nor will it be emitted for modes with continuous
   * animations (indeterminate and query).
   */
  animationEnd = new EventEmitter();
  /**
   * Mode of the progress bar.
   *
   * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
   * 'determinate'.
   * Mirrored to mode attribute.
   */
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
    this._changeDetectorRef.markForCheck();
  }
  _mode = "determinate";
  ngAfterViewInit() {
    this._ngZone.runOutsideAngular(() => {
      this._cleanupTransitionEnd = this._renderer.listen(this._elementRef.nativeElement, "transitionend", this._transitionendHandler);
    });
  }
  ngOnDestroy() {
    this._cleanupTransitionEnd?.();
  }
  /** Gets the transform style that should be applied to the primary bar. */
  _getPrimaryBarTransform() {
    return `scaleX(${this._isIndeterminate() ? 1 : this.value / 100})`;
  }
  /** Gets the `flex-basis` value that should be applied to the buffer bar. */
  _getBufferBarFlexBasis() {
    return `${this.mode === "buffer" ? this.bufferValue : 100}%`;
  }
  /** Returns whether the progress bar is indeterminate. */
  _isIndeterminate() {
    return this.mode === "indeterminate" || this.mode === "query";
  }
  /** Event handler for `transitionend` events. */
  _transitionendHandler = (event) => {
    if (this.animationEnd.observers.length === 0 || !event.target || !event.target.classList.contains("mdc-linear-progress__primary-bar")) {
      return;
    }
    if (this.mode === "determinate" || this.mode === "buffer") {
      this._ngZone.run(() => this.animationEnd.next({
        value: this.value
      }));
    }
  };
  static \u0275fac = function MatProgressBar_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatProgressBar)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatProgressBar,
    selectors: [["mat-progress-bar"]],
    hostAttrs: ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "tabindex", "-1", 1, "mat-mdc-progress-bar", "mdc-linear-progress"],
    hostVars: 10,
    hostBindings: function MatProgressBar_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("aria-valuenow", ctx._isIndeterminate() ? null : ctx.value)("mode", ctx.mode);
        \u0275\u0275classMap("mat-" + ctx.color);
        \u0275\u0275classProp("_mat-animation-noopable", ctx._isNoopAnimation)("mdc-linear-progress--animation-ready", !ctx._isNoopAnimation)("mdc-linear-progress--indeterminate", ctx._isIndeterminate());
      }
    },
    inputs: {
      color: "color",
      value: [2, "value", "value", numberAttribute],
      bufferValue: [2, "bufferValue", "bufferValue", numberAttribute],
      mode: "mode"
    },
    outputs: {
      animationEnd: "animationEnd"
    },
    exportAs: ["matProgressBar"],
    decls: 7,
    vars: 5,
    consts: [["aria-hidden", "true", 1, "mdc-linear-progress__buffer"], [1, "mdc-linear-progress__buffer-bar"], [1, "mdc-linear-progress__buffer-dots"], ["aria-hidden", "true", 1, "mdc-linear-progress__bar", "mdc-linear-progress__primary-bar"], [1, "mdc-linear-progress__bar-inner"], ["aria-hidden", "true", 1, "mdc-linear-progress__bar", "mdc-linear-progress__secondary-bar"]],
    template: function MatProgressBar_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0);
        \u0275\u0275element(1, "div", 1);
        \u0275\u0275template(2, MatProgressBar_Conditional_2_Template, 1, 0, "div", 2);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(3, "div", 3);
        \u0275\u0275element(4, "span", 4);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(5, "div", 5);
        \u0275\u0275element(6, "span", 4);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance();
        \u0275\u0275styleProp("flex-basis", ctx._getBufferBarFlexBasis());
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.mode === "buffer" ? 2 : -1);
        \u0275\u0275advance();
        \u0275\u0275styleProp("transform", ctx._getPrimaryBarTransform());
      }
    },
    styles: [`.mat-mdc-progress-bar{display:block;text-align:start}.mat-mdc-progress-bar[mode=query]{transform:scaleX(-1)}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-dots,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__secondary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__bar-inner.mdc-linear-progress__bar-inner{animation:none}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-bar{transition:transform 1ms}.mdc-linear-progress{position:relative;width:100%;transform:translateZ(0);outline:1px solid rgba(0,0,0,0);overflow-x:hidden;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);height:max(var(--mdc-linear-progress-track-height, 4px),var(--mdc-linear-progress-active-indicator-height, 4px))}@media(forced-colors: active){.mdc-linear-progress{outline-color:CanvasText}}.mdc-linear-progress__bar{position:absolute;top:0;bottom:0;margin:auto 0;width:100%;animation:none;transform-origin:top left;transition:transform 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);height:var(--mdc-linear-progress-active-indicator-height, 4px)}.mdc-linear-progress--indeterminate .mdc-linear-progress__bar{transition:none}[dir=rtl] .mdc-linear-progress__bar{right:0;transform-origin:center right}.mdc-linear-progress__bar-inner{display:inline-block;position:absolute;width:100%;animation:none;border-top-style:solid;border-color:var(--mdc-linear-progress-active-indicator-color, var(--mat-sys-primary));border-top-width:var(--mdc-linear-progress-active-indicator-height, 4px)}.mdc-linear-progress__buffer{display:flex;position:absolute;top:0;bottom:0;margin:auto 0;width:100%;overflow:hidden;height:var(--mdc-linear-progress-track-height, 4px);border-radius:var(--mdc-linear-progress-track-shape, var(--mat-sys-corner-none))}.mdc-linear-progress__buffer-dots{-webkit-mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");background-repeat:repeat-x;flex:auto;transform:rotate(180deg);animation:mdc-linear-progress-buffering 250ms infinite linear;background-color:var(--mdc-linear-progress-track-color, var(--mat-sys-surface-variant))}@media(forced-colors: active){.mdc-linear-progress__buffer-dots{background-color:ButtonBorder}}[dir=rtl] .mdc-linear-progress__buffer-dots{animation:mdc-linear-progress-buffering-reverse 250ms infinite linear;transform:rotate(0)}.mdc-linear-progress__buffer-bar{flex:0 1 100%;transition:flex-basis 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);background-color:var(--mdc-linear-progress-track-color, var(--mat-sys-surface-variant))}.mdc-linear-progress__primary-bar{transform:scaleX(0)}.mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{left:-145.166611%}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation:mdc-linear-progress-primary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-primary-indeterminate-scale 2s infinite linear}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation-name:mdc-linear-progress-primary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{right:-145.166611%;left:auto}.mdc-linear-progress__secondary-bar{display:none}.mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{left:-54.888891%;display:block}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation:mdc-linear-progress-secondary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-secondary-indeterminate-scale 2s infinite linear}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation-name:mdc-linear-progress-secondary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{right:-54.888891%;left:auto}@keyframes mdc-linear-progress-buffering{from{transform:rotate(180deg) translateX(calc(var(--mdc-linear-progress-track-height, 4px) * -2.5))}}@keyframes mdc-linear-progress-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mdc-linear-progress-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mdc-linear-progress-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-primary-indeterminate-translate-reverse{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(-83.67142%)}100%{transform:translateX(-200.611057%)}}@keyframes mdc-linear-progress-secondary-indeterminate-translate-reverse{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(-37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(-84.386165%)}100%{transform:translateX(-160.277782%)}}@keyframes mdc-linear-progress-buffering-reverse{from{transform:translateX(-10px)}}`],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatProgressBar, [{
    type: Component,
    args: [{
      selector: "mat-progress-bar",
      exportAs: "matProgressBar",
      host: {
        "role": "progressbar",
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        // set tab index to -1 so screen readers will read the aria-label
        // Note: there is a known issue with JAWS that does not read progressbar aria labels on FireFox
        "tabindex": "-1",
        "[attr.aria-valuenow]": "_isIndeterminate() ? null : value",
        "[attr.mode]": "mode",
        "class": "mat-mdc-progress-bar mdc-linear-progress",
        "[class]": '"mat-" + color',
        "[class._mat-animation-noopable]": "_isNoopAnimation",
        "[class.mdc-linear-progress--animation-ready]": "!_isNoopAnimation",
        "[class.mdc-linear-progress--indeterminate]": "_isIndeterminate()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      template: `<!--
  All children need to be hidden for screen readers in order to support ChromeVox.
  More context in the issue: https://github.com/angular/components/issues/22165.
-->
<div class="mdc-linear-progress__buffer" aria-hidden="true">
  <div
    class="mdc-linear-progress__buffer-bar"
    [style.flex-basis]="_getBufferBarFlexBasis()"></div>
  <!-- Remove the dots outside of buffer mode since they can cause CSP issues (see #28938) -->
  @if (mode === 'buffer') {
    <div class="mdc-linear-progress__buffer-dots"></div>
  }
</div>
<div
  class="mdc-linear-progress__bar mdc-linear-progress__primary-bar"
  aria-hidden="true"
  [style.transform]="_getPrimaryBarTransform()">
  <span class="mdc-linear-progress__bar-inner"></span>
</div>
<div class="mdc-linear-progress__bar mdc-linear-progress__secondary-bar" aria-hidden="true">
  <span class="mdc-linear-progress__bar-inner"></span>
</div>
`,
      styles: [`.mat-mdc-progress-bar{display:block;text-align:start}.mat-mdc-progress-bar[mode=query]{transform:scaleX(-1)}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-dots,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__secondary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__bar-inner.mdc-linear-progress__bar-inner{animation:none}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-bar{transition:transform 1ms}.mdc-linear-progress{position:relative;width:100%;transform:translateZ(0);outline:1px solid rgba(0,0,0,0);overflow-x:hidden;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);height:max(var(--mdc-linear-progress-track-height, 4px),var(--mdc-linear-progress-active-indicator-height, 4px))}@media(forced-colors: active){.mdc-linear-progress{outline-color:CanvasText}}.mdc-linear-progress__bar{position:absolute;top:0;bottom:0;margin:auto 0;width:100%;animation:none;transform-origin:top left;transition:transform 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);height:var(--mdc-linear-progress-active-indicator-height, 4px)}.mdc-linear-progress--indeterminate .mdc-linear-progress__bar{transition:none}[dir=rtl] .mdc-linear-progress__bar{right:0;transform-origin:center right}.mdc-linear-progress__bar-inner{display:inline-block;position:absolute;width:100%;animation:none;border-top-style:solid;border-color:var(--mdc-linear-progress-active-indicator-color, var(--mat-sys-primary));border-top-width:var(--mdc-linear-progress-active-indicator-height, 4px)}.mdc-linear-progress__buffer{display:flex;position:absolute;top:0;bottom:0;margin:auto 0;width:100%;overflow:hidden;height:var(--mdc-linear-progress-track-height, 4px);border-radius:var(--mdc-linear-progress-track-shape, var(--mat-sys-corner-none))}.mdc-linear-progress__buffer-dots{-webkit-mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");background-repeat:repeat-x;flex:auto;transform:rotate(180deg);animation:mdc-linear-progress-buffering 250ms infinite linear;background-color:var(--mdc-linear-progress-track-color, var(--mat-sys-surface-variant))}@media(forced-colors: active){.mdc-linear-progress__buffer-dots{background-color:ButtonBorder}}[dir=rtl] .mdc-linear-progress__buffer-dots{animation:mdc-linear-progress-buffering-reverse 250ms infinite linear;transform:rotate(0)}.mdc-linear-progress__buffer-bar{flex:0 1 100%;transition:flex-basis 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);background-color:var(--mdc-linear-progress-track-color, var(--mat-sys-surface-variant))}.mdc-linear-progress__primary-bar{transform:scaleX(0)}.mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{left:-145.166611%}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation:mdc-linear-progress-primary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-primary-indeterminate-scale 2s infinite linear}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation-name:mdc-linear-progress-primary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{right:-145.166611%;left:auto}.mdc-linear-progress__secondary-bar{display:none}.mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{left:-54.888891%;display:block}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation:mdc-linear-progress-secondary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-secondary-indeterminate-scale 2s infinite linear}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation-name:mdc-linear-progress-secondary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress.mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{right:-54.888891%;left:auto}@keyframes mdc-linear-progress-buffering{from{transform:rotate(180deg) translateX(calc(var(--mdc-linear-progress-track-height, 4px) * -2.5))}}@keyframes mdc-linear-progress-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mdc-linear-progress-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mdc-linear-progress-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-primary-indeterminate-translate-reverse{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(-83.67142%)}100%{transform:translateX(-200.611057%)}}@keyframes mdc-linear-progress-secondary-indeterminate-translate-reverse{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(-37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(-84.386165%)}100%{transform:translateX(-160.277782%)}}@keyframes mdc-linear-progress-buffering-reverse{from{transform:translateX(-10px)}}`]
    }]
  }], () => [], {
    color: [{
      type: Input
    }],
    value: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    bufferValue: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    animationEnd: [{
      type: Output
    }],
    mode: [{
      type: Input
    }]
  });
})();
function clamp(v, min = 0, max = 100) {
  return Math.max(min, Math.min(max, v));
}
var MatProgressBarModule = class _MatProgressBarModule {
  static \u0275fac = function MatProgressBarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatProgressBarModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatProgressBarModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [MatProgressBar],
      exports: [MatProgressBar, MatCommonModule]
    }]
  }], null, null);
})();

// src/app/shared/templates/navbar/navbar.component.ts
function NavbarComponent_a_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 38);
    \u0275\u0275listener("click", function NavbarComponent_a_10_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleSideBar());
    });
    \u0275\u0275element(1, "i", 39);
    \u0275\u0275elementEnd();
  }
}
function NavbarComponent_a_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 38);
    \u0275\u0275listener("click", function NavbarComponent_a_11_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleSideBar());
    });
    \u0275\u0275element(1, "i", 40);
    \u0275\u0275elementEnd();
  }
}
function NavbarComponent_app_input_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-input", 41);
    \u0275\u0275listener("select", function NavbarComponent_app_input_12_Template_app_input_select_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.selectUser($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("settings", ctx_r1.userSelectSettings);
  }
}
function NavbarComponent_button_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 42);
    \u0275\u0275listener("click", function NavbarComponent_button_14_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onReturnToMyUserClick());
    });
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "translate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "Return to my user"), " ");
  }
}
function NavbarComponent_mat_progress_bar_57_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 43);
  }
}
var NavbarComponent = class _NavbarComponent {
  sideBarService;
  router;
  idService;
  employeeService;
  supabaseAuthService;
  employeeRepository;
  spinner;
  storageService;
  loaderService;
  currentEmployee;
  users = [];
  userSelectSettings = {
    type: "autocomplete",
    placeholder: "Login as...",
    labelClass: "app-label",
    appearance: "outline",
    inputClass: "w-100",
    formFieldClass: "w-100 small",
    options: new Observable()
  };
  showSubMenusTab = true;
  multilevel = [false, false, false];
  openMenuItem = null;
  openSubmenuOneItem = null;
  base = "dashboard";
  page = "";
  last = "";
  routes = routes;
  baricon = false;
  constructor(sideBarService, router, idService, employeeService, supabaseAuthService, employeeRepository, spinner, storageService, loaderService) {
    this.sideBarService = sideBarService;
    this.router = router;
    this.idService = idService;
    this.employeeService = employeeService;
    this.supabaseAuthService = supabaseAuthService;
    this.employeeRepository = employeeRepository;
    this.spinner = spinner;
    this.storageService = storageService;
    this.loaderService = loaderService;
    router.events.subscribe((event) => {
      if (event instanceof NavigationEnd) {
        const splitVal = event.url.split("/");
        this.base = splitVal[1];
        this.page = splitVal[2];
        if (this.base === "components" || this.page === "tasks" || this.page === "email") {
          this.baricon = false;
          localStorage.setItem("baricon", "false");
        } else {
          this.baricon = true;
          localStorage.setItem("baricon", "true");
        }
      }
    });
    if (localStorage.getItem("baricon") == "true") {
      this.baricon = true;
    } else {
      this.baricon = false;
    }
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      if (!employee) {
        return;
      }
      this.currentEmployee = employee;
      this.initAllUsers();
    });
  }
  toggleSideBar() {
    this.sideBarService.toggleSidebar();
  }
  elem = document.documentElement;
  fullscreen() {
    if (!document.fullscreenElement) {
      this.elem.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }
  navigateToMyProfile() {
    this.idService.setId("profile", this.supabaseAuthService.getCurrentEmployee()?.getEmployeeId() ? this.supabaseAuthService.getCurrentEmployee()?.getEmployeeId() : this.currentEmployee?.getEmployeeId());
    this.router.navigate(["/profile"]);
  }
  logout(popup) {
    this.idService.clearAllSubjects();
    window.location.href = "https://caesarealtd.sharepoint.com/sites/Home";
  }
  selectUser(event) {
    this.spinner.show();
    this.loaderService.show();
    this.employeeRepository.getById(event).then((employee) => {
      if (employee) {
        this.supabaseAuthService.setAdditionalEmployee(employee);
        this.idService.setId("profile", employee.id);
        this.idService.setId("profile-edit", employee.id);
      }
      this.spinner.hide();
      this.loaderService.hide();
    });
  }
  onReturnToMyUserClick() {
    this.supabaseAuthService.setAdditionalEmployee(null);
  }
  initAllUsers() {
    this.employeeRepository.getAllSimple().then((result) => {
      this.userSelectSettings.options = of(result.map((x) => {
        return {
          label: `${x.display_name} (${x.role})`,
          value: x.id
        };
      }));
    });
  }
  static \u0275fac = function NavbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavbarComponent)(\u0275\u0275directiveInject(SideBarService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(EmployeeRepository), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(LoaderService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NavbarComponent, selectors: [["app-navbar"]], decls: 59, vars: 31, consts: [[1, "header"], [1, "main-header"], ["id", "mobile_btn", "tabindex", "0", "href", "javascript:void(0);", 1, "mobile_btn", 3, "click"], [1, "bar-icon"], [1, "header-user"], [1, "nav", "user-menu"], ["id", "header-search", 1, "d-flex", "col-9"], ["id", "toggle_btn", "href", "javascript:void(0);", "class", "btn btn-menubar me-1", 3, "click", 4, "ngIf"], ["class", "col-2", "id", "users", 3, "settings", "select", 4, "ngIf"], ["class", "col-2", "mat-raised-button", "", "color", "primary", 3, "click", 4, "ngIf"], [1, "d-flex", "justify-content-end", "col-3"], [1, "me-1"], ["href", "javascript:void(0);", 1, "btn", "btn-menubar", "btnFullscreen", 3, "click"], [1, "ti", "ti-maximize"], [1, "dropdown", "profile-dropdown"], ["href", "javascript:void(0);", "data-bs-toggle", "dropdown", 1, "dropdown-toggle", "d-flex", "align-items-center"], [1, "avatar", "avatar-sm", "online"], ["alt", "Img", 1, "img-fluid", "rounded-circle", 3, "src"], [1, "dropdown-menu", "shadow-none", "dropdown-menu-end"], [1, "card", "mb-0"], [1, "card-header"], [1, "d-flex", "align-items-center"], [1, "avatar", "avatar-lg", "me-2", "avatar-rounded"], ["alt", "img", 3, "src"], [1, "mb-0"], [1, "fs-12", "fw-medium", "mb-0"], [1, "card-body"], [1, "dropdown-item", "d-inline-flex", "align-items-center", "p-0", "py-2", 3, "click"], [1, "ti", "ti-user-circle", "me-1"], [1, "card-footer"], [1, "ti", "ti-login", "me-2"], [1, "dropdown", "mobile-user-menu"], ["href", "javascript:void(0);", "data-bs-toggle", "dropdown", "aria-expanded", "false", 1, "nav-link", "dropdown-toggle"], [1, "fa", "fa-ellipsis-v"], [1, "dropdown-menu", "dropdown-menu-end"], ["routerLink", "/employee-profile/about", 1, "dropdown-item"], [1, "dropdown-item", 3, "click"], ["color", "primary", "mode", "indeterminate", 4, "ngIf"], ["id", "toggle_btn", "href", "javascript:void(0);", 1, "btn", "btn-menubar", "me-1", 3, "click"], [1, "ti", "ti-arrow-bar-to-left"], [1, "ti", "ti-arrow-bar-to-right"], ["id", "users", 1, "col-2", 3, "select", "settings"], ["mat-raised-button", "", "color", "primary", 1, "col-2", 3, "click"], ["color", "primary", "mode", "indeterminate"]], template: function NavbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "header", 0)(1, "div", 1)(2, "a", 2);
      \u0275\u0275listener("click", function NavbarComponent_Template_a_click_2_listener() {
        return ctx.toggleSideBar();
      });
      \u0275\u0275elementStart(3, "span", 3);
      \u0275\u0275element(4, "span")(5, "span")(6, "span");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(7, "div", 4)(8, "div", 5)(9, "div", 6);
      \u0275\u0275template(10, NavbarComponent_a_10_Template, 2, 0, "a", 7)(11, NavbarComponent_a_11_Template, 2, 0, "a", 7)(12, NavbarComponent_app_input_12_Template, 1, 1, "app-input", 8);
      \u0275\u0275pipe(13, "async");
      \u0275\u0275template(14, NavbarComponent_button_14_Template, 3, 3, "button", 9);
      \u0275\u0275pipe(15, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(16, "div", 10)(17, "div", 11)(18, "a", 12);
      \u0275\u0275listener("click", function NavbarComponent_Template_a_click_18_listener() {
        return ctx.fullscreen();
      });
      \u0275\u0275element(19, "i", 13);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(20, "div", 14)(21, "a", 15)(22, "span", 16);
      \u0275\u0275element(23, "img", 17);
      \u0275\u0275pipe(24, "async");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(25, "div", 18)(26, "div", 19)(27, "div", 20)(28, "div", 21)(29, "span", 22);
      \u0275\u0275element(30, "img", 23);
      \u0275\u0275pipe(31, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(32, "div")(33, "h5", 24);
      \u0275\u0275text(34);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(35, "p", 25);
      \u0275\u0275text(36);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(37, "div", 26)(38, "a", 27);
      \u0275\u0275listener("click", function NavbarComponent_Template_a_click_38_listener() {
        return ctx.navigateToMyProfile();
      });
      \u0275\u0275element(39, "i", 28);
      \u0275\u0275text(40);
      \u0275\u0275pipe(41, "translate");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(42, "div", 29)(43, "a", 27);
      \u0275\u0275listener("click", function NavbarComponent_Template_a_click_43_listener() {
        return ctx.logout();
      });
      \u0275\u0275element(44, "i", 30);
      \u0275\u0275text(45);
      \u0275\u0275pipe(46, "translate");
      \u0275\u0275elementEnd()()()()()()()();
      \u0275\u0275elementStart(47, "div", 31)(48, "a", 32);
      \u0275\u0275element(49, "i", 33);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(50, "div", 34)(51, "a", 35);
      \u0275\u0275text(52);
      \u0275\u0275pipe(53, "translate");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(54, "a", 36);
      \u0275\u0275listener("click", function NavbarComponent_Template_a_click_54_listener() {
        return ctx.logout(true);
      });
      \u0275\u0275text(55);
      \u0275\u0275pipe(56, "translate");
      \u0275\u0275elementEnd()()()();
      \u0275\u0275template(57, NavbarComponent_mat_progress_bar_57_Template, 1, 0, "mat-progress-bar", 37);
      \u0275\u0275pipe(58, "async");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(10);
      \u0275\u0275property("ngIf", !ctx.sideBarService.isOpened && !ctx.sideBarService.isHovered);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.sideBarService.isOpened || ctx.sideBarService.isHovered);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.currentEmployee && ctx.currentEmployee.isAdmin() && \u0275\u0275pipeBind1(13, 13, ctx.supabaseAuthService.getAdditionalEmployee$()) == null);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(15, 15, ctx.supabaseAuthService.getAdditionalEmployee$()) != null);
      \u0275\u0275advance(9);
      \u0275\u0275property("src", \u0275\u0275pipeBind1(24, 17, ctx.currentEmployee == null ? null : ctx.currentEmployee.avatar_src), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(7);
      \u0275\u0275property("src", \u0275\u0275pipeBind1(31, 19, ctx.currentEmployee == null ? null : ctx.currentEmployee.avatar_src), \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate(ctx.currentEmployee == null ? null : ctx.currentEmployee.getEmployeeName());
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.currentEmployee == null ? null : ctx.currentEmployee.email);
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1("", \u0275\u0275pipeBind1(41, 21, "My Profile"), " ");
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(46, 23, "Go to portal"));
      \u0275\u0275advance(7);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(53, 25, "My Profile"));
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(56, 27, "Logout"));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(58, 29, ctx.loaderService.isLoading$));
    }
  }, dependencies: [
    AppInputComponent,
    TranslateModule,
    TranslatePipe,
    CommonModule,
    NgIf,
    AsyncPipe,
    RouterLink,
    MatButtonModule,
    MatButton,
    MatProgressBarModule,
    MatProgressBar
  ], styles: ["\n\n.site-header[_ngcontent-%COMP%] {\n  padding: 20px 0;\n}\n/*# sourceMappingURL=navbar.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NavbarComponent, { className: "NavbarComponent", filePath: "src/app/shared/templates/navbar/navbar.component.ts", lineNumber: 36 });
})();

// node_modules/@angular/core/fesm2022/rxjs-interop.mjs
function toSignal(source, options) {
  ngDevMode && assertNotInReactiveContext(toSignal, "Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");
  const requiresCleanup = !options?.manualCleanup;
  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;
  const equal = makeToSignalEqual(options?.equal);
  let state;
  if (options?.requireSync) {
    state = signal({
      kind: 0
      /* StateKind.NoValue */
    }, {
      equal
    });
  } else {
    state = signal({
      kind: 1,
      value: options?.initialValue
    }, {
      equal
    });
  }
  const sub = source.subscribe({
    next: (value) => state.set({
      kind: 1,
      value
    }),
    error: (error) => {
      if (options?.rejectErrors) {
        throw error;
      }
      state.set({
        kind: 2,
        error
      });
    }
    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
    // "complete".
  });
  if (options?.requireSync && state().kind === 0) {
    throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
  }
  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
  return computed(() => {
    const current = state();
    switch (current.kind) {
      case 1:
        return current.value;
      case 2:
        throw current.error;
      case 0:
        throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
    }
  }, {
    equal: options?.equal
  });
}
function makeToSignalEqual(userEquality = Object.is) {
  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);
}

// node_modules/ngx-scrollbar/fesm2022/ngx-scrollbar-smooth-scroll.mjs
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function LinearEasing(x) {
  return x;
}
function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (let i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function BezierEasing(x) {
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
}
var defaultSmoothScrollOptions = {
  duration: 468,
  easing: {
    x1: 0.42,
    y1: 0,
    x2: 0.58,
    y2: 1
  }
};
var SMOOTH_SCROLL_OPTIONS = new InjectionToken("SMOOTH_SCROLL_OPTIONS", {
  providedIn: "root",
  factory: () => defaultSmoothScrollOptions
});
var SmoothScrollManager = class _SmoothScrollManager {
  constructor() {
    this.document = inject(DOCUMENT);
    this.zone = inject(NgZone);
    this._defaultOptions = inject(SMOOTH_SCROLL_OPTIONS);
    this.onGoingScrolls = /* @__PURE__ */ new Map();
  }
  /**
   * Timing method
   */
  get now() {
    return this.document.defaultView.performance?.now?.bind(this.document.defaultView.performance) || Date.now;
  }
  /**
   * changes scroll position inside an element
   */
  scrollElement(el, x, y) {
    el.scrollLeft = x;
    el.scrollTop = y;
  }
  /**
   * Handles a given parameter of type HTMLElement, ElementRef or selector
   */
  getElement(el, parent) {
    if (typeof el === "string") {
      return (parent || this.document).querySelector(el);
    }
    return coerceElement(el);
  }
  /**
   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
   */
  getScrollDestroyerRef(el) {
    if (this.onGoingScrolls.has(el)) {
      this.onGoingScrolls.get(el).next();
    }
    return this.onGoingScrolls.set(el, new Subject()).get(el);
  }
  /**
   * A function called recursively that, given a context, steps through scrolling
   */
  step(context) {
    return new Observable((subscriber) => {
      let elapsed = (this.now() - context.startTime) / context.duration;
      elapsed = elapsed > 1 ? 1 : elapsed;
      const value = context.easing(elapsed);
      context.currentX = context.startX + (context.x - context.startX) * value;
      context.currentY = context.startY + (context.y - context.startY) * value;
      this.scrollElement(context.scrollable, context.currentX, context.currentY);
      requestAnimationFrame(() => {
        subscriber.next();
        subscriber.complete();
      });
    });
  }
  /**
   * Checks if smooth scroll has reached, cleans up the smooth scroll stream
   */
  isReached(context, destroyed) {
    if (context.currentX === context.x && context.currentY === context.y) {
      destroyed.next();
      return true;
    }
    return false;
  }
  /**
   * Scroll recursively until coordinates are reached
   * @param context
   * @param destroyed
   */
  scrolling(context, destroyed) {
    return this.step(context).pipe(
      // Continue while target coordinates hasn't reached yet
      takeWhile(() => !this.isReached(context, destroyed)),
      switchMap(() => this.scrolling(context, destroyed))
    );
  }
  /**
   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
   */
  onScrollReached(el, resolve, destroyed) {
    destroyed.complete();
    this.onGoingScrolls.delete(el);
    this.zone.run(() => resolve());
  }
  /**
   * Terminates an ongoing smooth scroll
   */
  interrupted(el, destroyed) {
    return merge(fromEvent(el, "wheel", {
      passive: true,
      capture: true
    }), fromEvent(el, "touchmove", {
      passive: true,
      capture: true
    }), destroyed).pipe(take(1));
  }
  applyScrollToOptions(el, options) {
    if (!options.duration) {
      this.scrollElement(el, options.left, options.top);
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.zone.runOutsideAngular(() => {
        const destroyed = this.getScrollDestroyerRef(el);
        const context = {
          scrollable: el,
          startTime: this.now(),
          startX: el.scrollLeft,
          startY: el.scrollTop,
          x: options.left == null ? el.scrollLeft : ~~options.left,
          y: options.top == null ? el.scrollTop : ~~options.top,
          duration: options.duration,
          easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        this.scrolling(context, destroyed).pipe(
          // Continue until interrupted by another scroll (new smooth scroll / wheel / touchmove)
          takeUntil(this.interrupted(el, destroyed)),
          // Once finished, clean up the destroyer stream and resolve the promise
          finalize(() => this.onScrollReached(el, resolve, destroyed))
        ).subscribe();
      });
    });
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param scrollable element
   * @param customOptions specified the offsets to scroll to.
   */
  scrollTo(scrollable, customOptions) {
    const el = this.getElement(scrollable);
    const isRtl = getComputedStyle(el).direction === "rtl";
    const options = __spreadValues(__spreadValues(__spreadValues({}, this._defaultOptions), customOptions), {
      // Rewrite start & end offsets as right or left offsets.
      left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,
      right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right
    });
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      options.left = options.right ? -options.right : options.right;
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    return this.applyScrollToOptions(el, options);
  }
  /**
   * Scroll to element by reference or selector
   */
  scrollToElement(scrollable, target, customOptions = {}) {
    const scrollableEl = this.getElement(scrollable);
    const targetEl = this.getElement(target, scrollableEl);
    const isRtl = getComputedStyle(scrollableEl).direction === "rtl";
    if (!targetEl || !scrollableEl) {
      return Promise.resolve();
    }
    const scrollableRect = scrollableEl.getBoundingClientRect();
    const targetRect = targetEl.getBoundingClientRect();
    const options = __spreadValues(__spreadValues(__spreadValues({}, this._defaultOptions), customOptions), {
      top: targetRect.top + scrollableEl.scrollTop - scrollableRect.top + (customOptions.top || 0),
      // Rewrite start & end offsets as right or left offsets.
      left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,
      right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right
    });
    if (customOptions.center) {
      const containerCenterX = scrollableRect.left + scrollableRect.width / 2;
      const containerCenterY = scrollableRect.top + scrollableRect.height / 2;
      const targetCenterX = targetRect.left + targetRect.width / 2;
      const targetCenterY = targetRect.top + targetRect.height / 2;
      options.left = targetCenterX - containerCenterX + scrollableEl.scrollLeft;
      options.top = targetCenterY - containerCenterY + scrollableEl.scrollTop;
      return this.applyScrollToOptions(scrollableEl, options);
    }
    if (options.bottom != null) {
      const bottomEdge = scrollableRect.height - targetRect.height;
      options.top = targetRect.top + scrollableEl.scrollTop - scrollableRect.top - bottomEdge + (customOptions.bottom || 0);
    }
    if (isRtl) {
      options.left = targetRect.left - scrollableRect.left + scrollableEl.scrollLeft + (options.left || 0);
      if (options.right != null) {
        options.left = targetRect.right - scrollableRect.left + scrollableEl.scrollLeft - scrollableRect.width + (options.right || 0);
      }
    } else {
      options.left = targetRect.left - scrollableRect.left + scrollableEl.scrollLeft + (options.left || 0);
      if (options.right != null) {
        options.left = targetRect.right - scrollableRect.left + scrollableEl.scrollLeft - scrollableRect.width + (options.right || 0);
      }
    }
    const computedOptions = {
      top: options.top,
      left: options.left,
      easing: options.easing,
      duration: options.duration
    };
    return this.applyScrollToOptions(scrollableEl, computedOptions);
  }
  static {
    this.\u0275fac = function SmoothScrollManager_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SmoothScrollManager)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _SmoothScrollManager,
      factory: _SmoothScrollManager.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmoothScrollManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var SmoothScroll = class _SmoothScroll {
  constructor() {
    this.smoothScroll = inject(SmoothScrollManager);
    this.element = inject(ElementRef);
  }
  scrollTo(options) {
    return this.smoothScroll.scrollTo(this.element, options);
  }
  scrollToElement(target, options) {
    return this.smoothScroll.scrollToElement(this.element, target, options);
  }
  static {
    this.\u0275fac = function SmoothScroll_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SmoothScroll)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _SmoothScroll,
      selectors: [["", "smoothScroll", ""]],
      exportAs: ["smoothScroll"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmoothScroll, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[smoothScroll]",
      exportAs: "smoothScroll"
    }]
  }], null, null);
})();

// node_modules/ngx-scrollbar/fesm2022/ngx-scrollbar.mjs
var _c03 = ["scrollbarButton", ""];
function ScrollbarY_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "button", 4)(1, "button", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("ng-scrollbar-button ", ctx_r0.cmp.buttonClass(), "");
    \u0275\u0275advance();
    \u0275\u0275classMapInterpolate1("ng-scrollbar-button ", ctx_r0.cmp.buttonClass(), "");
  }
}
function ScrollbarX_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "button", 4)(1, "button", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("ng-scrollbar-button ", ctx_r0.cmp.buttonClass(), "");
    \u0275\u0275advance();
    \u0275\u0275classMapInterpolate1("ng-scrollbar-button ", ctx_r0.cmp.buttonClass(), "");
  }
}
var _c1 = "[_nghost-%COMP%]{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky[_ngcontent-%COMP%]{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition);pointer-events:var(--_scrollbar-pointer-events)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);transition:var(--INTERNAL-scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;background-color:var(--INTERNAL-scrollbar-track-color);border-radius:var(--INTERNAL-scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb[_ngcontent-%COMP%]{box-sizing:border-box;position:absolute;transition:var(--INTERNAL-scrollbar-thumb-transition);border-radius:var(--INTERNAL-scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:_ngcontent-%COMP%_scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes _ngcontent-%COMP%_scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}";
function Scrollbars_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "scrollbar-y");
  }
}
function Scrollbars_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "scrollbar-x");
  }
}
var _c2 = ["contentWrapper"];
var _c3 = ["*"];
var _c4 = ["externalViewport", ""];
var _c5 = "[_nghost-%COMP%]{display:block;position:relative;max-height:100%;max-width:100%;--INTERNAL-scrollbar-border-radius: var(--scrollbar-border-radius, 0px);--INTERNAL-scrollbar-thickness: var(--scrollbar-thickness, 5);--INTERNAL-scrollbar-offset: var(--scrollbar-offset, 0);--INTERNAL-scrollbar-track-wrapper-transition: var(--scrollbar-track-wrapper-transition, width 60ms linear, height 60ms linear);--INTERNAL-scrollbar-track-color: var(--scrollbar-track-color, transparent);--INTERNAL-scrollbar-thumb-color: var(--scrollbar-thumb-color, rgb(0 0 0 / 20%));--INTERNAL-scrollbar-thumb-hover-color: var(--scrollbar-thumb-hover-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-hover-thickness: var(--scrollbar-hover-thickness, var(--INTERNAL-scrollbar-thickness));--INTERNAL-scrollbar-thumb-transition: var(--scrollbar-thumb-transition, none);--INTERNAL-scrollbar-thumb-min-size: var(--scrollbar-thumb-min-size, 20);--INTERNAL-scrollbar-button-color: var(--scrollbar-button-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-button-hover-color: var(--scrollbar-button-hover-color, var(--INTERNAL-scrollbar-button-color));--INTERNAL-scrollbar-button-active-color: var(--scrollbar-button-active-color, var(--INTERNAL-scrollbar-button-hover-color));--INTERNAL-scrollbar-button-fill: var(--scrollbar-button-fill, white);--INTERNAL-scrollbar-button-hover-fill: var(--scrollbar-button-hover-fill, var(--INTERNAL-scrollbar-button-fill));--INTERNAL-scrollbar-button-active-fill: var(--scrollbar-button-active-fill, var(--INTERNAL-scrollbar-button-hover-fill));--INTERNAL-scrollbar-button-size: var(--scrollbar-button-size, 20px);--INTERNAL-scrollbar-hover-opacity-transition-enter-duration: var(--scrollbar-hover-opacity-transition-enter-duration, 0);--INTERNAL-scrollbar-hover-opacity-transition-leave-duration: var(--scrollbar-hover-opacity-transition-leave-duration, .4s);--INTERNAL-scrollbar-hover-opacity-transition-leave-delay: var(--scrollbar-hover-opacity-transition-leave-delay, 1s);--INTERNAL-scrollbar-overscroll-behavior: var(--scrollbar-overscroll-behavior, initial);--INTERNAL-scrollbar-mobile-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior, none);--_scrollbar-thickness: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--INTERNAL-scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--INTERNAL-scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_viewport-pointer-events: auto;--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-color);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}[_nghost-%COMP%]{--_spacer-width: var(--spacer-width);--_spacer-height: var(--spacer-height);--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}.ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior);pointer-events:var(--_viewport-pointer-events)}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}[appearance=native][_nghost-%COMP%]{--_spacer-width: calc(var(--spacer-width) + var(--_scrollbar-thickness));--_spacer-height: calc(var(--spacer-height) + var(--_scrollbar-thickness))}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-spacer[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-spacer{position:relative;width:calc(var(--_spacer-width) * 1px);height:calc(var(--_spacer-height) * 1px)}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{scrollbar-width:none!important}.ng-scroll-viewport[_nghost-%COMP%]::-webkit-scrollbar, .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport::-webkit-scrollbar{display:none!important}[position=invertX][_nghost-%COMP%], [position=invertAll][_nghost-%COMP%]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}[dir=ltr][_nghost-%COMP%]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=ltr][position=invertY][_nghost-%COMP%], [dir=ltr][position=invertAll][_nghost-%COMP%]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}[dir=rtl][_nghost-%COMP%]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=rtl][position=invertY][_nghost-%COMP%], [dir=rtl][position=invertAll][_nghost-%COMP%]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_scrollbar-thickness-margin: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}[horizontalUsed=true][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}[horizontalUsed=true][position=invertX][_nghost-%COMP%], [horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}[verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[appearance=native][verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][_nghost-%COMP%]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][position=invertX][_nghost-%COMP%], [appearance=native][horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}[visibility=hover][_nghost-%COMP%]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-leave-duration) var(--INTERNAL-scrollbar-hover-opacity-transition-leave-delay)}[visibility=hover][_nghost-%COMP%]:hover, [visibility=hover][_nghost-%COMP%]:active, [visibility=hover][_nghost-%COMP%]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-enter-duration)}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper, [_nghost-%COMP%]     .scroll-reached-trigger-element, [_nghost-%COMP%]     .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}[_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end], [_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}[_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom], [_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}[_nghost-%COMP%]     .scroll-reached-trigger-element{background:red}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[_ngcontent-%COMP%]{background:#00f}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{left:0;right:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{top:0;bottom:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%]{top:0;height:var(--dropped-offset-top)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{bottom:0;height:var(--dropped-offset-bottom)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%]{width:var(--dropped-offset-start)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{width:var(--dropped-offset-end)}[verticalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y}[horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}[orientation=vertical][_nghost-%COMP%]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}[orientation=horizontal][_nghost-%COMP%]{--_viewport-overflow: auto hidden}[disableInteraction=true][_nghost-%COMP%]{--_viewport-pointer-events: none;--_scrollbar-pointer-events: none}[isVerticallyScrollable=false][_nghost-%COMP%]{--_vertical-thumb-display: none}[isHorizontallyScrollable=false][_nghost-%COMP%]{--_horizontal-thumb-display: none}[dragging=x][_nghost-%COMP%], [dragging=y][_nghost-%COMP%]{--_viewport-user-select: none}[dragging=x][_nghost-%COMP%]{--_track-x-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}[dragging=y][_nghost-%COMP%]{--_track-y-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}[mobile=true][_nghost-%COMP%]{--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-mobile-overscroll-behavior)}";
var ScrollViewport = class _ScrollViewport {
  constructor() {
    this.nativeElement = inject(ElementRef).nativeElement;
  }
  static {
    this.\u0275fac = function ScrollViewport_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScrollViewport)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ScrollViewport,
      selectors: [["", "scrollViewport", ""]]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollViewport, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[scrollViewport]"
    }]
  }], null, null);
})();
function preventSelection(doc) {
  return tap(() => doc.onselectstart = () => false);
}
function enableSelection(doc) {
  return tap(() => doc.onselectstart = null);
}
function stopPropagation() {
  return tap((e) => {
    e.preventDefault();
    e.stopPropagation();
  });
}
function getThrottledStream(stream, duration) {
  return stream.pipe(throttleTime(duration || 0, null, {
    leading: false,
    trailing: true
  }));
}
var ViewportClasses;
(function(ViewportClasses2) {
  ViewportClasses2["Viewport"] = "ng-scroll-viewport";
  ViewportClasses2["Content"] = "ng-scroll-content";
  ViewportClasses2["Spacer"] = "ng-scroll-spacer";
})(ViewportClasses || (ViewportClasses = {}));
var ViewportAdapter = class _ViewportAdapter {
  constructor() {
    this.initialized = signal(false);
  }
  /** Viewport clientHeight */
  get offsetHeight() {
    return this.nativeElement.offsetHeight;
  }
  /** Viewport clientWidth */
  get offsetWidth() {
    return this.nativeElement.offsetWidth;
  }
  /** Viewport scrollTop */
  get scrollTop() {
    return this.nativeElement.scrollTop;
  }
  /** Viewport scrollLeft */
  get scrollLeft() {
    return this.nativeElement.scrollLeft;
  }
  /** Content height */
  get contentHeight() {
    return this.contentWrapperElement.offsetHeight;
  }
  /** Content width */
  get contentWidth() {
    return this.contentWrapperElement.offsetWidth;
  }
  /** The remaining vertical scrollable distance. */
  get scrollMaxX() {
    return this.contentWidth - this.offsetWidth;
  }
  /** The vertical remaining scrollable distance */
  get scrollMaxY() {
    return this.contentHeight - this.offsetHeight;
  }
  /**
   * Initialize viewport
   */
  init(viewportElement, contentElement, spacerElement) {
    viewportElement.classList.add(ViewportClasses.Viewport);
    this.nativeElement = viewportElement;
    contentElement.classList.add(ViewportClasses.Content);
    if (spacerElement) {
      spacerElement.classList.add(ViewportClasses.Spacer);
      this.contentWrapperElement = spacerElement;
    } else {
      this.contentWrapperElement = contentElement;
    }
    this.initialized.set(true);
  }
  reset() {
    this.nativeElement = null;
    this.contentWrapperElement = null;
    this.initialized.set(false);
  }
  /**
   * Scrolls the viewport vertically to the specified value.
   */
  scrollYTo(value) {
    this.nativeElement.scrollTop = value;
  }
  /**
   * Scrolls the viewport horizontally to the specified value.
   */
  scrollXTo(value) {
    this.nativeElement.scrollLeft = value;
  }
  static {
    this.\u0275fac = function ViewportAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ViewportAdapter)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ViewportAdapter,
      factory: _ViewportAdapter.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportAdapter, [{
    type: Injectable
  }], null, null);
})();
var NG_SCROLLBAR = new InjectionToken("NG_SCROLLBAR");
var defaultOptions = {
  trackClass: "",
  thumbClass: "",
  buttonClass: "",
  orientation: "auto",
  appearance: "native",
  visibility: "native",
  position: "native",
  trackScrollDuration: 50,
  sensorThrottleTime: 0,
  disableSensor: false,
  disableInteraction: false,
  buttons: false,
  hoverOffset: false
};
var defaultScrollTimelinePolyfill = "https://cdn.statically.io/gist/MurhafSousli/c852b6a672069396953f06ddd4b64620/raw/ef55db72e2abb7bc002ed79f4ad4cf408bfdb72f/scroll-timeline-lite.js";
var ScrollbarUpdateReason;
(function(ScrollbarUpdateReason2) {
  ScrollbarUpdateReason2["AfterInit"] = "AfterInit";
  ScrollbarUpdateReason2["Resized"] = "ResizeObserver";
})(ScrollbarUpdateReason || (ScrollbarUpdateReason = {}));
var NG_SCROLLBAR_OPTIONS = new InjectionToken("NG_SCROLLBAR_OPTIONS", {
  providedIn: "root",
  factory: () => defaultOptions
});
var NG_SCROLLBAR_POLYFILL = new InjectionToken("NG_SCROLLBAR_POLYFILL", {
  providedIn: "root",
  factory: () => defaultScrollTimelinePolyfill
});
function filterResizeEntries(entries, target) {
  return entries.filter((entry) => entry.target === target)[0]?.contentRect;
}
var NgScrollbarCore = class _NgScrollbarCore {
  constructor() {
    this.options = inject(NG_SCROLLBAR_OPTIONS);
    this.sharedResizeObserver = inject(SharedResizeObserver);
    this.zone = inject(NgZone);
    this.platform = inject(Platform);
    this.isMobile = this.platform.IOS || this.platform.ANDROID;
    this.dir = inject(Directionality);
    this.smoothScroll = inject(SmoothScrollManager);
    this.viewport = inject(ViewportAdapter, {
      self: true
    });
    this.nativeElement = inject(ElementRef).nativeElement;
    this.direction = toSignal(this.dir.change, {
      initialValue: this.dir.value
    });
    this.dragging = signal("none");
    this.orientation = input(this.options.orientation);
    this.visibility = input(this.options.visibility);
    this.buttons = input(this.options.buttons, {
      transform: booleanAttribute
    });
    this.disableInteraction = input(this.options.disableInteraction, {
      transform: booleanAttribute
    });
    this.disableSensor = input(this.options.disableSensor, {
      transform: booleanAttribute
    });
    this.sensorThrottleTime = input(this.options.sensorThrottleTime, {
      transform: numberAttribute
    });
    this.hoverOffset = input(this.options.hoverOffset, {
      transform: booleanAttribute
    });
    this.viewportDimension = signal({
      width: 0,
      height: 0
    });
    this.contentDimension = signal({
      width: 0,
      height: 0
    });
    this.state = computed(() => {
      let verticalUsed = false;
      let horizontalUsed = false;
      let isVerticallyScrollable = false;
      let isHorizontallyScrollable = false;
      const orientation = this.orientation();
      const visibility = this.visibility();
      const viewportDimensions = this.viewportDimension();
      const contentDimensions = this.contentDimension();
      if (orientation === "auto" || orientation === "vertical") {
        isVerticallyScrollable = contentDimensions.height > viewportDimensions.height;
        verticalUsed = visibility === "visible" || isVerticallyScrollable;
      }
      if (orientation === "auto" || orientation === "horizontal") {
        isHorizontallyScrollable = contentDimensions.width > viewportDimensions.width;
        horizontalUsed = visibility === "visible" || isHorizontallyScrollable;
      }
      return {
        verticalUsed,
        horizontalUsed,
        isVerticallyScrollable,
        isHorizontallyScrollable
      };
    });
    this.isVerticallyScrollable = computed(() => this.state().isVerticallyScrollable);
    this.isHorizontallyScrollable = computed(() => this.state().isHorizontallyScrollable);
    this.verticalUsed = computed(() => this.state().verticalUsed);
    this.horizontalUsed = computed(() => this.state().horizontalUsed);
    this.trackScrollDuration = input(this.options.trackScrollDuration, {
      transform: numberAttribute
    });
    this.appearance = input(this.options.appearance);
    this.position = input(this.options.position);
    this.trackClass = input(this.options.trackClass);
    this.thumbClass = input(this.options.thumbClass);
    this.buttonClass = input(this.options.thumbClass);
    this.afterInit = output();
    this.afterUpdate = output();
    let resizeSub$;
    let hasInitialized;
    afterRenderEffect({
      earlyRead: (onCleanup) => {
        const disableSensor = this.disableSensor();
        const throttleDuration = this.sensorThrottleTime();
        const viewportInit = this.viewport.initialized();
        untracked(() => {
          if (viewportInit) {
            if (disableSensor) {
              requestAnimationFrame(() => this.update(ScrollbarUpdateReason.AfterInit));
            } else {
              this.zone.runOutsideAngular(() => {
                resizeSub$ = getThrottledStream(combineLatest([this.sharedResizeObserver.observe(this.viewport.nativeElement), this.sharedResizeObserver.observe(this.viewport.contentWrapperElement)]), throttleDuration).subscribe(() => {
                  this.zone.run(() => {
                    this.updateDimensions();
                    if (hasInitialized) {
                      this.afterUpdate.emit();
                    } else {
                      this.afterInit.emit();
                    }
                    hasInitialized = true;
                  });
                });
              });
            }
          }
          onCleanup(() => resizeSub$?.unsubscribe());
        });
      }
    });
  }
  /**
   * Manual update
   */
  update(reason) {
    this.updateDimensions();
    if (reason === ScrollbarUpdateReason.AfterInit) {
      this.afterInit.emit();
    } else {
      this.afterUpdate.emit();
    }
  }
  /**
   * Smooth scroll functions
   */
  scrollTo(options) {
    return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
  }
  /**
   * Scroll to element by reference or selector
   */
  scrollToElement(target, options) {
    return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
  }
  updateDimensions() {
    this.viewportDimension.set({
      width: this.viewport.offsetWidth,
      height: this.viewport.offsetHeight
    });
    this.contentDimension.set({
      width: this.viewport.contentWidth,
      height: this.viewport.contentHeight
    });
  }
  static {
    this.\u0275fac = function NgScrollbarCore_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgScrollbarCore)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _NgScrollbarCore,
      hostVars: 22,
      hostBindings: function NgScrollbarCore_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("verticalUsed", ctx.verticalUsed())("horizontalUsed", ctx.horizontalUsed())("isVerticallyScrollable", ctx.isVerticallyScrollable())("isHorizontallyScrollable", ctx.isHorizontallyScrollable())("mobile", ctx.isMobile)("dir", ctx.direction())("position", ctx.position())("dragging", ctx.dragging())("appearance", ctx.appearance())("visibility", ctx.visibility())("orientation", ctx.orientation())("disableInteraction", ctx.disableInteraction());
          \u0275\u0275styleProp("--content-height", ctx.contentDimension().height)("--content-width", ctx.contentDimension().width)("--viewport-height", ctx.viewportDimension().height)("--viewport-width", ctx.viewportDimension().width);
          \u0275\u0275classProp("ng-scrollbar", true);
        }
      },
      inputs: {
        orientation: [1, "orientation"],
        visibility: [1, "visibility"],
        buttons: [1, "buttons"],
        disableInteraction: [1, "disableInteraction"],
        disableSensor: [1, "disableSensor"],
        sensorThrottleTime: [1, "sensorThrottleTime"],
        hoverOffset: [1, "hoverOffset"],
        trackScrollDuration: [1, "trackScrollDuration"],
        appearance: [1, "appearance"],
        position: [1, "position"],
        trackClass: [1, "trackClass"],
        thumbClass: [1, "thumbClass"],
        buttonClass: [1, "buttonClass"]
      },
      outputs: {
        afterInit: "afterInit",
        afterUpdate: "afterUpdate"
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_SCROLLBAR,
        useExisting: _NgScrollbarCore
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgScrollbarCore, [{
    type: Directive,
    args: [{
      host: {
        "[class.ng-scrollbar]": "true",
        "[attr.verticalUsed]": "verticalUsed()",
        "[attr.horizontalUsed]": "horizontalUsed()",
        "[attr.isVerticallyScrollable]": "isVerticallyScrollable()",
        "[attr.isHorizontallyScrollable]": "isHorizontallyScrollable()",
        "[attr.mobile]": "isMobile",
        "[attr.dir]": "direction()",
        "[attr.position]": "position()",
        "[attr.dragging]": "dragging()",
        "[attr.appearance]": "appearance()",
        "[attr.visibility]": "visibility()",
        "[attr.orientation]": "orientation()",
        "[attr.disableInteraction]": "disableInteraction()",
        "[style.--content-height]": "contentDimension().height",
        "[style.--content-width]": "contentDimension().width",
        "[style.--viewport-height]": "viewportDimension().height",
        "[style.--viewport-width]": "viewportDimension().width"
      },
      providers: [{
        provide: NG_SCROLLBAR,
        useExisting: NgScrollbarCore
      }]
    }]
  }], () => [], null);
})();
var SCROLLBAR_CONTROL = new InjectionToken("SCROLLBAR_CONTROL");
var ScrollbarAdapter = class _ScrollbarAdapter {
  constructor() {
    this.trackSize = signal(0);
    this.cmp = inject(NG_SCROLLBAR);
  }
  static {
    this.\u0275fac = function ScrollbarAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScrollbarAdapter)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ScrollbarAdapter
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollbarAdapter, [{
    type: Directive
  }], null, null);
})();
var PointerEventsAdapter = class _PointerEventsAdapter {
  constructor() {
    this.cmp = inject(NG_SCROLLBAR);
    this.control = inject(SCROLLBAR_CONTROL);
    this.document = inject(DOCUMENT);
    this.zone = inject(NgZone);
    this.nativeElement = inject(ElementRef).nativeElement;
    effect((onCleanup) => {
      const disableInteraction = this.cmp.disableInteraction();
      untracked(() => {
        if (!disableInteraction) {
          this.zone.runOutsideAngular(() => {
            this._pointerEventsSub = this.pointerEvents.subscribe();
          });
        }
        onCleanup(() => this._pointerEventsSub?.unsubscribe());
      });
    });
  }
  static {
    this.\u0275fac = function PointerEventsAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PointerEventsAdapter)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _PointerEventsAdapter
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PointerEventsAdapter, [{
    type: Directive
  }], () => [], null);
})();
var TrackAdapter = class _TrackAdapter extends PointerEventsAdapter {
  // Returns viewport client size
  get viewportSize() {
    return this.cmp.viewport[this.control.sizeProperty];
  }
  // Get track client rect
  get clientRect() {
    return this.nativeElement.getBoundingClientRect();
  }
  // Scrollbar track offset
  get offset() {
    return this.clientRect[this.control.rectOffsetProperty];
  }
  // Scrollbar track length
  get size() {
    return this.nativeElement[this.control.sizeProperty];
  }
  // Observable for track dragging events
  get pointerEvents() {
    const pointerDown$ = fromEvent(this.nativeElement, "pointerdown").pipe(stopPropagation(), preventSelection(this.document));
    const pointerUp$ = fromEvent(this.document, "pointerup", {
      passive: true
    }).pipe(enableSelection(this.document));
    const pointerEnter$ = fromEvent(this.nativeElement, "pointerover", {
      passive: true
    }).pipe(
      // When mouse is out and enters again, must set the current position first
      tap((e) => this.currMousePosition = e[this.control.offsetProperty]),
      map(() => true)
    );
    const pointerLeave$ = fromEvent(this.nativeElement, "pointerout", {
      passive: true
    }).pipe(map(() => false));
    const pointerOver$ = merge(pointerEnter$, pointerLeave$).pipe(startWith(true));
    const pointerMove$ = fromEvent(this.nativeElement, "pointermove", {
      passive: true
    }).pipe(tap((e) => this.currMousePosition = e[this.control.offsetProperty]));
    return pointerDown$.pipe(switchMap((startEvent) => {
      pointerMove$.pipe(takeUntil(pointerUp$)).subscribe();
      return this.onTrackFirstClick(startEvent).pipe(delay(200), switchMap(() => {
        return pointerOver$.pipe(switchMap((over) => {
          const currDirection = this.getScrollDirection(this.currMousePosition);
          const sameDirection = this.scrollDirection === currDirection;
          return over && sameDirection ? this.onTrackOngoingMousedown() : EMPTY;
        }));
      }), takeUntil(pointerUp$));
    }));
  }
  constructor() {
    afterRenderEffect({
      earlyRead: () => {
        this.cmp.viewportDimension();
        this.cmp.contentDimension();
        untracked(() => {
          this.control.trackSize.set(this.size);
          if (!this.size) {
            requestAnimationFrame(() => this.control.trackSize.set(this.size));
          }
        });
      }
    });
    super();
  }
  /**
   *  Callback when mouse is first clicked on the track
   */
  onTrackFirstClick(e) {
    this.currMousePosition = e[this.control.offsetProperty];
    this.scrollDirection = this.getScrollDirection(this.currMousePosition);
    this.scrollMax = this.control.viewportScrollMax;
    return this.scrollTo(this.nextStep());
  }
  nextStep() {
    if (this.scrollDirection === "forward") {
      const scrollForwardIncrement = this.getScrollForwardStep();
      if (scrollForwardIncrement >= this.scrollMax) {
        return this.scrollMax;
      }
      return scrollForwardIncrement;
    }
    const scrollBackwardIncrement = this.getScrollBackwardStep();
    if (scrollBackwardIncrement <= 0) {
      return 0;
    }
    return scrollBackwardIncrement;
  }
  /**
   * Callback when mouse is still down on the track
   * Incrementally scrolls towards target position until reached
   */
  onTrackOngoingMousedown() {
    const position = this.nextStep();
    return this.scrollTo(position).pipe(takeWhile(() => !this.isReached(position)), switchMap(() => this.onTrackOngoingMousedown()));
  }
  /**
   * Returns a flag that determines whether the scroll from the given position is the final step or not
   */
  isReached(position) {
    if (this.scrollDirection === "forward") {
      return position >= this.scrollMax;
    }
    return position <= 0;
  }
  static {
    this.\u0275fac = function TrackAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TrackAdapter)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _TrackAdapter,
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrackAdapter, [{
    type: Directive
  }], () => [], null);
})();
var TrackXDirective = class _TrackXDirective extends TrackAdapter {
  get contentSize() {
    return this.cmp.viewport.contentWidth;
  }
  constructor() {
    effect(() => {
      if (this.cmp.direction() === "rtl") {
        this.getCurrPosition = () => {
          const offset = this.contentSize - this.viewportSize - this.control.viewportScrollOffset;
          return offset * this.size / this.contentSize;
        };
        this.getScrollDirection = (position) => {
          return position < this.getCurrPosition() ? "forward" : "backward";
        };
      } else {
        this.getCurrPosition = () => {
          return this.control.viewportScrollOffset * this.size / this.contentSize;
        };
        this.getScrollDirection = (position) => {
          return position > this.getCurrPosition() ? "forward" : "backward";
        };
      }
    });
    super();
  }
  scrollTo(start) {
    return from(this.cmp.scrollTo({
      start,
      duration: this.cmp.trackScrollDuration()
    }));
  }
  getScrollForwardStep() {
    return this.control.viewportScrollOffset + this.viewportSize;
  }
  getScrollBackwardStep() {
    return this.control.viewportScrollOffset - this.viewportSize;
  }
  static {
    this.\u0275fac = function TrackXDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TrackXDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _TrackXDirective,
      selectors: [["", "scrollbarTrackX", ""]],
      features: [\u0275\u0275ProvidersFeature([{
        provide: TrackAdapter,
        useExisting: _TrackXDirective
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrackXDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[scrollbarTrackX]",
      providers: [{
        provide: TrackAdapter,
        useExisting: TrackXDirective
      }]
    }]
  }], () => [], null);
})();
var TrackYDirective = class _TrackYDirective extends TrackAdapter {
  get contentSize() {
    return this.cmp.viewport.contentHeight;
  }
  getCurrPosition() {
    return this.control.viewportScrollOffset * this.size / this.contentSize;
  }
  getScrollDirection(position) {
    return position > this.getCurrPosition() ? "forward" : "backward";
  }
  scrollTo(top) {
    return from(this.cmp.scrollTo({
      top,
      duration: this.cmp.trackScrollDuration()
    }));
  }
  getScrollForwardStep() {
    return this.control.viewportScrollOffset + this.viewportSize;
  }
  getScrollBackwardStep() {
    return this.control.viewportScrollOffset - this.viewportSize;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275TrackYDirective_BaseFactory;
      return function TrackYDirective_Factory(__ngFactoryType__) {
        return (\u0275TrackYDirective_BaseFactory || (\u0275TrackYDirective_BaseFactory = \u0275\u0275getInheritedFactory(_TrackYDirective)))(__ngFactoryType__ || _TrackYDirective);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _TrackYDirective,
      selectors: [["", "scrollbarTrackY", ""]],
      features: [\u0275\u0275ProvidersFeature([{
        provide: TrackAdapter,
        useExisting: _TrackYDirective
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrackYDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[scrollbarTrackY]",
      providers: [{
        provide: TrackAdapter,
        useExisting: TrackYDirective
      }]
    }]
  }], null, null);
})();
var ScrollbarManager = class _ScrollbarManager {
  constructor() {
    this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
    this._polyfillUrl = inject(NG_SCROLLBAR_POLYFILL);
    this.document = inject(DOCUMENT);
    this.window = this.document.defaultView;
    this.scrollTimelinePolyfill = signal(null);
    if (this.isBrowser && (!this.window["ScrollTimeline"] || !CSS.supports("animation-timeline", "scroll()"))) {
      this.initPolyfill();
    }
  }
  initPolyfill() {
    return __async(this, null, function* () {
      try {
        const script = this.document.createElement("script");
        script.src = this._polyfillUrl;
        yield new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = reject;
          this.document.head.appendChild(script);
        });
        if (this.window["ScrollTimeline"]) {
          this.scrollTimelinePolyfill.set(this.window["ScrollTimeline"]);
        } else {
          console.error("[NgScrollbar]: ScrollTimeline is not attached to the window object.");
        }
      } catch (error) {
        console.error("[NgScrollbar]: Error loading ScrollTimeline script:", error);
      }
    });
  }
  static {
    this.\u0275fac = function ScrollbarManager_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScrollbarManager)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ScrollbarManager,
      factory: _ScrollbarManager.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollbarManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var ThumbAdapter = class _ThumbAdapter extends PointerEventsAdapter {
  // Returns thumb size
  get size() {
    return this.nativeElement.getBoundingClientRect()[this.control.rectSizeProperty];
  }
  // The maximum space available for scrolling.
  get trackMax() {
    return this.track.size - this.size;
  }
  /**
   * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
   * This function is called by thumb drag event using viewport or scrollbar pointer events
   */
  get pointerEvents() {
    return fromEvent(this.nativeElement, "pointerdown").pipe(stopPropagation(), preventSelection(this.document), switchMap((e) => {
      let startTrackMax;
      let startScrollMax;
      const dragStart = of(e).pipe(tap(() => {
        startTrackMax = this.trackMax;
        startScrollMax = this.control.viewportScrollMax;
        this.setDragging(this.control.axis);
      }));
      const dragging = fromEvent(this.document, "pointermove").pipe(stopPropagation());
      const dragEnd = fromEvent(this.document, "pointerup", {
        capture: true
      }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging("none")));
      return dragStart.pipe(map((startEvent) => startEvent[this.control.offsetProperty]), switchMap((startOffset) => dragging.pipe(
        map((moveEvent) => moveEvent[this.control.clientProperty]),
        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
        map((moveClient) => moveClient - this.track.offset),
        map((trackRelativeOffset) => startScrollMax * (trackRelativeOffset - startOffset) / startTrackMax),
        tap((scrollPosition) => this.control.instantScrollTo(scrollPosition, startScrollMax)),
        takeUntil(dragEnd)
      )));
    }));
  }
  constructor() {
    afterRenderEffect({
      earlyRead: () => {
        const script = this.manager.scrollTimelinePolyfill();
        untracked(() => {
          if (script && !this._animation) {
            this._animation = startPolyfill(script, this.nativeElement, this.cmp.viewport.nativeElement, this.control.axis);
          }
        });
      }
    });
    super();
    this.manager = inject(ScrollbarManager);
    this.track = inject(TrackAdapter);
  }
  setDragging(value) {
    this.zone.run(() => this.cmp.dragging.set(value));
  }
  static {
    this.\u0275fac = function ThumbAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThumbAdapter)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThumbAdapter,
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThumbAdapter, [{
    type: Directive
  }], () => [], null);
})();
function startPolyfill(ScrollTimeline, element, source, axis) {
  return element.animate({
    translate: ["var(--_scrollbar-thumb-transform-from)", "var(--_scrollbar-thumb-transform-to)"]
  }, {
    fill: "both",
    easing: "linear",
    timeline: new ScrollTimeline({
      source,
      axis
    })
  });
}
var ThumbXDirective = class _ThumbXDirective extends ThumbAdapter {
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThumbXDirective_BaseFactory;
      return function ThumbXDirective_Factory(__ngFactoryType__) {
        return (\u0275ThumbXDirective_BaseFactory || (\u0275ThumbXDirective_BaseFactory = \u0275\u0275getInheritedFactory(_ThumbXDirective)))(__ngFactoryType__ || _ThumbXDirective);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThumbXDirective,
      selectors: [["", "scrollbarThumbX", ""]],
      features: [\u0275\u0275ProvidersFeature([{
        provide: ThumbAdapter,
        useExisting: _ThumbXDirective
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThumbXDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[scrollbarThumbX]",
      providers: [{
        provide: ThumbAdapter,
        useExisting: ThumbXDirective
      }]
    }]
  }], null, null);
})();
var ThumbYDirective = class _ThumbYDirective extends ThumbAdapter {
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThumbYDirective_BaseFactory;
      return function ThumbYDirective_Factory(__ngFactoryType__) {
        return (\u0275ThumbYDirective_BaseFactory || (\u0275ThumbYDirective_BaseFactory = \u0275\u0275getInheritedFactory(_ThumbYDirective)))(__ngFactoryType__ || _ThumbYDirective);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThumbYDirective,
      selectors: [["", "scrollbarThumbY", ""]],
      features: [\u0275\u0275ProvidersFeature([{
        provide: ThumbAdapter,
        useExisting: _ThumbYDirective
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThumbYDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "[scrollbarThumbY]",
      providers: [{
        provide: ThumbAdapter,
        useExisting: ThumbYDirective
      }]
    }]
  }], null, null);
})();
var canScrollFunc = {
  forward: (scrollOffset, scrollMax) => scrollOffset < scrollMax,
  backward: (scrollOffset) => scrollOffset > 0
};
var scrollStepFunc = {
  forward: (scrollBy, offset) => offset + scrollBy,
  backward: (scrollBy, offset) => offset - scrollBy
};
var horizontalScrollStepFunc = {
  rtl: {
    forward: (scrollBy, offset, scrollMax) => scrollMax - offset - scrollBy,
    backward: (scrollBy, offset, scrollMax) => scrollMax - offset + scrollBy
  },
  ltr: scrollStepFunc
};
var ScrollbarButton = class _ScrollbarButton extends PointerEventsAdapter {
  get pointerEvents() {
    const pointerDown$ = fromEvent(this.nativeElement, "pointerdown").pipe(stopPropagation(), preventSelection(this.document));
    const pointerUp$ = fromEvent(this.document, "pointerup", {
      passive: true
    }).pipe(enableSelection(this.document));
    const pointerLeave$ = fromEvent(this.nativeElement, "pointerleave", {
      passive: true
    });
    const pointerUpOrLeave$ = merge(pointerUp$, pointerLeave$);
    return pointerDown$.pipe(switchMap(() => this.firstScrollStep().pipe(delay(this.afterFirstClickDelay), switchMap(() => this.onOngoingPointerdown()), takeUntil(pointerUpOrLeave$))));
  }
  constructor() {
    effect(() => {
      const scrollDirection = this.scrollDirection();
      const dir = this.cmp.direction();
      untracked(() => {
        this.canScroll = canScrollFunc[scrollDirection];
        if (this.control.axis === "x") {
          this.nextStep = horizontalScrollStepFunc[dir][scrollDirection];
        } else {
          this.nextStep = scrollStepFunc[scrollDirection];
        }
      });
    });
    super();
    this.scrollbarButton = input.required();
    this.scrollDirection = input.required();
    this.afterFirstClickDelay = 120;
    this.firstClickDuration = 100;
    this.scrollBy = 50;
    this.onGoingScrollBy = 12;
  }
  firstScrollStep() {
    const value = this.nextStep(this.scrollBy, this.control.viewportScrollOffset, this.control.viewportScrollMax);
    return this.control.scrollTo(value, this.firstClickDuration);
  }
  onGoingScrollStep() {
    const scrollMax = this.control.viewportScrollMax;
    const value = this.nextStep(this.onGoingScrollBy, this.control.viewportScrollOffset, scrollMax);
    this.control.instantScrollTo(value, scrollMax);
  }
  onOngoingPointerdown() {
    return interval(0, animationFrameScheduler).pipe(takeWhile(() => this.canScroll(this.control.viewportScrollOffset, this.control.viewportScrollMax)), tap(() => this.onGoingScrollStep()));
  }
  static {
    this.\u0275fac = function ScrollbarButton_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScrollbarButton)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ScrollbarButton,
      selectors: [["button", "scrollbarButton", ""]],
      inputs: {
        scrollbarButton: [1, "scrollbarButton"],
        scrollDirection: [1, "scrollDirection"]
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      attrs: _c03,
      decls: 3,
      vars: 0,
      consts: [[1, "ng-scrollbar-button-icon"], ["viewBox", "0 0 512 512", "xmlns", "http://www.w3.org/2000/svg"], ["d", "M413.1,327.3l-1.8-2.1l-136-156.5c-4.6-5.3-11.5-8.6-19.2-8.6c-7.7,0-14.6,3.4-19.2,8.6L101,324.9l-2.3,2.6  C97,330,96,333,96,336.2c0,8.7,7.4,15.8,16.6,15.8v0h286.8v0c9.2,0,16.6-7.1,16.6-15.8C416,332.9,414.9,329.8,413.1,327.3z"]],
      template: function ScrollbarButton_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275namespaceSVG();
          \u0275\u0275elementStart(1, "svg", 1);
          \u0275\u0275element(2, "path", 2);
          \u0275\u0275elementEnd()();
        }
      },
      styles: ["[_nghost-%COMP%]{position:relative;border:none;margin:0;padding:0;border-radius:0;appearance:none;background-color:var(--INTERNAL-scrollbar-button-color)}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:100%;height:100%;fill:var(--INTERNAL-scrollbar-button-fill)}[_nghost-%COMP%]:hover{background:var(--INTERNAL-scrollbar-button-hover-color)}[_nghost-%COMP%]:hover   svg[_ngcontent-%COMP%]{fill:var(--INTERNAL-scrollbar-button-hover-fill)}[_nghost-%COMP%]:active{background:var(--INTERNAL-scrollbar-button-active-color)}[_nghost-%COMP%]:active   svg[_ngcontent-%COMP%]{fill:var(--INTERNAL-scrollbar-button-active-fill)}[scrollbarButton=top][_nghost-%COMP%], [scrollbarButton=start][_nghost-%COMP%]{order:1}[scrollbarButton=bottom][_nghost-%COMP%], [scrollbarButton=end][_nghost-%COMP%]{order:3}[scrollbarButton=top][_nghost-%COMP%], [scrollbarButton=bottom][_nghost-%COMP%]{width:100%;height:var(--INTERNAL-scrollbar-button-size)}[scrollbarButton=start][_nghost-%COMP%], [scrollbarButton=end][_nghost-%COMP%]{width:var(--INTERNAL-scrollbar-button-size);height:100%}[scrollbarButton=bottom][_nghost-%COMP%]{--_button-rotate: 180deg}[scrollbarButton=start][_nghost-%COMP%]{--_button-rotate: -90deg}[scrollbarButton=start][_nghost-%COMP%]   .ng-scrollbar-button-icon[_ngcontent-%COMP%]{writing-mode:vertical-lr}[scrollbarButton=end][_nghost-%COMP%]{--_button-rotate: 90deg}[scrollbarButton=end][_nghost-%COMP%]   .ng-scrollbar-button-icon[_ngcontent-%COMP%]{writing-mode:vertical-rl}.ng-scrollbar-button-icon[_ngcontent-%COMP%]{rotate:var(--_button-rotate);display:flex;place-content:center;place-items:center;width:100%;height:100%}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollbarButton, [{
    type: Component,
    args: [{
      selector: "button[scrollbarButton]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div class="ng-scrollbar-button-icon">\r\n  <svg viewBox="0 0 512 512"\r\n       xmlns="http://www.w3.org/2000/svg">\r\n    <path\r\n      d="M413.1,327.3l-1.8-2.1l-136-156.5c-4.6-5.3-11.5-8.6-19.2-8.6c-7.7,0-14.6,3.4-19.2,8.6L101,324.9l-2.3,2.6  C97,330,96,333,96,336.2c0,8.7,7.4,15.8,16.6,15.8v0h286.8v0c9.2,0,16.6-7.1,16.6-15.8C416,332.9,414.9,329.8,413.1,327.3z"/>\r\n  </svg>\r\n</div>\r\n',
      styles: [":host{position:relative;border:none;margin:0;padding:0;border-radius:0;appearance:none;background-color:var(--INTERNAL-scrollbar-button-color)}:host svg{width:100%;height:100%;fill:var(--INTERNAL-scrollbar-button-fill)}:host:hover{background:var(--INTERNAL-scrollbar-button-hover-color)}:host:hover svg{fill:var(--INTERNAL-scrollbar-button-hover-fill)}:host:active{background:var(--INTERNAL-scrollbar-button-active-color)}:host:active svg{fill:var(--INTERNAL-scrollbar-button-active-fill)}:host[scrollbarButton=top],:host[scrollbarButton=start]{order:1}:host[scrollbarButton=bottom],:host[scrollbarButton=end]{order:3}:host[scrollbarButton=top],:host[scrollbarButton=bottom]{width:100%;height:var(--INTERNAL-scrollbar-button-size)}:host[scrollbarButton=start],:host[scrollbarButton=end]{width:var(--INTERNAL-scrollbar-button-size);height:100%}:host[scrollbarButton=bottom]{--_button-rotate: 180deg}:host[scrollbarButton=start]{--_button-rotate: -90deg}:host[scrollbarButton=start] .ng-scrollbar-button-icon{writing-mode:vertical-lr}:host[scrollbarButton=end]{--_button-rotate: 90deg}:host[scrollbarButton=end] .ng-scrollbar-button-icon{writing-mode:vertical-rl}.ng-scrollbar-button-icon{rotate:var(--_button-rotate);display:flex;place-content:center;place-items:center;width:100%;height:100%}\n"]
    }]
  }], () => [], null);
})();
var ScrollbarY = class _ScrollbarY extends ScrollbarAdapter {
  constructor() {
    super(...arguments);
    this.rectOffsetProperty = "top";
    this.rectSizeProperty = "height";
    this.sizeProperty = "offsetHeight";
    this.clientProperty = "clientY";
    this.offsetProperty = "offsetY";
    this.axis = "y";
  }
  get viewportScrollMax() {
    return this.cmp.viewport.scrollMaxY;
  }
  get viewportScrollOffset() {
    return this.cmp.viewport.scrollTop;
  }
  scrollTo(top, duration) {
    return from(this.cmp.scrollTo({
      top,
      duration
    }));
  }
  instantScrollTo(value) {
    this.cmp.viewport.scrollYTo(value);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ScrollbarY_BaseFactory;
      return function ScrollbarY_Factory(__ngFactoryType__) {
        return (\u0275ScrollbarY_BaseFactory || (\u0275ScrollbarY_BaseFactory = \u0275\u0275getInheritedFactory(_ScrollbarY)))(__ngFactoryType__ || _ScrollbarY);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ScrollbarY,
      selectors: [["scrollbar-y"]],
      hostVars: 2,
      hostBindings: function ScrollbarY_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275styleProp("--track-size", ctx.trackSize());
        }
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: SCROLLBAR_CONTROL,
        useExisting: _ScrollbarY
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 11,
      consts: [[1, "ng-scrollbar-sticky"], [1, "ng-scrollbar-track-wrapper"], ["scrollbarTrackY", ""], ["scrollbarThumbY", ""], ["scrollbarButton", "top", "scrollDirection", "backward"], ["scrollbarButton", "bottom", "scrollDirection", "forward"]],
      template: function ScrollbarY_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
          \u0275\u0275element(3, "div", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275template(4, ScrollbarY_Conditional_4_Template, 2, 6);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275classProp("ng-scrollbar-hover", ctx.cmp.hoverOffset());
          \u0275\u0275advance();
          \u0275\u0275classProp("ng-scrollbar-hover", !ctx.cmp.hoverOffset());
          \u0275\u0275advance();
          \u0275\u0275classMapInterpolate1("ng-scrollbar-track ", ctx.cmp.trackClass(), "");
          \u0275\u0275advance();
          \u0275\u0275classMapInterpolate1("ng-scrollbar-thumb ", ctx.cmp.thumbClass(), "");
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.cmp.buttons() ? 4 : -1);
        }
      },
      dependencies: [TrackYDirective, ThumbYDirective, ScrollbarButton],
      styles: ["[_nghost-%COMP%]{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky[_ngcontent-%COMP%]{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition);pointer-events:var(--_scrollbar-pointer-events)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);transition:var(--INTERNAL-scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;background-color:var(--INTERNAL-scrollbar-track-color);border-radius:var(--INTERNAL-scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb[_ngcontent-%COMP%]{box-sizing:border-box;position:absolute;transition:var(--INTERNAL-scrollbar-thumb-transition);border-radius:var(--INTERNAL-scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:_ngcontent-%COMP%_scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes _ngcontent-%COMP%_scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}", "[_nghost-%COMP%]{--_scrollbar-wrapper-top: 0;--_scrollbar-wrapper-left: var(--_scrollbar-wrapper-y-left);--_scrollbar-wrapper-right: var(--_scrollbar-wrapper-y-right);--_scrollbar-wrapper-height: var(--viewport-height);--_scrollbar-wrapper-width: var(--_scrollbar-thickness);--_scrollbar-track-top: var(--_vertical-top);--_scrollbar-track-bottom: var(--_vertical-bottom);--_scrollbar-track-right: var(--_vertical-right);--_scrollbar-track-left: var(--_vertical-left);--thumb-size: max(calc(var(--viewport-height) * var(--track-size) / var(--content-height)), var(--INTERNAL-scrollbar-thumb-min-size));--_thumb-height: calc(var(--thumb-size) * 1px);--_thumb-width: 100%;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-size) - var(--thumb-size));--_scrollbar-thumb-transform-from: 0 0;--_scrollbar-thumb-transform-to: 0 calc(var(--_scrollbar-y-thumb-transform-to-value) * 1px)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{width:var(--_track-y-thickness);flex-direction:column}.ng-scrollbar-hover[_ngcontent-%COMP%]:hover, .ng-scrollbar-hover[_ngcontent-%COMP%]:active{--_track-y-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-hover-color)}.ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-timeline:var(--_animation-timeline-y);min-height:calc(var(--INTERNAL-scrollbar-thumb-min-size) * 1px);display:var(--_vertical-thumb-display);background-color:var(--_thumb-y-color)}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollbarY, [{
    type: Component,
    args: [{
      selector: "scrollbar-y",
      template: `
    <div class="ng-scrollbar-sticky"
         [class.ng-scrollbar-hover]="cmp.hoverOffset()">
      <div class="ng-scrollbar-track-wrapper"
           [class.ng-scrollbar-hover]="!cmp.hoverOffset()">
        <div scrollbarTrackY class="ng-scrollbar-track {{ cmp.trackClass() }}">
          <div scrollbarThumbY class="ng-scrollbar-thumb {{ cmp.thumbClass() }}"></div>
        </div>
        @if (cmp.buttons()) {
          <button class="ng-scrollbar-button {{ cmp.buttonClass() }}"
                  scrollbarButton="top"
                  scrollDirection="backward"></button>
          <button class="ng-scrollbar-button {{ cmp.buttonClass() }}"
                  scrollbarButton="bottom"
                  scrollDirection="forward"></button>
        }
      </div>
    </div>
  `,
      imports: [TrackYDirective, ThumbYDirective, ScrollbarButton],
      providers: [{
        provide: SCROLLBAR_CONTROL,
        useExisting: ScrollbarY
      }],
      host: {
        "[style.--track-size]": "trackSize()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition);pointer-events:var(--_scrollbar-pointer-events)}.ng-scrollbar-track-wrapper{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);transition:var(--INTERNAL-scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track{position:relative;width:100%;height:100%;background-color:var(--INTERNAL-scrollbar-track-color);border-radius:var(--INTERNAL-scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--INTERNAL-scrollbar-thumb-transition);border-radius:var(--INTERNAL-scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: 0;--_scrollbar-wrapper-left: var(--_scrollbar-wrapper-y-left);--_scrollbar-wrapper-right: var(--_scrollbar-wrapper-y-right);--_scrollbar-wrapper-height: var(--viewport-height);--_scrollbar-wrapper-width: var(--_scrollbar-thickness);--_scrollbar-track-top: var(--_vertical-top);--_scrollbar-track-bottom: var(--_vertical-bottom);--_scrollbar-track-right: var(--_vertical-right);--_scrollbar-track-left: var(--_vertical-left);--thumb-size: max(calc(var(--viewport-height) * var(--track-size) / var(--content-height)), var(--INTERNAL-scrollbar-thumb-min-size));--_thumb-height: calc(var(--thumb-size) * 1px);--_thumb-width: 100%;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-size) - var(--thumb-size));--_scrollbar-thumb-transform-from: 0 0;--_scrollbar-thumb-transform-to: 0 calc(var(--_scrollbar-y-thumb-transform-to-value) * 1px)}.ng-scrollbar-track-wrapper{width:var(--_track-y-thickness);flex-direction:column}.ng-scrollbar-hover:hover,.ng-scrollbar-hover:active{--_track-y-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-y);min-height:calc(var(--INTERNAL-scrollbar-thumb-min-size) * 1px);display:var(--_vertical-thumb-display);background-color:var(--_thumb-y-color)}\n"]
    }]
  }], null, null);
})();
var ScrollbarX = class _ScrollbarX extends ScrollbarAdapter {
  get viewportScrollMax() {
    return this.cmp.viewport.scrollMaxX;
  }
  get viewportScrollOffset() {
    return Math.abs(this.cmp.viewport.scrollLeft);
  }
  constructor() {
    effect(() => {
      if (this.cmp.direction() === "rtl") {
        this.handlePosition = (position, scrollMax) => -(scrollMax - position);
      } else {
        this.handlePosition = (position) => position;
      }
    });
    super();
    this.manager = inject(ScrollbarManager);
    this.rectOffsetProperty = "left";
    this.rectSizeProperty = "width";
    this.sizeProperty = "offsetWidth";
    this.clientProperty = "clientX";
    this.offsetProperty = "offsetX";
    this.axis = "x";
  }
  scrollTo(left, duration) {
    return from(this.cmp.scrollTo({
      left,
      duration
    }));
  }
  instantScrollTo(value, scrollMax) {
    this.cmp.viewport.scrollXTo(this.handlePosition(value, scrollMax));
  }
  static {
    this.\u0275fac = function ScrollbarX_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScrollbarX)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ScrollbarX,
      selectors: [["scrollbar-x"]],
      hostVars: 3,
      hostBindings: function ScrollbarX_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("dir", ctx.cmp.direction());
          \u0275\u0275styleProp("--track-size", ctx.trackSize());
        }
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: SCROLLBAR_CONTROL,
        useExisting: _ScrollbarX
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 11,
      consts: [[1, "ng-scrollbar-sticky"], [1, "ng-scrollbar-track-wrapper"], ["scrollbarTrackX", ""], ["scrollbarThumbX", ""], ["scrollbarButton", "start", "scrollDirection", "backward"], ["scrollbarButton", "end", "scrollDirection", "forward"]],
      template: function ScrollbarX_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
          \u0275\u0275element(3, "div", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275template(4, ScrollbarX_Conditional_4_Template, 2, 6);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275classProp("ng-scrollbar-hover", ctx.cmp.hoverOffset());
          \u0275\u0275advance();
          \u0275\u0275classProp("ng-scrollbar-hover", !ctx.cmp.hoverOffset());
          \u0275\u0275advance();
          \u0275\u0275classMapInterpolate1("ng-scrollbar-track ", ctx.cmp.trackClass(), "");
          \u0275\u0275advance();
          \u0275\u0275classMapInterpolate1("ng-scrollbar-thumb ", ctx.cmp.thumbClass(), "");
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.cmp.buttons() ? 4 : -1);
        }
      },
      dependencies: [TrackXDirective, ThumbXDirective, ScrollbarButton],
      styles: [_c1, "[_nghost-%COMP%]{--_scrollbar-wrapper-top: var(--_scrollbar-wrapper-x-top);--_scrollbar-wrapper-left: 0;--_scrollbar-wrapper-right: 0;--_scrollbar-wrapper-height: var(--_scrollbar-thickness);--_scrollbar-wrapper-width: var(--viewport-width);--_scrollbar-track-top: var(--_horizontal-top);--_scrollbar-track-bottom: var(--_horizontal-bottom);--_scrollbar-track-right: var(--_horizontal-right);--_scrollbar-track-left: var(--_horizontal-left);--thumb-size: max(calc(var(--viewport-width) * var(--track-size) / var(--content-width)), var(--INTERNAL-scrollbar-thumb-min-size));--_thumb-height: 100%;--_thumb-width: calc(var(--thumb-size) * 1px);--_scrollbar-x-thumb-transform-to-value: calc(var(--track-size) - var(--thumb-size));--_scrollbar-thumb-transform-from: 0;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * 1px)}[_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=start][_ngcontent-%COMP%]{_--button-rotate:90}[_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=end][_ngcontent-%COMP%]{_--button-rotate:-90}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-name:_ngcontent-%COMP%_scrollbarThumbRTLAnimation;will-change:right;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * -1px)}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=start][_ngcontent-%COMP%]{--_button-rotate: 90deg}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=end][_ngcontent-%COMP%]{--_button-rotate: -90deg}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{height:var(--_track-x-thickness);flex-direction:row}.ng-scrollbar-hover[_ngcontent-%COMP%]:hover, .ng-scrollbar-hover[_ngcontent-%COMP%]:active{--_track-x-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-hover-color)}.ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-timeline:var(--_animation-timeline-x);min-width:calc(var(--INTERNAL-scrollbar-thumb-min-size) * 1px);display:var(--_horizontal-thumb-display);background-color:var(--_thumb-x-color)}@keyframes _ngcontent-%COMP%_scrollbarThumbRTLAnimation{0%{right:var(--_scrollbar-thumb-transform-from)}to{right:calc(var(--_scrollbar-thumb-transform-to) * -1)}}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollbarX, [{
    type: Component,
    args: [{
      selector: "scrollbar-x",
      template: `
    <div class="ng-scrollbar-sticky"
         [class.ng-scrollbar-hover]="cmp.hoverOffset()">
      <div class="ng-scrollbar-track-wrapper"
           [class.ng-scrollbar-hover]="!cmp.hoverOffset()">
        <div scrollbarTrackX class="ng-scrollbar-track {{ cmp.trackClass() }}">
          <div scrollbarThumbX class="ng-scrollbar-thumb {{ cmp.thumbClass() }}"></div>
        </div>
        @if (cmp.buttons()) {
          <button class="ng-scrollbar-button {{ cmp.buttonClass() }}"
                  scrollbarButton="start"
                  scrollDirection="backward"></button>
          <button class="ng-scrollbar-button {{ cmp.buttonClass() }}"
                  scrollbarButton="end"
                  scrollDirection="forward"></button>
        }
      </div>
    </div>
  `,
      imports: [TrackXDirective, ThumbXDirective, ScrollbarButton],
      providers: [{
        provide: SCROLLBAR_CONTROL,
        useExisting: ScrollbarX
      }],
      host: {
        "[attr.dir]": "cmp.direction()",
        "[style.--track-size]": "trackSize()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition);pointer-events:var(--_scrollbar-pointer-events)}.ng-scrollbar-track-wrapper{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);transition:var(--INTERNAL-scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track{position:relative;width:100%;height:100%;background-color:var(--INTERNAL-scrollbar-track-color);border-radius:var(--INTERNAL-scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--INTERNAL-scrollbar-thumb-transition);border-radius:var(--INTERNAL-scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: var(--_scrollbar-wrapper-x-top);--_scrollbar-wrapper-left: 0;--_scrollbar-wrapper-right: 0;--_scrollbar-wrapper-height: var(--_scrollbar-thickness);--_scrollbar-wrapper-width: var(--viewport-width);--_scrollbar-track-top: var(--_horizontal-top);--_scrollbar-track-bottom: var(--_horizontal-bottom);--_scrollbar-track-right: var(--_horizontal-right);--_scrollbar-track-left: var(--_horizontal-left);--thumb-size: max(calc(var(--viewport-width) * var(--track-size) / var(--content-width)), var(--INTERNAL-scrollbar-thumb-min-size));--_thumb-height: 100%;--_thumb-width: calc(var(--thumb-size) * 1px);--_scrollbar-x-thumb-transform-to-value: calc(var(--track-size) - var(--thumb-size));--_scrollbar-thumb-transform-from: 0;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * 1px)}:host .ng-scrollbar-button[scrollbarButton=start]{_--button-rotate:90}:host .ng-scrollbar-button[scrollbarButton=end]{_--button-rotate:-90}:host[dir=rtl] .ng-scrollbar-thumb{animation-name:scrollbarThumbRTLAnimation;will-change:right;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * -1px)}:host[dir=rtl] .ng-scrollbar-button[scrollbarButton=start]{--_button-rotate: 90deg}:host[dir=rtl] .ng-scrollbar-button[scrollbarButton=end]{--_button-rotate: -90deg}.ng-scrollbar-track-wrapper{height:var(--_track-x-thickness);flex-direction:row}.ng-scrollbar-hover:hover,.ng-scrollbar-hover:active{--_track-x-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-x);min-width:calc(var(--INTERNAL-scrollbar-thumb-min-size) * 1px);display:var(--_horizontal-thumb-display);background-color:var(--_thumb-x-color)}@keyframes scrollbarThumbRTLAnimation{0%{right:var(--_scrollbar-thumb-transform-from)}to{right:calc(var(--_scrollbar-thumb-transform-to) * -1)}}\n"]
    }]
  }], () => [], null);
})();
var Scrollbars = class _Scrollbars {
  constructor() {
    this.cmp = inject(NG_SCROLLBAR);
  }
  static {
    this.\u0275fac = function Scrollbars_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Scrollbars)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _Scrollbars,
      selectors: [["scrollbars"]],
      decls: 2,
      vars: 2,
      template: function Scrollbars_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, Scrollbars_Conditional_0_Template, 1, 0, "scrollbar-y")(1, Scrollbars_Conditional_1_Template, 1, 0, "scrollbar-x");
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.cmp.verticalUsed() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.cmp.horizontalUsed() ? 1 : -1);
        }
      },
      dependencies: [ScrollbarX, ScrollbarY],
      styles: ["[_nghost-%COMP%]{display:contents}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Scrollbars, [{
    type: Component,
    args: [{
      selector: "scrollbars",
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [ScrollbarX, ScrollbarY],
      template: `
    @if (cmp.verticalUsed()) {
      <scrollbar-y/>
    }
    @if (cmp.horizontalUsed()) {
      <scrollbar-x/>
    }
  `,
      styles: [":host{display:contents}\n"]
    }]
  }], null, null);
})();
var NgScrollbar = class _NgScrollbar extends NgScrollbarCore {
  constructor() {
    effect(() => {
      const contentWrapper = this.contentWrapper().nativeElement;
      untracked(() => {
        this.viewport.init(this.nativeElement, contentWrapper);
      });
    });
    super();
    this.contentWrapper = viewChild.required("contentWrapper");
    this._scrollbars = viewChild.required(Scrollbars);
  }
  static {
    this.\u0275fac = function NgScrollbar_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgScrollbar)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _NgScrollbar,
      selectors: [["ng-scrollbar", 3, "externalViewport", ""]],
      viewQuery: function NgScrollbar_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.contentWrapper, _c2, 5);
          \u0275\u0275viewQuerySignal(ctx._scrollbars, Scrollbars, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      exportAs: ["ngScrollbar"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_SCROLLBAR,
        useExisting: _NgScrollbar
      }, ViewportAdapter]), \u0275\u0275InheritDefinitionFeature],
      ngContentSelectors: _c3,
      decls: 4,
      vars: 0,
      consts: [["contentWrapper", ""]],
      template: function NgScrollbar_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275elementStart(0, "div", null, 0);
          \u0275\u0275projection(2);
          \u0275\u0275element(3, "scrollbars");
          \u0275\u0275elementEnd();
        }
      },
      dependencies: [Scrollbars],
      styles: ["[_nghost-%COMP%]{display:block;position:relative;max-height:100%;max-width:100%;--INTERNAL-scrollbar-border-radius: var(--scrollbar-border-radius, 0px);--INTERNAL-scrollbar-thickness: var(--scrollbar-thickness, 5);--INTERNAL-scrollbar-offset: var(--scrollbar-offset, 0);--INTERNAL-scrollbar-track-wrapper-transition: var(--scrollbar-track-wrapper-transition, width 60ms linear, height 60ms linear);--INTERNAL-scrollbar-track-color: var(--scrollbar-track-color, transparent);--INTERNAL-scrollbar-thumb-color: var(--scrollbar-thumb-color, rgb(0 0 0 / 20%));--INTERNAL-scrollbar-thumb-hover-color: var(--scrollbar-thumb-hover-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-hover-thickness: var(--scrollbar-hover-thickness, var(--INTERNAL-scrollbar-thickness));--INTERNAL-scrollbar-thumb-transition: var(--scrollbar-thumb-transition, none);--INTERNAL-scrollbar-thumb-min-size: var(--scrollbar-thumb-min-size, 20);--INTERNAL-scrollbar-button-color: var(--scrollbar-button-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-button-hover-color: var(--scrollbar-button-hover-color, var(--INTERNAL-scrollbar-button-color));--INTERNAL-scrollbar-button-active-color: var(--scrollbar-button-active-color, var(--INTERNAL-scrollbar-button-hover-color));--INTERNAL-scrollbar-button-fill: var(--scrollbar-button-fill, white);--INTERNAL-scrollbar-button-hover-fill: var(--scrollbar-button-hover-fill, var(--INTERNAL-scrollbar-button-fill));--INTERNAL-scrollbar-button-active-fill: var(--scrollbar-button-active-fill, var(--INTERNAL-scrollbar-button-hover-fill));--INTERNAL-scrollbar-button-size: var(--scrollbar-button-size, 20px);--INTERNAL-scrollbar-hover-opacity-transition-enter-duration: var(--scrollbar-hover-opacity-transition-enter-duration, 0);--INTERNAL-scrollbar-hover-opacity-transition-leave-duration: var(--scrollbar-hover-opacity-transition-leave-duration, .4s);--INTERNAL-scrollbar-hover-opacity-transition-leave-delay: var(--scrollbar-hover-opacity-transition-leave-delay, 1s);--INTERNAL-scrollbar-overscroll-behavior: var(--scrollbar-overscroll-behavior, initial);--INTERNAL-scrollbar-mobile-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior, none);--_scrollbar-thickness: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--INTERNAL-scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--INTERNAL-scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_viewport-pointer-events: auto;--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-color);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}[_nghost-%COMP%]{--_spacer-width: var(--spacer-width);--_spacer-height: var(--spacer-height);--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}.ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior);pointer-events:var(--_viewport-pointer-events)}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}[appearance=native][_nghost-%COMP%]{--_spacer-width: calc(var(--spacer-width) + var(--_scrollbar-thickness));--_spacer-height: calc(var(--spacer-height) + var(--_scrollbar-thickness))}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-spacer[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-spacer{position:relative;width:calc(var(--_spacer-width) * 1px);height:calc(var(--_spacer-height) * 1px)}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{scrollbar-width:none!important}.ng-scroll-viewport[_nghost-%COMP%]::-webkit-scrollbar, .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport::-webkit-scrollbar{display:none!important}[position=invertX][_nghost-%COMP%], [position=invertAll][_nghost-%COMP%]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}[dir=ltr][_nghost-%COMP%]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=ltr][position=invertY][_nghost-%COMP%], [dir=ltr][position=invertAll][_nghost-%COMP%]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}[dir=rtl][_nghost-%COMP%]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=rtl][position=invertY][_nghost-%COMP%], [dir=rtl][position=invertAll][_nghost-%COMP%]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_scrollbar-thickness-margin: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}[horizontalUsed=true][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}[horizontalUsed=true][position=invertX][_nghost-%COMP%], [horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}[verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[appearance=native][verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][_nghost-%COMP%]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][position=invertX][_nghost-%COMP%], [appearance=native][horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}[visibility=hover][_nghost-%COMP%]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-leave-duration) var(--INTERNAL-scrollbar-hover-opacity-transition-leave-delay)}[visibility=hover][_nghost-%COMP%]:hover, [visibility=hover][_nghost-%COMP%]:active, [visibility=hover][_nghost-%COMP%]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-enter-duration)}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper, [_nghost-%COMP%]     .scroll-reached-trigger-element, [_nghost-%COMP%]     .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}[_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end], [_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}[_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom], [_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}[_nghost-%COMP%]     .scroll-reached-trigger-element{background:red}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[_ngcontent-%COMP%]{background:#00f}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{left:0;right:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{top:0;bottom:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%]{top:0;height:var(--dropped-offset-top)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{bottom:0;height:var(--dropped-offset-bottom)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%]{width:var(--dropped-offset-start)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{width:var(--dropped-offset-end)}[verticalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y}[horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}[orientation=vertical][_nghost-%COMP%]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}[orientation=horizontal][_nghost-%COMP%]{--_viewport-overflow: auto hidden}[disableInteraction=true][_nghost-%COMP%]{--_viewport-pointer-events: none;--_scrollbar-pointer-events: none}[isVerticallyScrollable=false][_nghost-%COMP%]{--_vertical-thumb-display: none}[isHorizontallyScrollable=false][_nghost-%COMP%]{--_horizontal-thumb-display: none}[dragging=x][_nghost-%COMP%], [dragging=y][_nghost-%COMP%]{--_viewport-user-select: none}[dragging=x][_nghost-%COMP%]{--_track-x-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}[dragging=y][_nghost-%COMP%]{--_track-y-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}[mobile=true][_nghost-%COMP%]{--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-mobile-overscroll-behavior)}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgScrollbar, [{
    type: Component,
    args: [{
      selector: "ng-scrollbar:not([externalViewport])",
      exportAs: "ngScrollbar",
      imports: [Scrollbars],
      template: `
    <div #contentWrapper>
      <ng-content/>
      <scrollbars/>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_SCROLLBAR,
        useExisting: NgScrollbar
      }, ViewportAdapter],
      styles: [":host{display:block;position:relative;max-height:100%;max-width:100%;--INTERNAL-scrollbar-border-radius: var(--scrollbar-border-radius, 0px);--INTERNAL-scrollbar-thickness: var(--scrollbar-thickness, 5);--INTERNAL-scrollbar-offset: var(--scrollbar-offset, 0);--INTERNAL-scrollbar-track-wrapper-transition: var(--scrollbar-track-wrapper-transition, width 60ms linear, height 60ms linear);--INTERNAL-scrollbar-track-color: var(--scrollbar-track-color, transparent);--INTERNAL-scrollbar-thumb-color: var(--scrollbar-thumb-color, rgb(0 0 0 / 20%));--INTERNAL-scrollbar-thumb-hover-color: var(--scrollbar-thumb-hover-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-hover-thickness: var(--scrollbar-hover-thickness, var(--INTERNAL-scrollbar-thickness));--INTERNAL-scrollbar-thumb-transition: var(--scrollbar-thumb-transition, none);--INTERNAL-scrollbar-thumb-min-size: var(--scrollbar-thumb-min-size, 20);--INTERNAL-scrollbar-button-color: var(--scrollbar-button-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-button-hover-color: var(--scrollbar-button-hover-color, var(--INTERNAL-scrollbar-button-color));--INTERNAL-scrollbar-button-active-color: var(--scrollbar-button-active-color, var(--INTERNAL-scrollbar-button-hover-color));--INTERNAL-scrollbar-button-fill: var(--scrollbar-button-fill, white);--INTERNAL-scrollbar-button-hover-fill: var(--scrollbar-button-hover-fill, var(--INTERNAL-scrollbar-button-fill));--INTERNAL-scrollbar-button-active-fill: var(--scrollbar-button-active-fill, var(--INTERNAL-scrollbar-button-hover-fill));--INTERNAL-scrollbar-button-size: var(--scrollbar-button-size, 20px);--INTERNAL-scrollbar-hover-opacity-transition-enter-duration: var(--scrollbar-hover-opacity-transition-enter-duration, 0);--INTERNAL-scrollbar-hover-opacity-transition-leave-duration: var(--scrollbar-hover-opacity-transition-leave-duration, .4s);--INTERNAL-scrollbar-hover-opacity-transition-leave-delay: var(--scrollbar-hover-opacity-transition-leave-delay, 1s);--INTERNAL-scrollbar-overscroll-behavior: var(--scrollbar-overscroll-behavior, initial);--INTERNAL-scrollbar-mobile-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior, none);--_scrollbar-thickness: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--INTERNAL-scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--INTERNAL-scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_viewport-pointer-events: auto;--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-color);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_spacer-width: var(--spacer-width);--_spacer-height: var(--spacer-height);--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior);pointer-events:var(--_viewport-pointer-events)}:host.ng-scroll-viewport>.ng-scroll-content,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host[appearance=native]{--_spacer-width: calc(var(--spacer-width) + var(--_scrollbar-thickness));--_spacer-height: calc(var(--spacer-height) + var(--_scrollbar-thickness))}:host.ng-scroll-viewport>.ng-scroll-spacer,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport>.ng-scroll-spacer{position:relative;width:calc(var(--_spacer-width) * 1px);height:calc(var(--_spacer-height) * 1px)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none!important}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none!important}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=native][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=native][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=native][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=native][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=native][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][horizontalUsed=true][position=invertX],:host[appearance=native][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-leave-duration) var(--INTERNAL-scrollbar-hover-opacity-transition-leave-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-enter-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start],:host[dir=ltr] ::ng-deep .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end],:host[dir=ltr] ::ng-deep .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start],:host[dir=rtl] ::ng-deep .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end],:host[dir=rtl] ::ng-deep .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .ng-scroll-dropped-wrapper,:host ::ng-deep .scroll-reached-trigger-element,:host ::ng-deep .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end],:host ::ng-deep [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom],:host ::ng-deep [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host .scroll-dropped-trigger-element{background:#00f}:host .scroll-dropped-trigger-element[trigger=top],:host .scroll-dropped-trigger-element[trigger=bottom]{left:0;right:0}:host .scroll-dropped-trigger-element[trigger=start],:host .scroll-dropped-trigger-element[trigger=end]{top:0;bottom:0}:host .scroll-dropped-trigger-element[trigger=top]{top:0;height:var(--dropped-offset-top)}:host .scroll-dropped-trigger-element[trigger=bottom]{bottom:0;height:var(--dropped-offset-bottom)}:host .scroll-dropped-trigger-element[trigger=start]{width:var(--dropped-offset-start)}:host .scroll-dropped-trigger-element[trigger=end]{width:var(--dropped-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_viewport-pointer-events: none;--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[dragging=x]{--_track-x-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}:host[dragging=y]{--_track-y-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}:host[mobile=true]{--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-mobile-overscroll-behavior)}\n"]
    }]
  }], () => [], null);
})();
var NgScrollbarExt = class _NgScrollbarExt extends NgScrollbarCore {
  constructor() {
    effect(() => {
      const viewportElement = this.viewportElement();
      const contentWrapperElement = this.contentWrapperElement();
      const spacerElement = this.spacerElement();
      const viewportError = this.viewportError();
      const contentWrapperError = this.contentWrapperError();
      const spacerError = this.spacerError();
      untracked(() => {
        if (!this.skipInit) {
          const error = viewportError || contentWrapperError || spacerError;
          if (error) {
            console.error(error);
          } else {
            this.initialize(viewportElement, contentWrapperElement, spacerElement);
          }
        }
      });
    });
    super();
    this.renderer = inject(Renderer2);
    this.appRef = inject(ApplicationRef);
    this._scrollbars = signal(null);
    this.externalViewport = input();
    this.externalContentWrapper = input();
    this.externalSpacer = input();
    this.viewportElement = linkedSignal({
      source: this.externalViewport,
      // If viewport selector was defined, query the element
      computation: (selector) => this.getElement(selector) || this.customViewport()?.nativeElement
    });
    this.viewportError = computed(() => {
      return !this.viewportElement() ? `[NgScrollbar]: Could not find the viewport element for the provided selector "${this.externalViewport()}"` : null;
    });
    this.contentWrapperElement = linkedSignal({
      source: this.externalContentWrapper,
      computation: (selector) => this.getElement(selector)
    });
    this.contentWrapperError = computed(() => {
      return !this.contentWrapperElement() && this.externalContentWrapper() ? `[NgScrollbar]: Content wrapper element not found for the provided selector "${this.externalContentWrapper()}"` : null;
    });
    this.spacerElement = linkedSignal({
      source: this.externalSpacer,
      computation: (selector) => this.getElement(selector)
    });
    this.spacerError = computed(() => {
      return !this.spacerElement() && this.externalSpacer() ? `[NgScrollbar]: Spacer element not found for the provided selector "${this.externalSpacer()}"` : null;
    });
    this.customViewport = contentChild(ScrollViewport, {
      descendants: true
    });
  }
  ngOnDestroy() {
    if (this._scrollbarsRef) {
      this.appRef.detachView(this._scrollbarsRef.hostView);
      this._scrollbarsRef.destroy();
    }
  }
  initialize(viewportElement, contentWrapperElement, spacerElement) {
    if (this.skipInit) {
      this.viewportElement.set(viewportElement);
      this.contentWrapperElement.set(contentWrapperElement);
      this.spacerElement.set(spacerElement);
    }
    if (!spacerElement && !contentWrapperElement) {
      contentWrapperElement = this.renderer.createElement("div");
      const childNodes = Array.from(viewportElement.childNodes);
      childNodes.forEach((node) => this.renderer.appendChild(contentWrapperElement, node));
      this.renderer.appendChild(viewportElement, contentWrapperElement);
    }
    if (contentWrapperElement) {
      this.viewport.init(viewportElement, contentWrapperElement, spacerElement);
      this._attachScrollbars();
    }
  }
  _attachScrollbars() {
    this._scrollbarsRef = createComponent(Scrollbars, {
      environmentInjector: this.appRef.injector,
      elementInjector: Injector.create({
        providers: [{
          provide: NG_SCROLLBAR,
          useValue: this
        }]
      })
    });
    this.renderer.appendChild(this.viewport.contentWrapperElement, this._scrollbarsRef.location.nativeElement);
    this.appRef.attachView(this._scrollbarsRef.hostView);
    this._scrollbars.set(this._scrollbarsRef.instance);
  }
  getElement(selector) {
    return selector ? this.nativeElement.querySelector(selector) : null;
  }
  static {
    this.\u0275fac = function NgScrollbarExt_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgScrollbarExt)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _NgScrollbarExt,
      selectors: [["ng-scrollbar", "externalViewport", ""]],
      contentQueries: function NgScrollbarExt_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.customViewport, ScrollViewport, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: ["ngSkipHydration", "true"],
      hostVars: 2,
      hostBindings: function NgScrollbarExt_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("ng-scrollbar-external-viewport", true);
        }
      },
      inputs: {
        externalViewport: [1, "externalViewport"],
        externalContentWrapper: [1, "externalContentWrapper"],
        externalSpacer: [1, "externalSpacer"]
      },
      exportAs: ["ngScrollbar"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_SCROLLBAR,
        useExisting: _NgScrollbarExt
      }, {
        provide: NgScrollbarCore,
        useExisting: NgScrollbar
      }, ViewportAdapter]), \u0275\u0275InheritDefinitionFeature],
      attrs: _c4,
      ngContentSelectors: _c3,
      decls: 1,
      vars: 0,
      template: function NgScrollbarExt_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      styles: [_c5],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgScrollbarExt, [{
    type: Component,
    args: [{
      standalone: true,
      selector: "ng-scrollbar[externalViewport]",
      exportAs: "ngScrollbar",
      template: "<ng-content/>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        // This component appends a content wrapper element to the viewport
        // A hydration mismatch error will be thrown (NG0500) during DOM manipulation.
        // To avoid this error, the 'ngSkipHydration' attribute is added to skip hydration.
        ngSkipHydration: "true",
        "[class.ng-scrollbar-external-viewport]": "true"
      },
      providers: [{
        provide: NG_SCROLLBAR,
        useExisting: NgScrollbarExt
      }, {
        provide: NgScrollbarCore,
        useExisting: NgScrollbar
      }, ViewportAdapter],
      styles: [":host{display:block;position:relative;max-height:100%;max-width:100%;--INTERNAL-scrollbar-border-radius: var(--scrollbar-border-radius, 0px);--INTERNAL-scrollbar-thickness: var(--scrollbar-thickness, 5);--INTERNAL-scrollbar-offset: var(--scrollbar-offset, 0);--INTERNAL-scrollbar-track-wrapper-transition: var(--scrollbar-track-wrapper-transition, width 60ms linear, height 60ms linear);--INTERNAL-scrollbar-track-color: var(--scrollbar-track-color, transparent);--INTERNAL-scrollbar-thumb-color: var(--scrollbar-thumb-color, rgb(0 0 0 / 20%));--INTERNAL-scrollbar-thumb-hover-color: var(--scrollbar-thumb-hover-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-hover-thickness: var(--scrollbar-hover-thickness, var(--INTERNAL-scrollbar-thickness));--INTERNAL-scrollbar-thumb-transition: var(--scrollbar-thumb-transition, none);--INTERNAL-scrollbar-thumb-min-size: var(--scrollbar-thumb-min-size, 20);--INTERNAL-scrollbar-button-color: var(--scrollbar-button-color, var(--INTERNAL-scrollbar-thumb-color));--INTERNAL-scrollbar-button-hover-color: var(--scrollbar-button-hover-color, var(--INTERNAL-scrollbar-button-color));--INTERNAL-scrollbar-button-active-color: var(--scrollbar-button-active-color, var(--INTERNAL-scrollbar-button-hover-color));--INTERNAL-scrollbar-button-fill: var(--scrollbar-button-fill, white);--INTERNAL-scrollbar-button-hover-fill: var(--scrollbar-button-hover-fill, var(--INTERNAL-scrollbar-button-fill));--INTERNAL-scrollbar-button-active-fill: var(--scrollbar-button-active-fill, var(--INTERNAL-scrollbar-button-hover-fill));--INTERNAL-scrollbar-button-size: var(--scrollbar-button-size, 20px);--INTERNAL-scrollbar-hover-opacity-transition-enter-duration: var(--scrollbar-hover-opacity-transition-enter-duration, 0);--INTERNAL-scrollbar-hover-opacity-transition-leave-duration: var(--scrollbar-hover-opacity-transition-leave-duration, .4s);--INTERNAL-scrollbar-hover-opacity-transition-leave-delay: var(--scrollbar-hover-opacity-transition-leave-delay, 1s);--INTERNAL-scrollbar-overscroll-behavior: var(--scrollbar-overscroll-behavior, initial);--INTERNAL-scrollbar-mobile-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior, none);--_scrollbar-thickness: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--INTERNAL-scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--INTERNAL-scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_viewport-pointer-events: auto;--_thumb-x-color: var(--INTERNAL-scrollbar-thumb-color);--_thumb-y-color: var(--INTERNAL-scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_spacer-width: var(--spacer-width);--_spacer-height: var(--spacer-height);--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior);pointer-events:var(--_viewport-pointer-events)}:host.ng-scroll-viewport>.ng-scroll-content,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host[appearance=native]{--_spacer-width: calc(var(--spacer-width) + var(--_scrollbar-thickness));--_spacer-height: calc(var(--spacer-height) + var(--_scrollbar-thickness))}:host.ng-scroll-viewport>.ng-scroll-spacer,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport>.ng-scroll-spacer{position:relative;width:calc(var(--_spacer-width) * 1px);height:calc(var(--_spacer-height) * 1px)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none!important}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none!important}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--INTERNAL-scrollbar-thickness) + var(--INTERNAL-scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=native][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=native][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=native][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=native][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=native][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=native][horizontalUsed=true][position=invertX],:host[appearance=native][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-leave-duration) var(--INTERNAL-scrollbar-hover-opacity-transition-leave-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--INTERNAL-scrollbar-hover-opacity-transition-enter-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start],:host[dir=ltr] ::ng-deep .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end],:host[dir=ltr] ::ng-deep .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start],:host[dir=rtl] ::ng-deep .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end],:host[dir=rtl] ::ng-deep .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .ng-scroll-dropped-wrapper,:host ::ng-deep .scroll-reached-trigger-element,:host ::ng-deep .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end],:host ::ng-deep [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom],:host ::ng-deep [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host .scroll-dropped-trigger-element{background:#00f}:host .scroll-dropped-trigger-element[trigger=top],:host .scroll-dropped-trigger-element[trigger=bottom]{left:0;right:0}:host .scroll-dropped-trigger-element[trigger=start],:host .scroll-dropped-trigger-element[trigger=end]{top:0;bottom:0}:host .scroll-dropped-trigger-element[trigger=top]{top:0;height:var(--dropped-offset-top)}:host .scroll-dropped-trigger-element[trigger=bottom]{bottom:0;height:var(--dropped-offset-bottom)}:host .scroll-dropped-trigger-element[trigger=start]{width:var(--dropped-offset-start)}:host .scroll-dropped-trigger-element[trigger=end]{width:var(--dropped-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_viewport-pointer-events: none;--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[dragging=x]{--_track-x-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}:host[dragging=y]{--_track-y-thickness: calc(var(--INTERNAL-scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(var(--INTERNAL-scrollbar-thumb-min-size))}:host[mobile=true]{--_viewport-overscroll-behavior: var(--INTERNAL-scrollbar-mobile-overscroll-behavior)}\n"]
    }]
  }], () => [], null);
})();
var AsyncDetection = class _AsyncDetection {
  constructor() {
    this.scrollbar = inject(NgScrollbarExt, {
      self: true
    });
    this.zone = inject(NgZone);
    this.contentObserver = inject(ContentObserver);
    this.asyncDetection = input();
    this.scrollbar.skipInit = true;
    let sub$;
    effect((onCleanup) => {
      const init = this.scrollbar.viewport.initialized();
      const externalViewport = this.scrollbar.externalViewport();
      const externalContentWrapper = this.scrollbar.externalContentWrapper();
      const externalSpacer = this.scrollbar.externalSpacer();
      const asyncDetection = this.asyncDetection();
      untracked(() => {
        let viewportElement;
        let contentWrapperElement;
        this.zone.runOutsideAngular(() => {
          sub$ = this.contentObserver.observe(this.scrollbar.nativeElement).pipe(throttleTime(100, null, {
            leading: true,
            trailing: true
          })).subscribe(() => {
            viewportElement = this.scrollbar.nativeElement.querySelector(externalViewport);
            contentWrapperElement = this.scrollbar.nativeElement.querySelector(externalContentWrapper);
            this.zone.run(() => {
              if (!init && viewportElement && contentWrapperElement) {
                let spacerElement;
                if (externalSpacer) {
                  spacerElement = this.scrollbar.nativeElement.querySelector(externalSpacer);
                }
                this.scrollbar.initialize(viewportElement, contentWrapperElement, spacerElement);
              } else if (!viewportElement || !contentWrapperElement) {
                this.scrollbar.viewport.reset();
              }
            });
            if (asyncDetection !== "auto") {
              sub$.unsubscribe();
            }
          });
        });
        onCleanup(() => sub$?.unsubscribe());
      });
    });
  }
  static {
    this.\u0275fac = function AsyncDetection_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AsyncDetection)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _AsyncDetection,
      selectors: [["ng-scrollbar", "externalViewport", "", "asyncDetection", ""]],
      inputs: {
        asyncDetection: [1, "asyncDetection"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncDetection, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "ng-scrollbar[externalViewport][asyncDetection]"
    }]
  }], () => [], null);
})();
var SyncSpacer = class _SyncSpacer {
  constructor() {
    this.sharedResizeObserver = inject(SharedResizeObserver);
    this.scrollbar = inject(NgScrollbarExt, {
      self: true
    });
    this.zone = inject(NgZone);
    this.spacerDimension = signal({});
    let sub$;
    effect((onCleanup) => {
      const spacerElement = this.scrollbar.spacerElement();
      const contentWrapperElement = this.scrollbar.contentWrapperElement();
      const throttleDuration = this.scrollbar.sensorThrottleTime();
      const disableSensor = this.scrollbar.disableSensor();
      untracked(() => {
        if (!disableSensor && contentWrapperElement && spacerElement) {
          this.zone.runOutsideAngular(() => {
            sub$ = getThrottledStream(this.sharedResizeObserver.observe(contentWrapperElement), throttleDuration).pipe(map((entries) => filterResizeEntries(entries, contentWrapperElement))).subscribe(() => {
              this.zone.run(() => {
                requestAnimationFrame(() => {
                  this.spacerDimension.set({
                    width: contentWrapperElement.offsetWidth,
                    height: contentWrapperElement.offsetHeight
                  });
                });
              });
            });
          });
        }
        onCleanup(() => sub$?.unsubscribe());
      });
    });
  }
  static {
    this.\u0275fac = function SyncSpacer_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SyncSpacer)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _SyncSpacer,
      selectors: [["ng-scrollbar", "externalViewport", "", "syncSpacer", ""]],
      hostVars: 4,
      hostBindings: function SyncSpacer_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275styleProp("--spacer-width", ctx.spacerDimension().width)("--spacer-height", ctx.spacerDimension().height);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SyncSpacer, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "ng-scrollbar[externalViewport][syncSpacer]",
      host: {
        "[style.--spacer-width]": "spacerDimension().width",
        "[style.--spacer-height]": "spacerDimension().height"
      }
    }]
  }], () => [], null);
})();
var NgScrollbarModule = class _NgScrollbarModule {
  static {
    this.\u0275fac = function NgScrollbarModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgScrollbarModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _NgScrollbarModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgScrollbarModule, [{
    type: NgModule,
    args: [{
      imports: [NgScrollbar, ScrollViewport, NgScrollbarExt, AsyncDetection, SyncSpacer],
      exports: [NgScrollbar, ScrollViewport, NgScrollbarExt, AsyncDetection, SyncSpacer]
    }]
  }], null, null);
})();

// src/app/shared/templates/sidebar/menu-item/menu-item.component.ts
var _c04 = (a0) => ({ "active": a0 });
function MenuItemComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 2)(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 1, ctx_r0.item.name || ""));
  }
}
function MenuItemComponent_ng_container_2_i_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i");
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap("ti ti-" + ctx_r0.item.icon);
  }
}
function MenuItemComponent_ng_container_2_ul_7_ng_container_1_app_menu_item_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-menu-item", 10);
  }
  if (rf & 2) {
    const subItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("item", subItem_r3)("isOpened", ctx_r0.isOpened)("isHovered", ctx_r0.isHovered)("activatedFeatures", ctx_r0.activatedFeatures)("currentEmployee", ctx_r0.currentEmployee);
  }
}
function MenuItemComponent_ng_container_2_ul_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, MenuItemComponent_ng_container_2_ul_7_ng_container_1_app_menu_item_1_Template, 1, 5, "app-menu-item", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const subItem_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.checkRole(subItem_r3) && ctx_r0.checkFeature(subItem_r3));
  }
}
function MenuItemComponent_ng_container_2_ul_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 7);
    \u0275\u0275template(1, MenuItemComponent_ng_container_2_ul_7_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", ctx_r0.item.expanded && (ctx_r0.isOpened || ctx_r0.isHovered) ? "show-sub-menu" : "hide-sub-menu");
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.item.submenu);
  }
}
function MenuItemComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 3)(2, "a", 4);
    \u0275\u0275listener("click", function MenuItemComponent_ng_container_2_Template_a_click_2_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.expandMenu());
    })("keydown.enter", function MenuItemComponent_ng_container_2_Template_a_keydown_enter_2_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.expandMenu());
    });
    \u0275\u0275template(3, MenuItemComponent_ng_container_2_i_3_Template, 1, 2, "i", 5);
    \u0275\u0275elementStart(4, "span");
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "translate");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(7, MenuItemComponent_ng_container_2_ul_7_Template, 2, 2, "ul", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", ctx_r0.item.route)("ngClass", \u0275\u0275pureFunction1(7, _c04, ctx_r0.item.expanded));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.item.icon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(6, 5, ctx_r0.item.name || ""));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.item.submenu && ctx_r0.item.submenu.length > 0);
  }
}
function MenuItemComponent_ng_container_3_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "small", 14);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", ctx_r0.item.badge.class);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 2, ctx_r0.item.badge.value), " ");
  }
}
function MenuItemComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 11)(2, "a", 12);
    \u0275\u0275listener("click", function MenuItemComponent_ng_container_3_Template_a_click_2_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onItemClick(ctx_r0.item));
    });
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "translate");
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, MenuItemComponent_ng_container_3_ng_container_6_Template, 4, 4, "ng-container", 13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", ctx_r0.item.route);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(5, 3, ctx_r0.item.name || ""));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.item.badge);
  }
}
var MenuItemComponent = class _MenuItemComponent {
  sideBarService;
  item;
  isOpened;
  isHovered;
  activatedFeatures = [];
  currentEmployee;
  constructor(sideBarService) {
    this.sideBarService = sideBarService;
  }
  expandMenu() {
    if (this.item.submenu && this.item.submenu.length > 0) {
      this.onExpandMenu();
    }
  }
  onItemClick(item) {
    if (!this.checkRole(this.item) || !this.checkFeature(this.item)) {
      return;
    }
    this.sideBarService.saveActiveState(item.route || "");
  }
  onExpandMenu() {
    this.item.expanded = !this.item.expanded;
    this.sideBarService.saveState();
  }
  checkFeature(item) {
    return !item.feature || this.activatedFeatures.includes(item.feature);
  }
  checkRole(item) {
    if (!item.accessibility)
      return false;
    if (item.accessibility === "*") {
      return true;
    }
    if (this.currentEmployee?.role && item.accessibility.includes(this.currentEmployee.role)) {
      return true;
    }
    return false;
  }
  static \u0275fac = function MenuItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuItemComponent)(\u0275\u0275directiveInject(SideBarService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _MenuItemComponent, selectors: [["app-menu-item"]], inputs: { item: "item", isOpened: "isOpened", isHovered: "isHovered", activatedFeatures: "activatedFeatures", currentEmployee: "currentEmployee" }, decls: 4, vars: 4, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [1, "title-item"], [1, "expanded-item", "submenu"], [3, "click", "keydown.enter", "routerLink", "ngClass"], [3, "class", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], [4, "ngFor", "ngForOf"], [3, "item", "isOpened", "isHovered", "activatedFeatures", "currentEmployee", 4, "ngIf"], [3, "item", "isOpened", "isHovered", "activatedFeatures", "currentEmployee"], [1, "menu-item"], ["routerLinkActive", "active", 1, "justify-content-between", 3, "click", "routerLink"], [4, "ngIf"], [1, "ms-2", "badge", "float-end", 3, "ngClass"]], template: function MenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainerStart(0, 0);
      \u0275\u0275template(1, MenuItemComponent_ng_container_1_Template, 5, 3, "ng-container", 1)(2, MenuItemComponent_ng_container_2_Template, 8, 9, "ng-container", 1)(3, MenuItemComponent_ng_container_3_Template, 7, 5, "ng-container", 1);
      \u0275\u0275elementContainerEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngSwitch", ctx.item.type);
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", "header");
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", "expandable");
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", "item");
    }
  }, dependencies: [_MenuItemComponent, CommonModule, NgClass, NgForOf, NgIf, NgSwitch, NgSwitchCase, AsyncPipe, RouterLink, RouterLinkActive, TranslatePipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(MenuItemComponent, { className: "MenuItemComponent", filePath: "src/app/shared/templates/sidebar/menu-item/menu-item.component.ts", lineNumber: 16 });
})();

// src/app/shared/templates/sidebar/sidebar.component.ts
function SidebarComponent_img_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 7);
  }
  if (rf & 2) {
    const logo_r1 = ctx.$implicit;
    \u0275\u0275property("src", logo_r1, \u0275\u0275sanitizeUrl);
  }
}
function SidebarComponent_For_10_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-menu-item", 8);
  }
  if (rf & 2) {
    const menu_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("item", menu_r2)("isOpened", ctx_r2.sideBarService.isOpened)("isHovered", ctx_r2.sideBarService.isHovered)("activatedFeatures", ctx_r2.activatedFeatures)("currentEmployee", ctx_r2.currentEmployee);
  }
}
function SidebarComponent_For_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SidebarComponent_For_10_Conditional_0_Template, 1, 5, "app-menu-item", 8);
  }
  if (rf & 2) {
    const menu_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r2.checkRole(menu_r2) && ctx_r2.checkFeature(menu_r2) ? 0 : -1);
  }
}
var SidebarComponent = class _SidebarComponent {
  router;
  objectiveFormRepository;
  appSettingsService;
  supabaseAuthService;
  idService;
  spinner;
  storageService;
  sideBarService;
  employeeRepository;
  feedbackFormsRepository;
  featureSettingsService;
  stylesSettingsService;
  selectedCompany = null;
  currentEmployee;
  logos = [];
  activatedFeatures = [];
  constructor(router, objectiveFormRepository, appSettingsService, supabaseAuthService, idService, spinner, storageService, sideBarService, employeeRepository, feedbackFormsRepository, featureSettingsService, stylesSettingsService) {
    this.router = router;
    this.objectiveFormRepository = objectiveFormRepository;
    this.appSettingsService = appSettingsService;
    this.supabaseAuthService = supabaseAuthService;
    this.idService = idService;
    this.spinner = spinner;
    this.storageService = storageService;
    this.sideBarService = sideBarService;
    this.employeeRepository = employeeRepository;
    this.feedbackFormsRepository = feedbackFormsRepository;
    this.featureSettingsService = featureSettingsService;
    this.stylesSettingsService = stylesSettingsService;
  }
  ngOnInit() {
    this.supabaseAuthService.getEmployee$().subscribe((employee) => {
      if (!employee || employee.id == null) {
        return;
      }
      this.currentEmployee = employee;
    });
  }
  ngAfterViewInit() {
    this.initActiveFeatures();
    this.initStylesSettings();
  }
  initStylesSettings() {
    this.stylesSettingsService.stylesSettingsSubject.subscribe((stylesSettings) => {
      if (stylesSettings && stylesSettings.logos) {
        this.logos = stylesSettings.logos;
      }
    });
  }
  initActiveFeatures() {
    this.featureSettingsService.featureSettingsSubject.subscribe((feature_settings) => {
      if (feature_settings?.feature_settings_features) {
        this.activatedFeatures = feature_settings.feature_settings_features.map((x) => x.feature?.component_name || "");
      }
    });
  }
  checkFeature(item) {
    return !item.feature || this.activatedFeatures.includes(item.feature);
  }
  checkRole(item) {
    if (item.accessibility == "*") {
      return true;
    }
    if (this.currentEmployee && item.accessibility.includes(this.currentEmployee.role)) {
      return true;
    }
    return false;
  }
  goToMyProfile() {
    if (!this.currentEmployee) {
      return;
    }
    this.idService.setId("profile", this.currentEmployee.getEmployeeId());
    this.router.navigate(["/profile"]);
  }
  sideBarMouseHover(expand) {
    this.sideBarService.isHovered = expand;
  }
  static \u0275fac = function SidebarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SidebarComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ObjectiveFormRepository), \u0275\u0275directiveInject(AppSettingsService), \u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(SideBarService), \u0275\u0275directiveInject(EmployeeRepository), \u0275\u0275directiveInject(FeedbackFormsRepository), \u0275\u0275directiveInject(FeatureSettingsService), \u0275\u0275directiveInject(StylesSettingsService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SidebarComponent, selectors: [["app-sidebar"]], inputs: { selectedCompany: "selectedCompany" }, decls: 11, vars: 1, consts: [[1, "sidebar", 3, "mouseover", "mouseout", "focus", "blur"], [1, "sidebar-logo"], [1, "d-flex", "align-items-center", "justify-content-between", "header-row"], ["dir", "rtl", 1, "col-12", "d-flex", "flex-row"], ["class", "site-logo", "width", "260px", "height", "100px", 3, "src", 4, "ngFor", "ngForOf"], ["dir", "rtl", 1, "sidebar-inner", "slimscroll"], ["id", "sidebar-menu", 1, "sidebar-menu"], ["width", "260px", "height", "100px", 1, "site-logo", 3, "src"], [3, "item", "isOpened", "isHovered", "activatedFeatures", "currentEmployee"]], template: function SidebarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275listener("mouseover", function SidebarComponent_Template_div_mouseover_0_listener() {
        return ctx.sideBarMouseHover(true);
      })("mouseout", function SidebarComponent_Template_div_mouseout_0_listener() {
        return ctx.sideBarMouseHover(false);
      })("focus", function SidebarComponent_Template_div_focus_0_listener() {
        return ctx.sideBarMouseHover(true);
      })("blur", function SidebarComponent_Template_div_blur_0_listener() {
        return ctx.sideBarMouseHover(false);
      });
      \u0275\u0275elementStart(1, "div", 1)(2, "div", 2)(3, "div", 3);
      \u0275\u0275template(4, SidebarComponent_img_4_Template, 1, 1, "img", 4);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(5, "ng-scrollbar")(6, "div", 5)(7, "div", 6)(8, "ul");
      \u0275\u0275repeaterCreate(9, SidebarComponent_For_10_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIdentity);
      \u0275\u0275elementEnd()()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(4);
      \u0275\u0275property("ngForOf", ctx.logos);
      \u0275\u0275advance(5);
      \u0275\u0275repeater(ctx.sideBarService.sidebarMenu);
    }
  }, dependencies: [CommonModule, NgForOf, NgScrollbarModule, NgScrollbar, MenuItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SidebarComponent, { className: "SidebarComponent", filePath: "src/app/shared/templates/sidebar/sidebar.component.ts", lineNumber: 33 });
})();

// src/app/app.component.ts
var _c05 = (a0, a1) => ({ "mini-sidebar": a0, "expand-menu": a1 });
function AppComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "main", 4);
    \u0275\u0275element(1, "app-navbar");
    \u0275\u0275elementStart(2, "div", 5)(3, "div", 6);
    \u0275\u0275element(4, "app-breadcrumb");
    \u0275\u0275elementContainerStart(5);
    \u0275\u0275element(6, "router-outlet");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd()();
    \u0275\u0275element(7, "app-sidebar");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(1, _c05, !ctx_r0.sidebarService.isOpened, ctx_r0.sidebarService.isHovered));
  }
}
function AppComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "router-outlet");
  }
}
function AppComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function AppComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var AppComponent = class _AppComponent {
  breadcrumbService;
  employeeService;
  idService;
  router;
  msalService;
  msalBroadcastService;
  sidebarService;
  storageService;
  supabaseAuthService;
  smsAuthService;
  appSettingsService;
  eventService;
  msalGuardConfig;
  appConstants = AppConstants;
  title = "client-app";
  currentLanguage = {};
  isSidebarOpen = false;
  isNotificationSidebarOpen = false;
  currentEmployee;
  modalTemplate = null;
  _destroying$ = new Subject();
  loginDisplay = false;
  loginRequest;
  isLoading = true;
  selectedUser = {};
  eventSubscription;
  constructor(breadcrumbService, employeeService, idService, router, msalService, msalBroadcastService, sidebarService, storageService, supabaseAuthService, smsAuthService, appSettingsService, eventService, msalGuardConfig) {
    this.breadcrumbService = breadcrumbService;
    this.employeeService = employeeService;
    this.idService = idService;
    this.router = router;
    this.msalService = msalService;
    this.msalBroadcastService = msalBroadcastService;
    this.sidebarService = sidebarService;
    this.storageService = storageService;
    this.supabaseAuthService = supabaseAuthService;
    this.smsAuthService = smsAuthService;
    this.appSettingsService = appSettingsService;
    this.eventService = eventService;
    this.msalGuardConfig = msalGuardConfig;
  }
  ngOnInit() {
    this.initApp();
  }
  setLoginDisplay() {
    this.loginDisplay = this.msalService.instance.getAllAccounts().length > 0;
  }
  initApp() {
    this.sidebarService.loadState();
    this.initCurrentEmployee();
    this.initEventService();
    this.idService.loadStateFromStorage();
    this.appSettingsService.initAppSettings();
    this.sidebarService.loadMenuFromDatabase();
  }
  initCurrentEmployee() {
    this.supabaseAuthService.getCurrentEmployee$().subscribe((employee) => {
      if (!employee) {
        return;
      }
      this.currentEmployee = employee;
    });
  }
  initEventService() {
    this.eventSubscription = this.eventService.subscribe().subscribe((event) => {
      console.log("[EventService]", event.type, event.payload);
    });
  }
  toggleSidebar() {
    this.isSidebarOpen = !this.isSidebarOpen;
  }
  toggleNotificationSidebar() {
    this.isNotificationSidebarOpen = !this.isNotificationSidebarOpen;
  }
  loginRedirect() {
    if (this.msalGuardConfig.authRequest) {
      this.msalService.loginRedirect(__spreadValues({}, this.msalGuardConfig.authRequest));
    } else {
      this.msalService.loginRedirect();
    }
  }
  checkAndSetActiveAccount() {
    let activeAccount = this.msalService.instance.getActiveAccount();
    if (!activeAccount) {
      const accounts = this.msalService.instance.getAllAccounts();
      if (accounts.length > 0) {
        activeAccount = accounts[0];
        this.msalService.instance.setActiveAccount(activeAccount);
      } else {
        this.loginRedirect();
        return;
      }
    }
    this.acquireToken(activeAccount);
    this.finalizeLogin();
  }
  acquireToken(account) {
    this.msalService.acquireTokenSilent(__spreadProps(__spreadValues({}, this.msalGuardConfig.authRequest), {
      account
    })).subscribe({
      next: (tokenResponse) => {
        console.log("Token acquired:", tokenResponse);
      },
      error: (error) => {
        console.error("Token acquisition failed:", error);
        if (error instanceof InteractionRequiredAuthError) {
          console.warn("Interaction required, redirecting to login...");
          this.msalService.loginRedirect();
        }
      }
    });
  }
  finalizeLogin() {
    this.isAuthenticated$().subscribe((isAuthenticated) => {
      if (isAuthenticated) {
        this.initApp();
      }
    });
    this._destroying$.complete();
  }
  logout(popup) {
    this.idService.clearAllSubjects();
    window.location.href = "https://caesarealtd.sharepoint.com/sites/Home";
  }
  isLoginRoute() {
    return this.router.url === "/login";
  }
  ngOnDestroy() {
    if (this.eventSubscription) {
      this.eventSubscription.unsubscribe();
    }
    this._destroying$.next(void 0);
    this._destroying$.complete();
  }
  onFileChange(event) {
    this.storageService.uploadFile("feature-preview", "birthday-calendar.png", event.target.files[0]).then(() => {
    });
  }
  isAuthenticated$() {
    return combineLatest([
      this.smsAuthService.isAuthenticated$(),
      this.supabaseAuthService.isAuthenticated$()
    ]).pipe(map(([smsAuth, supabaseAuth]) => {
      return (smsAuth || !this.currentEmployee?.is_2fa_enabled) && supabaseAuth;
    }));
  }
  static \u0275fac = function AppComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppComponent)(\u0275\u0275directiveInject(BreadcrumbService), \u0275\u0275directiveInject(EmployeeService), \u0275\u0275directiveInject(IdService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(MsalService), \u0275\u0275directiveInject(MsalBroadcastService), \u0275\u0275directiveInject(SideBarService), \u0275\u0275directiveInject(StorageService), \u0275\u0275directiveInject(SupabaseAuthService), \u0275\u0275directiveInject(SMSAuthService), \u0275\u0275directiveInject(AppSettingsService), \u0275\u0275directiveInject(EventService), \u0275\u0275directiveInject(MSAL_GUARD_CONFIG));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], features: [\u0275\u0275ProvidersFeature([EmployeeRepository])], decls: 7, vars: 6, consts: [["authenticated", ""], ["notAuthenticated", ""], [4, "ngTemplateOutlet"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "ngClass"], ["dir", "rtl", 1, "page-wrapper"], [1, "content"]], template: function AppComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, AppComponent_ng_template_0_Template, 8, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, AppComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(4, AppComponent_ng_container_4_Template, 1, 0, "ng-container", 2)(5, AppComponent_ng_container_5_Template, 1, 0, "ng-container", 3);
      \u0275\u0275pipe(6, "async");
    }
    if (rf & 2) {
      const authenticated_r2 = \u0275\u0275reference(1);
      const notAuthenticated_r3 = \u0275\u0275reference(3);
      \u0275\u0275advance(4);
      \u0275\u0275property("ngTemplateOutlet", ctx.modalTemplate);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.currentEmployee && (ctx.currentEmployee.id && \u0275\u0275pipeBind1(6, 4, ctx.isAuthenticated$())))("ngIfThen", authenticated_r2)("ngIfElse", notAuthenticated_r3);
    }
  }, dependencies: [
    RouterOutlet,
    SidebarComponent,
    CommonModule,
    NgClass,
    NgIf,
    NgTemplateOutlet,
    AsyncPipe,
    BreadcrumbComponent,
    NgxSpinnerModule,
    TranslateModule,
    NavbarComponent
  ], styles: ["\n\n.not-authorized[_ngcontent-%COMP%] {\n  font-size: 24px;\n  font-weight: bold;\n  margin-top: 200px;\n  width: 360px;\n  margin-left: auto;\n  margin-right: auto;\n  color: #ff4d4d;\n  text-align: center;\n  padding: 20px;\n  border: 2px solid #ff4d4d;\n  border-radius: 8px;\n  animation: _ngcontent-%COMP%_glow 1.5s infinite;\n}\n.connection-container[_ngcontent-%COMP%] {\n  font-size: 24px;\n  font-weight: bold;\n  margin-top: 200px;\n  width: 360px;\n  margin-left: auto;\n  margin-right: auto;\n  color: #4e7eed;\n  text-align: center;\n  padding: 20px;\n  border: 2px solid #4e7eed;\n  border-radius: 8px;\n  animation: _ngcontent-%COMP%_glow 1.5s infinite;\n}\n@keyframes _ngcontent-%COMP%_glow {\n  0%, 100% {\n    box-shadow:\n      0 0 5px #ff4d4d,\n      0 0 10px #ff4d4d,\n      0 0 15px #ff4d4d,\n      0 0 20px #ff1a1a;\n  }\n  50% {\n    box-shadow:\n      0 0 10px #ff8080,\n      0 0 20px #ff8080,\n      0 0 30px #ff1a1a,\n      0 0 40px #ff1a1a;\n  }\n}\n.site-logo[_ngcontent-%COMP%] {\n  object-fit: contain;\n  max-width: 100%;\n  max-height: 100%;\n}\n/*# sourceMappingURL=app.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src/app/app.component.ts", lineNumber: 43 });
})();

// src/main.ts
bootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));
/*! Bundled license information:

@angular/platform-browser/fesm2022/animations/async.mjs:
  (**
   * @license Angular v19.2.3
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/rxjs-interop.mjs:
  (**
   * @license Angular v19.2.3
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=main.js.map
